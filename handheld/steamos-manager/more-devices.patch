From 5f03a6121d09bff0fc2bfdd86bce0d268a322869 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 12:33:36 -0700
Subject: [PATCH 01/15] platform: complete Legion Go integration

---
 data/platforms/legion-go.toml | 10 ++++++++++
 src/platform.rs               |  1 +
 2 files changed, 11 insertions(+)
 create mode 100644 data/platforms/legion-go.toml

diff --git a/data/platforms/legion-go.toml b/data/platforms/legion-go.toml
new file mode 100644
index 000000000000..7d5b7aef0d30
--- /dev/null
+++ b/data/platforms/legion-go.toml
@@ -0,0 +1,10 @@
+[performance_profile]
+platform_profile_name = "lenovo-wmi-gamezone"
+suggested_default = "custom"
+
+[tdp_limit]
+method = "firmware_attribute"
+
+[tdp_limit.firmware_attribute]
+attribute = "lenovo-wmi-other-0"
+performance_profile = "custom"
diff --git a/src/platform.rs b/src/platform.rs
index dbd7ca0fb83c..1c14c47282c4 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -165,6 +165,7 @@ impl PlatformConfig {
     async fn load() -> Result<Option<PlatformConfig>> {
         let platform = match device_type().await? {
             DeviceType::SteamDeck => "jupiter",
+            DeviceType::LegionGo  => "legion-go",
             DeviceType::LegionGoS => "legion-go-s",
             _ => return Ok(None),
         };
-- 
2.49.0


From a756fd262a4484b5d0b8d124bcb02c2a95c6f3c0 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 12:42:20 -0700
Subject: [PATCH 02/15] platform: complete ROG Ally + ROG Ally X integration

---
 data/platforms/rog-ally-x.toml | 12 ++++++++++++
 data/platforms/rog-ally.toml   | 12 ++++++++++++
 src/platform.rs                |  2 ++
 3 files changed, 26 insertions(+)
 create mode 100644 data/platforms/rog-ally-x.toml
 create mode 100644 data/platforms/rog-ally.toml

diff --git a/data/platforms/rog-ally-x.toml b/data/platforms/rog-ally-x.toml
new file mode 100644
index 000000000000..07d2c5f9eb94
--- /dev/null
+++ b/data/platforms/rog-ally-x.toml
@@ -0,0 +1,12 @@
+[performance_profile]
+platform_profile_name = "asus-wmi"
+# until custom mode is added
+suggested_default = "performance"
+
+[tdp_limit]
+method = "firmware_attribute"
+
+[tdp_limit.firmware_attribute]
+attribute = "asus-armoury"
+# until custom mode is added
+performance_profile = "performance"
diff --git a/data/platforms/rog-ally.toml b/data/platforms/rog-ally.toml
new file mode 100644
index 000000000000..07d2c5f9eb94
--- /dev/null
+++ b/data/platforms/rog-ally.toml
@@ -0,0 +1,12 @@
+[performance_profile]
+platform_profile_name = "asus-wmi"
+# until custom mode is added
+suggested_default = "performance"
+
+[tdp_limit]
+method = "firmware_attribute"
+
+[tdp_limit.firmware_attribute]
+attribute = "asus-armoury"
+# until custom mode is added
+performance_profile = "performance"
diff --git a/src/platform.rs b/src/platform.rs
index 1c14c47282c4..1f44180984e8 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -164,6 +164,8 @@ impl PlatformConfig {
     #[cfg(not(test))]
     async fn load() -> Result<Option<PlatformConfig>> {
         let platform = match device_type().await? {
+            DeviceType::RogAlly   => "rog-ally",
+            DeviceType::RogAllyX  => "rog-ally-x",
             DeviceType::SteamDeck => "jupiter",
             DeviceType::LegionGo  => "legion-go",
             DeviceType::LegionGoS => "legion-go-s",
-- 
2.49.0


From 842111f05606c64ea9e1d52d0c0b3e9ac6cf5dda Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 12:47:37 -0700
Subject: [PATCH 03/15] platform: complete ZOTAC Gaming Zone integration

---
 data/platforms/zotac-gaming-zone.toml | 10 ++++++++++
 src/platform.rs                       |  1 +
 2 files changed, 11 insertions(+)
 create mode 100644 data/platforms/zotac-gaming-zone.toml

diff --git a/data/platforms/zotac-gaming-zone.toml b/data/platforms/zotac-gaming-zone.toml
new file mode 100644
index 000000000000..3e3ba75f207d
--- /dev/null
+++ b/data/platforms/zotac-gaming-zone.toml
@@ -0,0 +1,10 @@
+[performance_profile]
+platform_profile_name = "zotac-zone-platform"
+suggested_default = "custom"
+
+[tdp_limit]
+method = "firmware_attribute"
+
+[tdp_limit.firmware_attribute]
+attribute = "zotac-zone-platform"
+performance_profile = "custom"
diff --git a/src/platform.rs b/src/platform.rs
index 1f44180984e8..b7531cce9923 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -169,6 +169,7 @@ impl PlatformConfig {
             DeviceType::SteamDeck => "jupiter",
             DeviceType::LegionGo  => "legion-go",
             DeviceType::LegionGoS => "legion-go-s",
+            DeviceType::ZotacGamingZone => "zotac-gaming-zone",
             _ => return Ok(None),
         };
         let config = read_to_string(format!(
-- 
2.49.0


From 263408a7722e7d19edbdbbb626571614b49fcc34 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 13:41:27 -0700
Subject: [PATCH 04/15] platform: normalize DeviceType order with hardware.rs

---
 src/platform.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/platform.rs b/src/platform.rs
index b7531cce9923..6343390cdaa1 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -166,9 +166,9 @@ impl PlatformConfig {
         let platform = match device_type().await? {
             DeviceType::RogAlly   => "rog-ally",
             DeviceType::RogAllyX  => "rog-ally-x",
-            DeviceType::SteamDeck => "jupiter",
             DeviceType::LegionGo  => "legion-go",
             DeviceType::LegionGoS => "legion-go-s",
+            DeviceType::SteamDeck => "jupiter",
             DeviceType::ZotacGamingZone => "zotac-gaming-zone",
             _ => return Ok(None),
         };
-- 
2.49.0


From e0ceb387423bd22b536bd5383435412e2aadce99 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 13:52:29 -0700
Subject: [PATCH 05/15] hardware: Detect MSI Claw series

---
 src/hardware.rs | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/hardware.rs b/src/hardware.rs
index 960e4b66b041..975f746012e5 100644
--- a/src/hardware.rs
+++ b/src/hardware.rs
@@ -36,6 +36,7 @@ pub(crate) enum DeviceType {
     #[default]
     Unknown,
     SteamDeck,
+    Claw,
     LegionGo,
     LegionGoS,
     RogAlly,
@@ -88,6 +89,11 @@ pub(crate) async fn device_variant() -> Result<(DeviceType, String)> {
         ("LENOVO", "83L3" | "83N6" | "83Q2" | "83Q3", _) => {
             (DeviceType::LegionGoS, product_name.to_string())
         }
+        (
+            "Micro-Star International Co., Ltd.",
+            "Claw A1M" | "Claw 7 AI+ A2VM" | "Claw 8 AI+ A2VM",
+            _,
+        ) => (DeviceType::Claw, product_name.to_string()),
         ("Valve", _, "Jupiter" | "Galileo") => (DeviceType::SteamDeck, board_name.to_string()),
         ("ZOTAC", _, "G0A1W") => (DeviceType::ZotacGamingZone, board_name.to_string()),
         _ => (DeviceType::Unknown, String::from("unknown")),
-- 
2.49.0


From 73abdd273c16c37e7db2a8a049032c235b05ddb7 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 13:53:16 -0700
Subject: [PATCH 06/15] platform: complete MSI Claw integration

---
 data/platforms/claw.toml | 12 ++++++++++++
 src/platform.rs          |  1 +
 2 files changed, 13 insertions(+)
 create mode 100644 data/platforms/claw.toml

diff --git a/data/platforms/claw.toml b/data/platforms/claw.toml
new file mode 100644
index 000000000000..fe61b661ce1f
--- /dev/null
+++ b/data/platforms/claw.toml
@@ -0,0 +1,12 @@
+[performance_profile]
+platform_profile_name = "msi-wmi-platform"
+# until custom mode is added
+suggested_default = "performance"
+
+[tdp_limit]
+method = "firmware_attribute"
+
+[tdp_limit.firmware_attribute]
+attribute = "msi-wmi-platform"
+# until custom mode is added
+performance_profile = "performance"
diff --git a/src/platform.rs b/src/platform.rs
index 6343390cdaa1..fcd41b5e07e3 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -168,6 +168,7 @@ impl PlatformConfig {
             DeviceType::RogAllyX  => "rog-ally-x",
             DeviceType::LegionGo  => "legion-go",
             DeviceType::LegionGoS => "legion-go-s",
+            DeviceType::Claw      => "claw",
             DeviceType::SteamDeck => "jupiter",
             DeviceType::ZotacGamingZone => "zotac-gaming-zone",
             _ => return Ok(None),
-- 
2.49.0


From ef14ddf228849e87380c11b5471d0156d8ff6554 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 25 Apr 2025 22:34:59 +0800
Subject: [PATCH 07/15] power: add support for Intel GPU frequency control

---
 src/power.rs | 351 +++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 283 insertions(+), 68 deletions(-)

diff --git a/src/power.rs b/src/power.rs
index d026f8d95327..83760b66449c 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -339,94 +339,309 @@ pub(crate) async fn set_cpu_scaling_governor(governor: CPUScalingGovernor) -> Re
     write_cpu_governor_sysfs_contents(name).await
 }
 
-pub(crate) async fn get_gpu_clocks_range() -> Result<RangeInclusive<u32>> {
-    if let Some(range) = platform_config()
-        .await?
-        .as_ref()
-        .and_then(|config| config.gpu_clocks)
-    {
-        return Ok(range.min..=range.max);
-    }
-    let contents = read_gpu_sysfs_contents(GPU_CLOCK_LEVELS_SUFFIX).await?;
-    let lines = contents.lines();
-    let mut min = 1_000_000;
-    let mut max = 0;
+#[async_trait]
+trait GpuClockController: Send + Sync {
+    async fn get_clocks_range(&self) -> Result<RangeInclusive<u32>>;
+    async fn set_clocks(&self, clocks: u32) -> Result<()>;
+    async fn get_clocks(&self) -> Result<u32>;
+}
 
-    for line in lines {
-        let Some(caps) = GPU_CLOCK_LEVELS_REGEX.captures(line) else {
-            continue;
-        };
-        let value: u32 = caps["value"]
-            .parse()
-            .map_err(|message| anyhow!("Unable to parse value for GPU power profile: {message}"))?;
-        if value < min {
-            min = value;
+// AMD GPU controller implementation using HWMON
+struct AmdGpuController {
+    hwmon_path: PathBuf,
+}
+
+#[async_trait]
+impl GpuClockController for AmdGpuController {
+    async fn get_clocks_range(&self) -> Result<RangeInclusive<u32>> {
+        let contents = fs::read_to_string(self.hwmon_path.join(GPU_CLOCK_LEVELS_SUFFIX))
+            .await
+            .map_err(|message| anyhow!("Error opening sysfs file for reading {message}"))?;
+
+        let lines = contents.lines();
+        let mut min = 1_000_000;
+        let mut max = 0;
+
+        for line in lines {
+            let Some(caps) = GPU_CLOCK_LEVELS_REGEX.captures(line) else {
+                continue;
+            };
+            let value: u32 = caps["value"].parse().map_err(|message| {
+                anyhow!("Unable to parse value for GPU power profile: {message}")
+            })?;
+            if value < min {
+                min = value;
+            }
+            if value > max {
+                max = value;
+            }
         }
-        if value > max {
-            max = value;
+
+        ensure!(min <= max, "Could not read any clocks");
+        Ok(min..=max)
+    }
+
+    async fn set_clocks(&self, clocks: u32) -> Result<()> {
+        let mut myfile = File::create(self.hwmon_path.join(GPU_CLOCKS_SUFFIX))
+            .await
+            .inspect_err(|message| error!("Error opening sysfs file for writing: {message}"))?;
+
+        let data = format!("s 0 {clocks}\n");
+        myfile
+            .write(data.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        let data = format!("s 1 {clocks}\n");
+        myfile
+            .write(data.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        myfile
+            .write("c\n".as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        Ok(())
+    }
+
+    async fn get_clocks(&self) -> Result<u32> {
+        let clocks_file = File::open(self.hwmon_path.join(GPU_CLOCKS_SUFFIX)).await?;
+        let mut reader = BufReader::new(clocks_file);
+        loop {
+            let mut line = String::new();
+            if reader.read_line(&mut line).await? == 0 {
+                break;
+            }
+            if line != "OD_SCLK:\n" {
+                continue;
+            }
+
+            let mut line = String::new();
+            if reader.read_line(&mut line).await? == 0 {
+                break;
+            }
+            let mhz = match line.split_whitespace().nth(1) {
+                Some(mhz) if mhz.ends_with("Mhz") => mhz.trim_end_matches("Mhz"),
+                _ => break,
+            };
+
+            return Ok(mhz.parse()?);
         }
+        Ok(0)
     }
+}
 
-    ensure!(min <= max, "Could not read any clocks");
-    Ok(min..=max)
+// Intel GPU controller implementation using i915 driver
+struct IntelI915Controller {
+    path: PathBuf,
 }
 
-pub(crate) async fn set_gpu_clocks(clocks: u32) -> Result<()> {
-    // Set GPU clocks to given value valid
-    // Only used when GPU Performance Level is manual, but write whenever called.
-    let base = find_hwmon(GPU_HWMON_NAME).await?;
-    let mut myfile = File::create(base.join(GPU_CLOCKS_SUFFIX))
-        .await
-        .inspect_err(|message| error!("Error opening sysfs file for writing: {message}"))?;
+#[async_trait]
+impl GpuClockController for IntelI915Controller {
+    async fn get_clocks_range(&self) -> Result<RangeInclusive<u32>> {
+        // For i915, the supported frequency range is in the rps_* files
+        let min_path = self.path.join("gt_RPn_freq_mhz");
+        let max_path = self.path.join("gt_RP0_freq_mhz");
 
-    let data = format!("s 0 {clocks}\n");
-    myfile
-        .write(data.as_bytes())
-        .await
-        .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
-    myfile.flush().await?;
+        let min_val = fs::read_to_string(min_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel min freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing min freq: {e}"))?;
 
-    let data = format!("s 1 {clocks}\n");
-    myfile
-        .write(data.as_bytes())
-        .await
-        .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
-    myfile.flush().await?;
+        let max_val = fs::read_to_string(max_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel max freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing max freq: {e}"))?;
 
-    myfile
-        .write("c\n".as_bytes())
-        .await
-        .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
-    myfile.flush().await?;
+        Ok(min_val..=max_val)
+    }
+
+    async fn set_clocks(&self, clocks: u32) -> Result<()> {
+        // For Intel, we set both min and max to the same value to force the frequency
+        let min_path = self.path.join("gt_min_freq_mhz");
+        let max_path = self.path.join("gt_max_freq_mhz");
 
-    Ok(())
+        let clocks_str = clocks.to_string();
+
+        write_synced(min_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel min freq: {message}"))?;
+
+        write_synced(max_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel max freq: {message}"))?;
+
+        Ok(())
+    }
+
+    async fn get_clocks(&self) -> Result<u32> {
+        let cur_path = self.path.join("gt_act_freq_mhz");
+
+        let cur_val = fs::read_to_string(cur_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel current freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing current freq: {e}"))?;
+
+        Ok(cur_val)
+    }
 }
 
-pub(crate) async fn get_gpu_clocks() -> Result<u32> {
-    let base = find_hwmon(GPU_HWMON_NAME).await?;
-    let clocks_file = File::open(base.join(GPU_CLOCKS_SUFFIX)).await?;
-    let mut reader = BufReader::new(clocks_file);
-    loop {
-        let mut line = String::new();
-        if reader.read_line(&mut line).await? == 0 {
-            break;
+// Intel GPU controller implementation using Xe driver
+struct IntelXeController {
+    path: PathBuf,
+}
+
+#[async_trait]
+impl GpuClockController for IntelXeController {
+    async fn get_clocks_range(&self) -> Result<RangeInclusive<u32>> {
+        // For Xe, directly use hardware limits
+        let min_path = self.path.join("device/tile0/gt0/freq0/rpn_freq");
+        let max_path = self.path.join("device/tile0/gt0/freq0/rp0_freq");
+
+        let min_val = fs::read_to_string(min_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel Xe min freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing min freq: {e}"))?;
+
+        let max_val = fs::read_to_string(max_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel Xe max freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing max freq: {e}"))?;
+
+        Ok(min_val..=max_val)
+    }
+
+    async fn set_clocks(&self, clocks: u32) -> Result<()> {
+        let min_path = self.path.join("device/tile0/gt0/freq0/min_freq");
+        let max_path = self.path.join("device/tile0/gt0/freq0/max_freq");
+
+        let clocks_str = clocks.to_string();
+
+        write_synced(min_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel Xe min freq: {message}"))?;
+
+        write_synced(max_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel Xe max freq: {message}"))?;
+
+        Ok(())
+    }
+
+    async fn get_clocks(&self) -> Result<u32> {
+        let cur_path = self.path.join("device/tile0/gt0/freq0/cur_freq");
+
+        let cur_val = fs::read_to_string(cur_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel Xe current freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing current freq: {e}"))?;
+
+        Ok(cur_val)
+    }
+}
+
+// Helper function to check if a path exists
+async fn path_exists(path: impl AsRef<Path>) -> bool {
+    match try_exists(path).await {
+        Ok(exists) => exists,
+        Err(_) => false,
+    }
+}
+
+// Helper function to check if a GPU is enabled
+async fn is_gpu_enabled(card_path: impl AsRef<Path>) -> bool {
+    let enable_path = card_path.as_ref().join("device/enable");
+
+    if !path_exists(&enable_path).await {
+        return true; // Assume enabled if no enable file exists
+    }
+
+    match fs::read_to_string(&enable_path).await {
+        Ok(content) => content.trim() == "1",
+        Err(_) => true, // Assume enabled if can't read the file
+    }
+}
+
+// Factory function to get the appropriate GPU controller
+async fn get_gpu_controller() -> Result<Box<dyn GpuClockController>> {
+    // First try AMD GPU via HWMON
+    if let Ok(path) = find_hwmon(GPU_HWMON_NAME).await {
+        debug!("Found AMD GPU via HWMON");
+        return Ok(Box::new(AmdGpuController { hwmon_path: path }));
+    }
+
+    // If no AMD GPU, try Intel GPUs
+    for card_num in 0..4 {
+        // Check card0 to card3
+        let card_path = PathBuf::from(format!("/sys/class/drm/card{}", card_num));
+
+        // Skip if path doesn't exist
+        if !path_exists(&card_path).await {
+            continue;
         }
-        if line != "OD_SCLK:\n" {
+
+        // Skip if GPU is disabled
+        if !is_gpu_enabled(&card_path).await {
+            debug!("Skipping disabled GPU at {}", card_path.display());
             continue;
         }
 
-        let mut line = String::new();
-        if reader.read_line(&mut line).await? == 0 {
-            break;
+        // Check for Intel i915
+        if path_exists(card_path.join("gt_min_freq_mhz")).await {
+            debug!("Found Intel i915 GPU at {}", card_path.display());
+            return Ok(Box::new(IntelI915Controller { path: card_path }));
         }
-        let mhz = match line.split_whitespace().nth(1) {
-            Some(mhz) if mhz.ends_with("Mhz") => mhz.trim_end_matches("Mhz"),
-            _ => break,
-        };
 
-        return Ok(mhz.parse()?);
+        // Check for Intel Xe
+        if path_exists(card_path.join("device/tile0/gt0/freq0/min_freq")).await {
+            debug!("Found Intel Xe GPU at {}", card_path.display());
+            return Ok(Box::new(IntelXeController { path: card_path }));
+        }
     }
-    Ok(0)
+
+    bail!("No supported GPU found")
+}
+
+pub(crate) async fn get_gpu_clocks_range() -> Result<RangeInclusive<u32>> {
+    // First try to get from config
+    if let Some(range) = platform_config()
+        .await?
+        .as_ref()
+        .and_then(|config| config.gpu_clocks)
+    {
+        return Ok(range.min..=range.max);
+    }
+
+    // If no config, use the appropriate controller
+    let controller = get_gpu_controller().await?;
+    controller.get_clocks_range().await
+}
+
+pub(crate) async fn set_gpu_clocks(clocks: u32) -> Result<()> {
+    let controller = get_gpu_controller().await?;
+    controller.set_clocks(clocks).await
+}
+
+pub(crate) async fn get_gpu_clocks() -> Result<u32> {
+    let controller = get_gpu_controller().await?;
+    controller.get_clocks().await
 }
 
 async fn find_sysdir(prefix: impl AsRef<Path>, expected: &str) -> Result<PathBuf> {
-- 
2.49.0


From 0c5531c589d3d20fa80a9f15db075b20b3bc364b Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 25 Apr 2025 23:53:29 +0800
Subject: [PATCH 08/15] power: add Intel GPU performance level support

---
 src/power.rs | 119 ++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 108 insertions(+), 11 deletions(-)

diff --git a/src/power.rs b/src/power.rs
index 83760b66449c..91b5c500cb5c 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -280,9 +280,36 @@ pub(crate) async fn set_gpu_power_profile(value: GPUPowerProfile) -> Result<()>
     write_gpu_sysfs_contents(GPU_POWER_PROFILE_SUFFIX, profile.as_bytes()).await
 }
 
-pub(crate) async fn get_available_gpu_performance_levels() -> Result<Vec<GPUPerformanceLevel>> {
-    let base = find_hwmon(GPU_HWMON_NAME).await?;
-    if try_exists(base.join(GPU_PERFORMANCE_LEVEL_SUFFIX)).await? {
+// GPU performance level controller interface
+#[async_trait]
+trait GpuPerformanceLevelController: Send + Sync {
+    async fn get_performance_level(&self) -> Result<GPUPerformanceLevel>;
+    async fn set_performance_level(&self, level: GPUPerformanceLevel) -> Result<()>;
+    async fn get_available_performance_levels(&self) -> Result<Vec<GPUPerformanceLevel>>;
+}
+
+// AMD GPU performance level controller implementation
+struct AmdGpuPerformanceController {
+    hwmon_path: PathBuf,
+}
+
+#[async_trait]
+impl GpuPerformanceLevelController for AmdGpuPerformanceController {
+    async fn get_performance_level(&self) -> Result<GPUPerformanceLevel> {
+        let level = fs::read_to_string(self.hwmon_path.join(GPU_PERFORMANCE_LEVEL_SUFFIX))
+            .await
+            .map_err(|message| anyhow!("Error reading performance level: {message}"))?;
+        Ok(GPUPerformanceLevel::from_str(level.trim())?)
+    }
+
+    async fn set_performance_level(&self, level: GPUPerformanceLevel) -> Result<()> {
+        let level_str = level.to_string();
+        write_synced(self.hwmon_path.join(GPU_PERFORMANCE_LEVEL_SUFFIX), level_str.as_bytes())
+            .await
+            .map_err(|message| anyhow!("Error setting performance level: {message}"))
+    }
+
+    async fn get_available_performance_levels(&self) -> Result<Vec<GPUPerformanceLevel>> {
         Ok(vec![
             GPUPerformanceLevel::Auto,
             GPUPerformanceLevel::Low,
@@ -290,19 +317,89 @@ pub(crate) async fn get_available_gpu_performance_levels() -> Result<Vec<GPUPerf
             GPUPerformanceLevel::Manual,
             GPUPerformanceLevel::ProfilePeak,
         ])
-    } else {
-        Ok(Vec::new())
     }
 }
 
+// Intel GPU performance level controller implementation
+struct IntelGpuPerformanceController {
+    clock_controller: Box<dyn GpuClockController>,
+}
+
+#[async_trait]
+impl GpuPerformanceLevelController for IntelGpuPerformanceController {
+    async fn get_performance_level(&self) -> Result<GPUPerformanceLevel> {
+        // Determine mode by checking current clock frequency
+        let current = self.clock_controller.get_clocks().await?;
+        let range = self.clock_controller.get_clocks_range().await?;
+
+        // If frequency is at extreme values, consider it Manual mode
+        if current == *range.start() || current == *range.end() {
+            Ok(GPUPerformanceLevel::Manual)
+        } else {
+            Ok(GPUPerformanceLevel::Auto)
+        }
+    }
+
+    async fn set_performance_level(&self, level: GPUPerformanceLevel) -> Result<()> {
+        match level {
+            GPUPerformanceLevel::Auto => {
+                // Auto mode: set to mid-range frequency
+                let range = self.clock_controller.get_clocks_range().await?;
+                let min = *range.start();
+                let max = *range.end();
+                let mid = min + (max - min) / 2;
+                self.clock_controller.set_clocks(mid).await
+            },
+            GPUPerformanceLevel::Manual => {
+                // Manual mode: do nothing, user will set specific frequency later
+                Ok(())
+            },
+            _ => {
+                // Other modes not supported
+                bail!("Intel GPU only supports Auto and Manual performance levels")
+            }
+        }
+    }
+
+    async fn get_available_performance_levels(&self) -> Result<Vec<GPUPerformanceLevel>> {
+        // Intel GPU only supports two modes
+        Ok(vec![
+            GPUPerformanceLevel::Auto,
+            GPUPerformanceLevel::Manual,
+        ])
+    }
+}
+
+// Factory function to get appropriate GPU performance controller
+async fn get_gpu_performance_controller() -> Result<Box<dyn GpuPerformanceLevelController>> {
+    // First try AMD GPU
+    if let Ok(path) = find_hwmon(GPU_HWMON_NAME).await {
+        if try_exists(path.join(GPU_PERFORMANCE_LEVEL_SUFFIX)).await.unwrap_or(false) {
+            return Ok(Box::new(AmdGpuPerformanceController { hwmon_path: path }));
+        }
+    }
+
+    // Then try Intel GPU
+    let controller = get_gpu_controller().await?;
+    Ok(Box::new(IntelGpuPerformanceController {
+        clock_controller: controller,
+    }))
+}
+
+// Update public API functions to use the controller
+pub(crate) async fn get_available_gpu_performance_levels() -> Result<Vec<GPUPerformanceLevel>> {
+    let controller = get_gpu_performance_controller().await?;
+    controller.get_available_performance_levels().await
+}
+
 pub(crate) async fn get_gpu_performance_level() -> Result<GPUPerformanceLevel> {
-    let level = read_gpu_sysfs_contents(GPU_PERFORMANCE_LEVEL_SUFFIX).await?;
-    Ok(GPUPerformanceLevel::from_str(level.trim())?)
+    let controller = get_gpu_performance_controller().await?;
+    controller.get_performance_level().await
 }
 
 pub(crate) async fn set_gpu_performance_level(level: GPUPerformanceLevel) -> Result<()> {
-    let level: String = level.to_string();
-    write_gpu_sysfs_contents(GPU_PERFORMANCE_LEVEL_SUFFIX, level.as_bytes()).await
+    let controller = get_gpu_performance_controller().await?;
+    controller.set_performance_level(level).await
 }
 
 pub(crate) async fn get_available_cpu_scaling_governors() -> Result<Vec<CPUScalingGovernor>> {
@@ -484,7 +581,7 @@ impl GpuClockController for IntelI915Controller {
     }
 
     async fn get_clocks(&self) -> Result<u32> {
-        let cur_path = self.path.join("gt_act_freq_mhz");
+        let cur_path = self.path.join("gt_max_freq_mhz");
 
         let cur_val = fs::read_to_string(cur_path)
             .await
@@ -544,7 +641,7 @@ impl GpuClockController for IntelXeController {
     }
 
     async fn get_clocks(&self) -> Result<u32> {
-        let cur_path = self.path.join("device/tile0/gt0/freq0/cur_freq");
+        let cur_path = self.path.join("device/tile0/gt0/freq0/max_freq");
 
         let cur_val = fs::read_to_string(cur_path)
             .await
-- 
2.49.0


From ca6bcdb308547ea3f9a42e640cde22c51a4b9643 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Fri, 25 Apr 2025 23:59:52 +0800
Subject: [PATCH 09/15] power: Refactor performance level setting and improve
 code formatting

---
 src/power.rs | 125 +++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 111 insertions(+), 14 deletions(-)

diff --git a/src/power.rs b/src/power.rs
index 91b5c500cb5c..0d1014fdfbb9 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -304,9 +304,12 @@ impl GpuPerformanceLevelController for AmdGpuPerformanceController {
 
     async fn set_performance_level(&self, level: GPUPerformanceLevel) -> Result<()> {
         let level_str = level.to_string();
-        write_synced(self.hwmon_path.join(GPU_PERFORMANCE_LEVEL_SUFFIX), level_str.as_bytes())
-            .await
-            .map_err(|message| anyhow!("Error setting performance level: {message}"))
+        write_synced(
+            self.hwmon_path.join(GPU_PERFORMANCE_LEVEL_SUFFIX),
+            level_str.as_bytes(),
+        )
+        .await
+        .map_err(|message| anyhow!("Error setting performance level: {message}"))
     }
 
     async fn get_available_performance_levels(&self) -> Result<Vec<GPUPerformanceLevel>> {
@@ -343,17 +346,19 @@ impl GpuPerformanceLevelController for IntelGpuPerformanceController {
     async fn set_performance_level(&self, level: GPUPerformanceLevel) -> Result<()> {
         match level {
             GPUPerformanceLevel::Auto => {
-                // Auto mode: set to mid-range frequency
+                // Auto mode: reset min/max to hardware range for dynamic frequency adjustment
                 let range = self.clock_controller.get_clocks_range().await?;
                 let min = *range.start();
                 let max = *range.end();
-                let mid = min + (max - min) / 2;
-                self.clock_controller.set_clocks(mid).await
-            },
+
+                // Set min and max frequencies to hardware limits
+                self.clock_controller.set_min_clocks(min).await?;
+                self.clock_controller.set_max_clocks(max).await
+            }
             GPUPerformanceLevel::Manual => {
                 // Manual mode: do nothing, user will set specific frequency later
                 Ok(())
-            },
+            }
             _ => {
                 // Other modes not supported
                 bail!("Intel GPU only supports Auto and Manual performance levels")
@@ -363,24 +368,28 @@ impl GpuPerformanceLevelController for IntelGpuPerformanceController {
 
     async fn get_available_performance_levels(&self) -> Result<Vec<GPUPerformanceLevel>> {
         // Intel GPU only supports two modes
-        Ok(vec![
-            GPUPerformanceLevel::Auto,
-            GPUPerformanceLevel::Manual,
-        ])
+        Ok(vec![GPUPerformanceLevel::Auto, GPUPerformanceLevel::Manual])
     }
 }
 
 // Factory function to get appropriate GPU performance controller
 async fn get_gpu_performance_controller() -> Result<Box<dyn GpuPerformanceLevelController>> {
+    debug!("Getting GPU performance controller");
     // First try AMD GPU
     if let Ok(path) = find_hwmon(GPU_HWMON_NAME).await {
-        if try_exists(path.join(GPU_PERFORMANCE_LEVEL_SUFFIX)).await.unwrap_or(false) {
+        if try_exists(path.join(GPU_PERFORMANCE_LEVEL_SUFFIX))
+            .await
+            .unwrap_or(false)
+        {
             return Ok(Box::new(AmdGpuPerformanceController { hwmon_path: path }));
         }
     }
 
     // Then try Intel GPU
-    let controller = get_gpu_controller().await?;
+    debug!("Getting Intel GPU performance controller");
+    let controller = get_gpu_controller()
+        .await
+        .inspect_err(|message| error!("Error getting GPU controller: {message}"))?;
     Ok(Box::new(IntelGpuPerformanceController {
         clock_controller: controller,
     }))
@@ -441,6 +450,8 @@ trait GpuClockController: Send + Sync {
     async fn get_clocks_range(&self) -> Result<RangeInclusive<u32>>;
     async fn set_clocks(&self, clocks: u32) -> Result<()>;
     async fn get_clocks(&self) -> Result<u32>;
+    async fn set_min_clocks(&self, clocks: u32) -> Result<()>;
+    async fn set_max_clocks(&self, clocks: u32) -> Result<()>;
 }
 
 // AMD GPU controller implementation using HWMON
@@ -531,6 +542,54 @@ impl GpuClockController for AmdGpuController {
         }
         Ok(0)
     }
+
+    async fn set_min_clocks(&self, clocks: u32) -> Result<()> {
+        // For AMD GPUs, set the lower limit (s 0)
+        let mut myfile = File::create(self.hwmon_path.join(GPU_CLOCKS_SUFFIX))
+            .await
+            .inspect_err(|message| error!("Error opening sysfs file for writing: {message}"))?;
+
+        // s 0 sets the lower limit
+        let data = format!("s 0 {clocks}\n");
+        myfile
+            .write(data.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        // Commit changes
+        myfile
+            .write("c\n".as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        Ok(())
+    }
+
+    async fn set_max_clocks(&self, clocks: u32) -> Result<()> {
+        // For AMD GPUs, set the upper limit (s 1)
+        let mut myfile = File::create(self.hwmon_path.join(GPU_CLOCKS_SUFFIX))
+            .await
+            .inspect_err(|message| error!("Error opening sysfs file for writing: {message}"))?;
+
+        // s 1 sets the upper limit
+        let data = format!("s 1 {clocks}\n");
+        myfile
+            .write(data.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        // Commit changes
+        myfile
+            .write("c\n".as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to sysfs file: {message}"))?;
+        myfile.flush().await?;
+
+        Ok(())
+    }
 }
 
 // Intel GPU controller implementation using i915 driver
@@ -592,6 +651,25 @@ impl GpuClockController for IntelI915Controller {
 
         Ok(cur_val)
     }
+
+    // New methods to set min and max clocks separately for i915
+    async fn set_min_clocks(&self, clocks: u32) -> Result<()> {
+        let min_path = self.path.join("gt_min_freq_mhz");
+        let clocks_str = clocks.to_string();
+
+        write_synced(min_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel min freq: {message}"))
+    }
+
+    async fn set_max_clocks(&self, clocks: u32) -> Result<()> {
+        let max_path = self.path.join("gt_max_freq_mhz");
+        let clocks_str = clocks.to_string();
+
+        write_synced(max_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel max freq: {message}"))
+    }
 }
 
 // Intel GPU controller implementation using Xe driver
@@ -652,6 +730,25 @@ impl GpuClockController for IntelXeController {
 
         Ok(cur_val)
     }
+
+    // New methods to set min and max clocks separately for Xe
+    async fn set_min_clocks(&self, clocks: u32) -> Result<()> {
+        let min_path = self.path.join("device/tile0/gt0/freq0/min_freq");
+        let clocks_str = clocks.to_string();
+
+        write_synced(min_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel Xe min freq: {message}"))
+    }
+
+    async fn set_max_clocks(&self, clocks: u32) -> Result<()> {
+        let max_path = self.path.join("device/tile0/gt0/freq0/max_freq");
+        let clocks_str = clocks.to_string();
+
+        write_synced(max_path, clocks_str.as_bytes())
+            .await
+            .inspect_err(|message| error!("Error writing to Intel Xe max freq: {message}"))
+    }
 }
 
 // Helper function to check if a path exists
-- 
2.49.0


From f74be2007c0413153c3cd08ada1fd6d29804ff63 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Sat, 26 Apr 2025 01:50:22 +0800
Subject: [PATCH 10/15] power: Add min and max clock frequency retrieval for
 GPU controllers

---
 src/power.rs | 103 +++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 96 insertions(+), 7 deletions(-)

diff --git a/src/power.rs b/src/power.rs
index 0d1014fdfbb9..28f20ae1b9b5 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -331,15 +331,15 @@ struct IntelGpuPerformanceController {
 #[async_trait]
 impl GpuPerformanceLevelController for IntelGpuPerformanceController {
     async fn get_performance_level(&self) -> Result<GPUPerformanceLevel> {
-        // Determine mode by checking current clock frequency
-        let current = self.clock_controller.get_clocks().await?;
         let range = self.clock_controller.get_clocks_range().await?;
+        let min_clock = self.clock_controller.get_min_clocks().await?;
+        let max_clock = self.clock_controller.get_max_clocks().await?;
 
-        // If frequency is at extreme values, consider it Manual mode
-        if current == *range.start() || current == *range.end() {
-            Ok(GPUPerformanceLevel::Manual)
-        } else {
+        // If min same as range start and max same as range end, consider it Auto mode
+        if min_clock == *range.start() && max_clock == *range.end() {
             Ok(GPUPerformanceLevel::Auto)
+        } else {
+            Ok(GPUPerformanceLevel::Manual)
         }
     }
 
@@ -451,7 +451,9 @@ trait GpuClockController: Send + Sync {
     async fn set_clocks(&self, clocks: u32) -> Result<()>;
     async fn get_clocks(&self) -> Result<u32>;
     async fn set_min_clocks(&self, clocks: u32) -> Result<()>;
+    async fn get_min_clocks(&self) -> Result<u32>;
     async fn set_max_clocks(&self, clocks: u32) -> Result<()>;
+    async fn get_max_clocks(&self) -> Result<u32>;
 }
 
 // AMD GPU controller implementation using HWMON
@@ -567,6 +569,28 @@ impl GpuClockController for AmdGpuController {
         Ok(())
     }
 
+    async fn get_min_clocks(&self) -> Result<u32> {
+        let contents = fs::read_to_string(self.hwmon_path.join(GPU_CLOCKS_SUFFIX))
+            .await
+            .map_err(|message| anyhow!("Error opening sysfs file for reading {message}"))?;
+
+        for line in contents.lines() {
+            let Some(caps) = GPU_CLOCK_LEVELS_REGEX.captures(line) else {
+                continue;
+            };
+
+            // Only find the entry with index 0
+            if &caps["index"] == "0" {
+                let value: u32 = caps["value"].parse().map_err(|message| {
+                    anyhow!("Unable to parse value for GPU power profile: {message}")
+                })?;
+                return Ok(value);
+            }
+        }
+
+        bail!("Could not find minimum GPU clock frequency (index 0) in the clock data")
+    }
+
     async fn set_max_clocks(&self, clocks: u32) -> Result<()> {
         // For AMD GPUs, set the upper limit (s 1)
         let mut myfile = File::create(self.hwmon_path.join(GPU_CLOCKS_SUFFIX))
@@ -590,9 +614,31 @@ impl GpuClockController for AmdGpuController {
 
         Ok(())
     }
+
+    async fn get_max_clocks(&self) -> Result<u32> {
+        let contents = fs::read_to_string(self.hwmon_path.join(GPU_CLOCKS_SUFFIX))
+            .await
+            .map_err(|message| anyhow!("Error opening sysfs file for reading {message}"))?;
+
+        for line in contents.lines() {
+            let Some(caps) = GPU_CLOCK_LEVELS_REGEX.captures(line) else {
+                continue;
+            };
+
+            // Only find the entry with index 1
+            if &caps["index"] == "1" {
+                let value: u32 = caps["value"].parse().map_err(|message| {
+                    anyhow!("Unable to parse value for GPU power profile: {message}")
+                })?;
+                return Ok(value);
+            }
+        }
+
+        bail!("Could not find maximum GPU clock frequency (index 1) in the clock data")
+    }
 }
 
-// Intel GPU controller implementation using i915 driver
+// Intel GPU controller implementation using Xe driver
 struct IntelI915Controller {
     path: PathBuf,
 }
@@ -662,6 +708,16 @@ impl GpuClockController for IntelI915Controller {
             .inspect_err(|message| error!("Error writing to Intel min freq: {message}"))
     }
 
+    async fn get_min_clocks(&self) -> Result<u32> {
+        let min_path = self.path.join("gt_min_freq_mhz");
+        let min_val = fs::read_to_string(min_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel min freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing min freq: {e}"))?;
+        Ok(min_val)
+    }
     async fn set_max_clocks(&self, clocks: u32) -> Result<()> {
         let max_path = self.path.join("gt_max_freq_mhz");
         let clocks_str = clocks.to_string();
@@ -670,6 +726,17 @@ impl GpuClockController for IntelI915Controller {
             .await
             .inspect_err(|message| error!("Error writing to Intel max freq: {message}"))
     }
+
+    async fn get_max_clocks(&self) -> Result<u32> {
+        let max_path = self.path.join("gt_max_freq_mhz");
+        let max_val = fs::read_to_string(max_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel max freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing max freq: {e}"))?;
+        Ok(max_val)
+    }
 }
 
 // Intel GPU controller implementation using Xe driver
@@ -741,6 +808,17 @@ impl GpuClockController for IntelXeController {
             .inspect_err(|message| error!("Error writing to Intel Xe min freq: {message}"))
     }
 
+    async fn get_min_clocks(&self) -> Result<u32> {
+        let min_path = self.path.join("device/tile0/gt0/freq0/min_freq");
+        let min_val = fs::read_to_string(min_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel Xe min freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing min freq: {e}"))?;
+        Ok(min_val)
+    }
+
     async fn set_max_clocks(&self, clocks: u32) -> Result<()> {
         let max_path = self.path.join("device/tile0/gt0/freq0/max_freq");
         let clocks_str = clocks.to_string();
@@ -749,6 +827,17 @@ impl GpuClockController for IntelXeController {
             .await
             .inspect_err(|message| error!("Error writing to Intel Xe max freq: {message}"))
     }
+
+    async fn get_max_clocks(&self) -> Result<u32> {
+        let max_path = self.path.join("device/tile0/gt0/freq0/max_freq");
+        let max_val = fs::read_to_string(max_path)
+            .await
+            .map_err(|message| anyhow!("Error reading Intel Xe max freq: {message}"))?
+            .trim()
+            .parse::<u32>()
+            .map_err(|e| anyhow!("Error parsing max freq: {e}"))?;
+        Ok(max_val)
+    }
 }
 
 // Helper function to check if a path exists
-- 
2.49.0


From 65e423419964fa8609941891df2ba03ee678dde3 Mon Sep 17 00:00:00 2001
From: honjow <honjow311@gmail.com>
Date: Sat, 26 Apr 2025 02:09:38 +0800
Subject: [PATCH 11/15] power: Update GPU clock frequency retrieval to use
 minimum frequency paths

---
 src/power.rs | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/power.rs b/src/power.rs
index 28f20ae1b9b5..cd3710ff88c8 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -686,7 +686,7 @@ impl GpuClockController for IntelI915Controller {
     }
 
     async fn get_clocks(&self) -> Result<u32> {
-        let cur_path = self.path.join("gt_max_freq_mhz");
+        let cur_path = self.path.join("gt_min_freq_mhz");
 
         let cur_val = fs::read_to_string(cur_path)
             .await
@@ -786,7 +786,7 @@ impl GpuClockController for IntelXeController {
     }
 
     async fn get_clocks(&self) -> Result<u32> {
-        let cur_path = self.path.join("device/tile0/gt0/freq0/max_freq");
+        let cur_path = self.path.join("device/tile0/gt0/freq0/min_freq");
 
         let cur_val = fs::read_to_string(cur_path)
             .await
-- 
2.49.0


From ebe9161f90ebd1637c41ad8400cb982053c1b9ea Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Fri, 16 May 2025 21:57:00 -0700
Subject: [PATCH 12/15] power: Fix tests after Intel refactor

---
 src/power.rs | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/power.rs b/src/power.rs
index cd3710ff88c8..1670a93cfab5 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -1376,6 +1376,8 @@ pub(crate) mod test {
         create_dir_all(filename.parent().unwrap()).await?;
         // Writes name file as addgpu so find_hwmon() will find it.
         write_synced(base.join("name"), GPU_HWMON_NAME.as_bytes()).await?;
+        // Create the performance level file so AMD path is taken by get_gpu_performance_controller
+        write_synced(filename, "auto\n".as_bytes()).await?;
         Ok(())
     }
 
@@ -1452,7 +1454,12 @@ CCLK_RANGE in Core0:
         setup().await.expect("setup");
         let base = find_hwmon(GPU_HWMON_NAME).await.unwrap();
         let filename = base.join(GPU_PERFORMANCE_LEVEL_SUFFIX);
-        assert!(get_gpu_performance_level().await.is_err());
+        // After setup(), the performance level should be Auto
+        assert_eq!(
+            get_gpu_performance_level().await.unwrap(),
+            GPUPerformanceLevel::Auto
+        );
+
 
         write(filename.as_path(), "auto\n").await.expect("write");
         assert_eq!(
-- 
2.49.0


From b1e0af02db839d05bd2693349e4a1518bd386be6 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Sun, 18 May 2025 14:40:24 -0700
Subject: [PATCH 13/15] inputplumber: Add workaround for volume keys not
 registering on MSI Claw

---
 src/inputplumber.rs | 72 ++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 65 insertions(+), 7 deletions(-)

diff --git a/src/inputplumber.rs b/src/inputplumber.rs
index aec1b213eba9..20e5c5f7495c 100644
--- a/src/inputplumber.rs
+++ b/src/inputplumber.rs
@@ -8,13 +8,14 @@
 use anyhow::Result;
 use tokio::spawn;
 use tokio_stream::StreamExt;
-use tracing::{debug, info};
+use tracing::{debug, error, info};
 use zbus::fdo::{InterfacesAdded, ObjectManagerProxy};
 use zbus::names::OwnedInterfaceName;
 use zbus::proxy::CacheProperties;
 use zbus::zvariant::ObjectPath;
 use zbus::Connection;
 
+use crate::hardware::{device_type, DeviceType};
 use crate::Service;
 
 #[zbus::proxy(
@@ -100,13 +101,70 @@ impl DeckService {
             .path(path)?
             .build()
             .await?;
-        if !self.is_deck(&proxy).await? {
-            debug!("Changing CompositeDevice {} into `deck-uhid` type", path);
-            proxy.set_target_devices(&["deck-uhid"]).await
-        } else {
-            debug!("CompositeDevice {} is already `deck-uhid` type", path);
-            Ok(())
+
+        let system_device_type = match device_type().await {
+            Ok(dt) => dt,
+            Err(e) => {
+                error!(
+                    "Failed to get system device type for {}: {}. Skipping inputplumber device configuration.",
+                    path, e
+                );
+                return Ok(());
+            }
+        };
+
+        match system_device_type {
+            DeviceType::SteamDeck => {
+                if !self.is_deck(&proxy).await? {
+                    debug!(
+                        "Changing CompositeDevice {} into `deck-uhid` type for SteamDeck",
+                        path
+                    );
+                    proxy.set_target_devices(&["deck-uhid"]).await?;
+                } else {
+                    debug!(
+                        "CompositeDevice {} is already `deck-uhid` type for SteamDeck",
+                        path
+                    );
+                }
+            }
+            // The MSI Claw lineup needs a keyboard target to be configured in order for the volume
+            // keys to be registered while InputPlumber is running. Creating both a deck-uhid and a
+            // keyboard target works for this.
+            DeviceType::Claw => {
+                const EXPECTED_CLAW_TARGET_TYPES: &[&str] = &["deck-uhid", "keyboard"];
+                let current_target_types = proxy.target_devices().await?;
+
+                let expected_claw_types_vec: Vec<String> = EXPECTED_CLAW_TARGET_TYPES
+                    .iter()
+                    .map(|&s| s.to_string())
+                    .collect();
+
+                let is_correctly_set = current_target_types == expected_claw_types_vec;
+
+                if !is_correctly_set {
+                    debug!(
+                        "Changing CompositeDevice {} into `{:?}` for {:?}",
+                        path, EXPECTED_CLAW_TARGET_TYPES, system_device_type
+                    );
+                    proxy
+                        .set_target_devices(EXPECTED_CLAW_TARGET_TYPES)
+                        .await?;
+                } else {
+                    debug!(
+                        "CompositeDevice {} is already `{:?}` for {:?}",
+                        path, EXPECTED_CLAW_TARGET_TYPES, system_device_type
+                    );
+                }
+            }
+            _ => {
+                debug!(
+                    "CompositeDevice {} (type {:?}). No specific target configuration change.",
+                    path, system_device_type
+                );
+            }
         }
+        Ok(())
     }
 }
 
-- 
2.49.0


From 89cc3d6a78776e90a31b5faff28174ff98f2e7ee Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Sun, 18 May 2025 15:52:50 -0700
Subject: [PATCH 14/15] fix clippy warnings

---
 src/power.rs | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/power.rs b/src/power.rs
index 1670a93cfab5..7a96f0fc3c4a 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -842,10 +842,7 @@ impl GpuClockController for IntelXeController {
 
 // Helper function to check if a path exists
 async fn path_exists(path: impl AsRef<Path>) -> bool {
-    match try_exists(path).await {
-        Ok(exists) => exists,
-        Err(_) => false,
-    }
+    (try_exists(path).await).unwrap_or(false)
 }
 
 // Helper function to check if a GPU is enabled
-- 
2.49.0


From ae111167e4eb343d74b48741aa3e301c633bb8e1 Mon Sep 17 00:00:00 2001
From: Matthew Schwartz <matthew.schwartz@linux.dev>
Date: Sun, 18 May 2025 15:53:13 -0700
Subject: [PATCH 15/15] Run cargo fmt

---
 src/inputplumber.rs | 4 +---
 src/platform.rs     | 8 ++++----
 src/power.rs        | 1 -
 3 files changed, 5 insertions(+), 8 deletions(-)

diff --git a/src/inputplumber.rs b/src/inputplumber.rs
index 20e5c5f7495c..5eaf374060ab 100644
--- a/src/inputplumber.rs
+++ b/src/inputplumber.rs
@@ -147,9 +147,7 @@ impl DeckService {
                         "Changing CompositeDevice {} into `{:?}` for {:?}",
                         path, EXPECTED_CLAW_TARGET_TYPES, system_device_type
                     );
-                    proxy
-                        .set_target_devices(EXPECTED_CLAW_TARGET_TYPES)
-                        .await?;
+                    proxy.set_target_devices(EXPECTED_CLAW_TARGET_TYPES).await?;
                 } else {
                     debug!(
                         "CompositeDevice {} is already `{:?}` for {:?}",
diff --git a/src/platform.rs b/src/platform.rs
index fcd41b5e07e3..f1d8db63b250 100644
--- a/src/platform.rs
+++ b/src/platform.rs
@@ -164,11 +164,11 @@ impl PlatformConfig {
     #[cfg(not(test))]
     async fn load() -> Result<Option<PlatformConfig>> {
         let platform = match device_type().await? {
-            DeviceType::RogAlly   => "rog-ally",
-            DeviceType::RogAllyX  => "rog-ally-x",
-            DeviceType::LegionGo  => "legion-go",
+            DeviceType::RogAlly => "rog-ally",
+            DeviceType::RogAllyX => "rog-ally-x",
+            DeviceType::LegionGo => "legion-go",
             DeviceType::LegionGoS => "legion-go-s",
-            DeviceType::Claw      => "claw",
+            DeviceType::Claw => "claw",
             DeviceType::SteamDeck => "jupiter",
             DeviceType::ZotacGamingZone => "zotac-gaming-zone",
             _ => return Ok(None),
diff --git a/src/power.rs b/src/power.rs
index 7a96f0fc3c4a..00da8dc0891c 100644
--- a/src/power.rs
+++ b/src/power.rs
@@ -1457,7 +1457,6 @@ CCLK_RANGE in Core0:
             GPUPerformanceLevel::Auto
         );
 
-
         write(filename.as_path(), "auto\n").await.expect("write");
         assert_eq!(
             get_gpu_performance_level().await.unwrap(),
-- 
2.49.0

