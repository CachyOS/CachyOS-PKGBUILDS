From 3856bee7adf3ca49d5c7ed36be7e777f91baf7f0 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Mon, 4 Mar 2024 17:11:59 +0100
Subject: [PATCH 1/8] xwayland: add detection for drivers that don't support
 implicit sync

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xwayland/xwayland-glamor-gbm.c | 19 ++++++++++++++++++-
 hw/xwayland/xwayland-glamor.h     |  1 +
 2 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 7cd4a68060..b22e892487 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -62,6 +62,7 @@ struct xwl_gbm_private {
     Bool drm_authenticated;
     Bool dmabuf_capable;
     Bool glamor_gles;
+    Bool implicit_sync;
 
     /* Set if wl_drm is available */
     struct wl_drm *drm;
@@ -1020,6 +1021,14 @@ xwl_glamor_gbm_has_egl_extension(void)
             epoxy_has_egl_extension(NULL, "EGL_KHR_platform_gbm"));
 }
 
+Bool
+xwl_glamor_supports_implicit_sync(struct xwl_screen *xwl_screen)
+{
+    /* absent glamor, implicit sync is irrelevant so just return TRUE */
+    return !xwl_screen->glamor ||
+        xwl_gbm_get(xwl_screen)->implicit_sync;
+}
+
 static Bool
 xwl_glamor_try_to_make_context_current(struct xwl_screen *xwl_screen)
 {
@@ -1164,7 +1173,7 @@ xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
     EGLint major, minor;
     const GLubyte *renderer;
-    const char *gbm_backend_name;
+    const char *gbm_backend_name, *egl_vendor;
 
     if (!xwl_gbm->drm && !xwl_glamor_gbm_init_main_dev(xwl_screen))
         return FALSE;
@@ -1229,6 +1238,14 @@ xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
         xwl_screen->glvnd_vendor = gbm_backend_name;
     xwl_gbm->glamor_gles = !epoxy_is_desktop_gl();
 
+    egl_vendor = eglQueryString(xwl_screen->egl_display, EGL_VENDOR);
+    if (!egl_vendor) {
+        ErrorF("Could not determine EGL vendor\n");
+        goto error;
+    }
+    /* NVIDIA driver does not support implicit sync */
+    xwl_gbm->implicit_sync = !strstr(egl_vendor, "NVIDIA");
+
     return TRUE;
 error:
     if (xwl_screen->egl_display != EGL_NO_DISPLAY) {
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index 297ae1786c..ff019feda4 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -57,6 +57,7 @@ void xwl_glamor_init_wl_registry(struct xwl_screen *xwl_screen,
 void xwl_glamor_egl_make_current(struct xwl_screen *xwl_screen);
 Bool xwl_glamor_check_flip(WindowPtr present_window, PixmapPtr pixmap);
 PixmapPtr xwl_glamor_create_pixmap_for_window (struct xwl_window *xwl_window);
+Bool xwl_glamor_supports_implicit_sync(struct xwl_screen *xwl_screen);
 
 #ifdef XV
 /* glamor Xv Adaptor */
-- 
GitLab


From ae1b20e21a7bc2983551168657e4943f066a3544 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@kde.org>
Date: Mon, 4 Mar 2024 17:15:13 +0100
Subject: [PATCH 2/8] xwayland: add workaround for drivers that don't support
 impicit sync

Without either implicit or explicit synchronization, the result of rendering is
pretty much undefined, and many glitches can appear. This still doesn't synchronize
buffer release, but it works around most glitches until explicit sync is supported.

Signed-off-by: Xaver Hugl <xaver.hugl@kde.org>
---
 hw/xwayland/xwayland-present.c        | 6 +++++-
 hw/xwayland/xwayland-window-buffers.c | 9 +++++++++
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index d973dea23d..6370c56840 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -655,6 +655,7 @@ xwl_present_check_flip(RRCrtcPtr crtc,
     WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(present_window);
     struct xwl_window *xwl_window = xwl_window_from_window(present_window);
     ScreenPtr screen = pixmap->drawable.pScreen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
 
     if (reason)
         *reason = PRESENT_FLIP_REASON_UNKNOWN;
@@ -695,7 +696,10 @@ xwl_present_check_flip(RRCrtcPtr crtc,
     if (xwl_window->xwl_screen->glamor &&
         !xwl_glamor_check_flip(present_window, pixmap))
         return FALSE;
-#endif
+
+    if (!xwl_glamor_supports_implicit_sync(xwl_screen))
+        return FALSE;
+#endif /* XWL_HAS_GLAMOR */
 
     /* Can't flip if the window pixmap doesn't match the xwl_window parent
      * window's, e.g. because a client redirected this window or one of its
diff --git a/hw/xwayland/xwayland-window-buffers.c b/hw/xwayland/xwayland-window-buffers.c
index ced9d95679..85c987de72 100644
--- a/hw/xwayland/xwayland-window-buffers.c
+++ b/hw/xwayland/xwayland-window-buffers.c
@@ -32,6 +32,9 @@
 #include "xwayland-pixmap.h"
 #include "xwayland-screen.h"
 #include "xwayland-window-buffers.h"
+#ifdef XWL_HAS_GLAMOR
+#include "glamor.h"
+#endif
 
 #define BUFFER_TIMEOUT 1 * 1000 /* ms */
 
@@ -384,6 +387,12 @@ xwl_window_swap_pixmap(struct xwl_window *xwl_window)
 
     /* Hold a reference on the buffer until it's released by the compositor */
     xwl_window_buffer->refcnt++;
+
+#ifdef XWL_HAS_GLAMOR
+    if (!xwl_glamor_supports_implicit_sync(xwl_screen)) {
+        glamor_finish(xwl_screen->screen);
+    }
+#endif /* XWL_HAS_GLAMOR */
     xwl_pixmap_set_buffer_release_cb(xwl_window_buffer->pixmap,
                                      xwl_window_buffer_release_callback,
                                      xwl_window_buffer);
-- 
GitLab


From 53f83f841d256a4ba5f4971abfe93aaade8d9c53 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 24 Oct 2023 16:14:17 -0700
Subject: [PATCH 3/8] DRI3: provide stub implementation of
 DRI3SetDRMDeviceInUse

DRI3 version 1.3 introduced a new request which allows clients to
provide a hint to the server about which DRM device they are using, so
that the server might return DRM format modifiers specific to that
device. However, implementing such functionality, for Xwayland in
particular, will require fairly significant architectural changes.

To avoid blocking future versions of the DRI3 extension, we provide here
a stub implementation for the request in question. The spec explicitly
states that it is only a hint that the server is free to ignore, so
strictly speaking this implementation is still correct.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 dri3/dri3_request.c         | 34 ++++++++++++++++++++++++++++++++++
 include/protocol-versions.h |  2 +-
 meson.build                 |  2 +-
 3 files changed, 36 insertions(+), 2 deletions(-)

diff --git a/dri3/dri3_request.c b/dri3/dri3_request.c
index 99ff73d393..a5cc7ccc97 100644
--- a/dri3/dri3_request.c
+++ b/dri3/dri3_request.c
@@ -555,6 +555,27 @@ proc_dri3_buffers_from_pixmap(ClientPtr client)
     return Success;
 }
 
+static int
+proc_dri3_set_drm_device_in_use(ClientPtr client)
+{
+    REQUEST(xDRI3SetDRMDeviceInUseReq);
+    WindowPtr window;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI3SetDRMDeviceInUseReq);
+    status = dixLookupWindow(&window, stuff->window, client,
+                             DixGetAttrAccess);
+    if (status != Success)
+        return status;
+
+    /* TODO Eventually we should use this information to have
+     * DRI3GetSupportedModifiers return device-specific modifiers, but for now
+     * we will ignore it until multi-device support is more complete.
+     * Otherwise we can't advertise support for DRI3 1.4.
+     */
+    return Success;
+}
+
 int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_query_version,            /* 0 */
     proc_dri3_open,                     /* 1 */
@@ -565,6 +586,7 @@ int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_get_supported_modifiers,  /* 6 */
     proc_dri3_pixmap_from_buffers,      /* 7 */
     proc_dri3_buffers_from_pixmap,      /* 8 */
+    proc_dri3_set_drm_device_in_use,    /* 9 */
 };
 
 int
@@ -698,6 +720,17 @@ sproc_dri3_buffers_from_pixmap(ClientPtr client)
     return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
 }
 
+static int _X_COLD
+sproc_dri3_set_drm_device_in_use(ClientPtr client)
+{
+    REQUEST(xDRI3SetDRMDeviceInUseReq);
+    REQUEST_SIZE_MATCH(xDRI3SetDRMDeviceInUseReq);
+    swapl(&stuff->window);
+    swapl(&stuff->drmMajor);
+    swapl(&stuff->drmMinor);
+    return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
+}
+
 int (*sproc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     sproc_dri3_query_version,           /* 0 */
     sproc_dri3_open,                    /* 1 */
@@ -708,6 +741,7 @@ int (*sproc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     sproc_dri3_get_supported_modifiers, /* 6 */
     sproc_dri3_pixmap_from_buffers,     /* 7 */
     sproc_dri3_buffers_from_pixmap,     /* 8 */
+    sproc_dri3_set_drm_device_in_use,   /* 9 */
 };
 
 int _X_COLD
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index a81a2d17c4..ee58e8a673 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -52,7 +52,7 @@
 
 /* DRI3 */
 #define SERVER_DRI3_MAJOR_VERSION               1
-#define SERVER_DRI3_MINOR_VERSION               2
+#define SERVER_DRI3_MINOR_VERSION               3
 
 /* Generic event extension */
 #define SERVER_GE_MAJOR_VERSION                 1
diff --git a/meson.build b/meson.build
index 935e3b8b14..2cc7bf9c96 100644
--- a/meson.build
+++ b/meson.build
@@ -90,7 +90,7 @@ scrnsaverproto_dep = dependency('scrnsaverproto', version: '>= 1.1', fallback: [
 resourceproto_dep = dependency('resourceproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'])
 xf86driproto_dep = dependency('xf86driproto', version: '>= 2.1.0', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri1') == 'true')
 dri2proto_dep = dependency('dri2proto', version: '>= 2.8', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri2') == 'true')
-dri3proto_dep = dependency('dri3proto', version: '>= 1.2', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri3') == 'true')
+dri3proto_dep = dependency('dri3proto', version: '>= 1.3', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri3') == 'true')
 xineramaproto_dep = dependency('xineramaproto', fallback: ['xorgproto', 'ext_xorgproto'])
 xf86bigfontproto_dep = dependency('xf86bigfontproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('xf86bigfont'))
 xf86vidmodeproto_dep = dependency('xf86vidmodeproto', version: '>= 2.2.99.1', fallback: ['xorgproto', 'ext_xorgproto'])
-- 
GitLab


From 11246bb4d8f6aa0ee8169ad8be859996e0aa1bcc Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 16 Aug 2022 11:57:40 -0700
Subject: [PATCH 4/8] DRI3: add DRI3ImportSyncobj and DRI3FreeSyncobj

Adds the required infrastructure in the core DRI3 code to support
importing DRM synchronization objects from clients. This includes
support for the two new protocol requests from DRI3 version 1.4, an
internal representation of these objects in the form of the dri3_syncobj
structure, and an import_syncobj screen info callback.

The following operations are defined for dri3_syncobj objects
* free - release any server-side resources associated with the object
* has_fence - check if the fence for a timeline point is submitted
* is_signaled - check if a timeline point is signaled
* export_fence - return a sync fd corresponding to a timeline point
* import_fence - submit a sync fd as the fence for a timeline point
* signal - immediately signal a timeline point
* submitted_eventfd and signaled_eventfd - register an eventfd to be
  signaled when the given timeline point is either submitted or
  signaled

Implementations will be responsible for populating these function
pointers when importing a syncobj.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 dri3/dri3.c                 | 15 ++++++
 dri3/dri3.h                 | 38 +++++++++++++++-
 dri3/dri3_priv.h            |  3 ++
 dri3/dri3_request.c         | 91 +++++++++++++++++++++++++++++++++++++
 dri3/dri3_screen.c          | 20 ++++++++
 include/protocol-versions.h |  2 +-
 meson.build                 |  2 +-
 7 files changed, 168 insertions(+), 3 deletions(-)

diff --git a/dri3/dri3.c b/dri3/dri3.c
index 1912529695..f9c5172774 100644
--- a/dri3/dri3.c
+++ b/dri3/dri3.c
@@ -63,6 +63,16 @@ dri3_screen_init(ScreenPtr screen, const dri3_screen_info_rec *info)
     return TRUE;
 }
 
+RESTYPE dri3_syncobj_type;
+
+static int dri3_syncobj_free(void *data, XID id)
+{
+    struct dri3_syncobj *syncobj = data;
+    if (--syncobj->refcount == 0)
+        syncobj->free(syncobj);
+    return 0;
+}
+
 void
 dri3_extension_init(void)
 {
@@ -92,6 +102,11 @@ dri3_extension_init(void)
         if (!dri3_screen_init(screenInfo.screens[i], NULL))
             goto bail;
     }
+
+    dri3_syncobj_type = CreateNewResourceType(dri3_syncobj_free, "DRI3Syncobj");
+    if (!dri3_syncobj_type)
+        goto bail;
+
     return;
 
 bail:
diff --git a/dri3/dri3.h b/dri3/dri3.h
index 02d3b03eec..14f9a1efa7 100644
--- a/dri3/dri3.h
+++ b/dri3/dri3.h
@@ -28,7 +28,35 @@
 #include <X11/extensions/dri3proto.h>
 #include <randrstr.h>
 
-#define DRI3_SCREEN_INFO_VERSION        2
+#define DRI3_SCREEN_INFO_VERSION        4
+
+extern RESTYPE dri3_syncobj_type;
+
+struct dri3_syncobj
+{
+    XID id;
+    ScreenPtr screen;
+    uint32_t refcount;
+
+    void (*free)(struct dri3_syncobj *syncobj);
+    Bool (*has_fence)(struct dri3_syncobj *syncobj, uint64_t point);
+    Bool (*is_signaled)(struct dri3_syncobj *syncobj, uint64_t point);
+    int (*export_fence)(struct dri3_syncobj *syncobj, uint64_t point);
+    void (*import_fence)(struct dri3_syncobj *syncobj, uint64_t point, int fd);
+    void (*signal)(struct dri3_syncobj *syncobj, uint64_t point);
+    void (*submitted_eventfd)(struct dri3_syncobj *syncobj, uint64_t point, int efd);
+    void (*signaled_eventfd)(struct dri3_syncobj *syncobj, uint64_t point, int efd);
+};
+
+#define VERIFY_DRI3_SYNCOBJ(id, ptr, a)\
+    do {\
+        int rc = dixLookupResourceByType((void **)&(ptr), id,\
+                                         dri3_syncobj_type, client, a);\
+        if (rc != Success) {\
+            client->errorValue = id;\
+            return rc;\
+        }\
+    } while (0);
 
 typedef int (*dri3_open_proc)(ScreenPtr screen,
                               RRProviderPtr provider,
@@ -84,6 +112,11 @@ typedef int (*dri3_get_drawable_modifiers_proc) (DrawablePtr draw,
                                                  uint32_t *num_modifiers,
                                                  uint64_t **modifiers);
 
+typedef struct dri3_syncobj *(*dri3_import_syncobj_proc) (ClientPtr client,
+                                                          ScreenPtr screen,
+                                                          XID id,
+                                                          int fd);
+
 typedef struct dri3_screen_info {
     uint32_t                    version;
 
@@ -101,6 +134,9 @@ typedef struct dri3_screen_info {
     dri3_get_modifiers_proc     get_modifiers;
     dri3_get_drawable_modifiers_proc get_drawable_modifiers;
 
+    /* Version 4 */
+    dri3_import_syncobj_proc    import_syncobj;
+
 } dri3_screen_info_rec, *dri3_screen_info_ptr;
 
 extern _X_EXPORT Bool
diff --git a/dri3/dri3_priv.h b/dri3/dri3_priv.h
index f319d17702..71d2da9571 100644
--- a/dri3/dri3_priv.h
+++ b/dri3/dri3_priv.h
@@ -102,4 +102,7 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
                              CARD32 *num_screen_modifiers,
                              CARD64 **screen_modifiers);
 
+int
+dri3_import_syncobj(ClientPtr client, ScreenPtr screen, XID id, int fd);
+
 #endif /* _DRI3PRIV_H_ */
diff --git a/dri3/dri3_request.c b/dri3/dri3_request.c
index a5cc7ccc97..98c37aa912 100644
--- a/dri3/dri3_request.c
+++ b/dri3/dri3_request.c
@@ -29,6 +29,17 @@
 #include <drm_fourcc.h>
 #include "randrstr_priv.h"
 
+static Bool
+dri3_screen_can_one_point_four(ScreenPtr screen)
+{
+    dri3_screen_priv_ptr dri3 = dri3_screen_priv(screen);
+
+    return dri3 &&
+        dri3->info &&
+        dri3->info->version >= 4 &&
+        dri3->info->import_syncobj;
+}
+
 static Bool
 dri3_screen_can_one_point_two(ScreenPtr screen)
 {
@@ -62,6 +73,10 @@ proc_dri3_query_version(ClientPtr client)
             rep.minorVersion = 0;
             break;
         }
+        if (!dri3_screen_can_one_point_four(screenInfo.screens[i])) {
+            rep.minorVersion = 2;
+            break;
+        }
     }
 
     for (int i = 0; i < screenInfo.numGPUScreens; i++) {
@@ -69,6 +84,10 @@ proc_dri3_query_version(ClientPtr client)
             rep.minorVersion = 0;
             break;
         }
+        if (!dri3_screen_can_one_point_four(screenInfo.gpuscreens[i])) {
+            rep.minorVersion = 2;
+            break;
+        }
     }
 
     /* From DRI3 proto:
@@ -576,6 +595,51 @@ proc_dri3_set_drm_device_in_use(ClientPtr client)
     return Success;
 }
 
+static int
+proc_dri3_import_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3ImportSyncobjReq);
+    DrawablePtr drawable;
+    ScreenPtr screen;
+    int fd;
+    int status;
+
+    SetReqFds(client, 1);
+    REQUEST_SIZE_MATCH(xDRI3ImportSyncobjReq);
+    LEGAL_NEW_RESOURCE(stuff->syncobj, client);
+
+    status = dixLookupDrawable(&drawable, stuff->drawable, client,
+                               M_ANY, DixGetAttrAccess);
+    if (status != Success)
+        return status;
+
+    screen = drawable->pScreen;
+
+    fd = ReadFdFromClient(client);
+    if (fd < 0)
+        return BadValue;
+
+    return dri3_import_syncobj(client, screen, stuff->syncobj, fd);
+}
+
+static int
+proc_dri3_free_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3FreeSyncobjReq);
+    struct dri3_syncobj *syncobj;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI3FreeSyncobjReq);
+
+    status = dixLookupResourceByType((void **) &syncobj, stuff->syncobj,
+                                     dri3_syncobj_type, client, DixWriteAccess);
+    if (status != Success)
+        return status;
+
+    FreeResource(stuff->syncobj, RT_NONE);
+    return Success;
+}
+
 int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_query_version,            /* 0 */
     proc_dri3_open,                     /* 1 */
@@ -587,6 +651,8 @@ int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_pixmap_from_buffers,      /* 7 */
     proc_dri3_buffers_from_pixmap,      /* 8 */
     proc_dri3_set_drm_device_in_use,    /* 9 */
+    proc_dri3_import_syncobj,           /* 10 */
+    proc_dri3_free_syncobj,             /* 11 */
 };
 
 int
@@ -731,6 +797,29 @@ sproc_dri3_set_drm_device_in_use(ClientPtr client)
     return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
 }
 
+static int _X_COLD
+sproc_dri3_import_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3ImportSyncobjReq);
+    REQUEST_SIZE_MATCH(xDRI3ImportSyncobjReq);
+
+    swaps(&stuff->length);
+    swapl(&stuff->syncobj);
+    swapl(&stuff->drawable);
+    return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
+}
+
+static int _X_COLD
+sproc_dri3_free_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3FreeSyncobjReq);
+    REQUEST_SIZE_MATCH(xDRI3FreeSyncobjReq);
+
+    swaps(&stuff->length);
+    swapl(&stuff->syncobj);
+    return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
+}
+
 int (*sproc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     sproc_dri3_query_version,           /* 0 */
     sproc_dri3_open,                    /* 1 */
@@ -742,6 +831,8 @@ int (*sproc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     sproc_dri3_pixmap_from_buffers,     /* 7 */
     sproc_dri3_buffers_from_pixmap,     /* 8 */
     sproc_dri3_set_drm_device_in_use,   /* 9 */
+    sproc_dri3_import_syncobj,          /* 10 */
+    sproc_dri3_free_syncobj,            /* 11 */
 };
 
 int _X_COLD
diff --git a/dri3/dri3_screen.c b/dri3/dri3_screen.c
index bc96e5339c..5614a22b35 100644
--- a/dri3/dri3_screen.c
+++ b/dri3/dri3_screen.c
@@ -272,3 +272,23 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
 
     return Success;
 }
+
+int dri3_import_syncobj(ClientPtr client, ScreenPtr screen, XID id, int fd)
+{
+    const dri3_screen_info_rec *info = dri3_screen_priv(screen)->info;
+    struct dri3_syncobj *syncobj = NULL;
+
+    if (info->version < 4 || !info->import_syncobj)
+        return BadImplementation;
+
+    syncobj = info->import_syncobj(client, screen, id, fd);
+    close(fd);
+
+    if (!syncobj)
+        return BadAlloc;
+
+    if (!AddResource(id, dri3_syncobj_type, syncobj))
+        return BadAlloc;
+
+    return Success;
+}
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index ee58e8a673..6d1b4daa53 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -52,7 +52,7 @@
 
 /* DRI3 */
 #define SERVER_DRI3_MAJOR_VERSION               1
-#define SERVER_DRI3_MINOR_VERSION               3
+#define SERVER_DRI3_MINOR_VERSION               4
 
 /* Generic event extension */
 #define SERVER_GE_MAJOR_VERSION                 1
diff --git a/meson.build b/meson.build
index 2cc7bf9c96..cbfbb715ed 100644
--- a/meson.build
+++ b/meson.build
@@ -90,7 +90,7 @@ scrnsaverproto_dep = dependency('scrnsaverproto', version: '>= 1.1', fallback: [
 resourceproto_dep = dependency('resourceproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'])
 xf86driproto_dep = dependency('xf86driproto', version: '>= 2.1.0', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri1') == 'true')
 dri2proto_dep = dependency('dri2proto', version: '>= 2.8', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri2') == 'true')
-dri3proto_dep = dependency('dri3proto', version: '>= 1.3', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri3') == 'true')
+dri3proto_dep = dependency('dri3proto', version: '>= 1.4', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri3') == 'true')
 xineramaproto_dep = dependency('xineramaproto', fallback: ['xorgproto', 'ext_xorgproto'])
 xf86bigfontproto_dep = dependency('xf86bigfontproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('xf86bigfont'))
 xf86vidmodeproto_dep = dependency('xf86vidmodeproto', version: '>= 2.2.99.1', fallback: ['xorgproto', 'ext_xorgproto'])
-- 
GitLab


From c4d4b7de165f74f7d35ec98df9cd145d5e9b547d Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Mon, 18 Mar 2024 11:33:15 -0700
Subject: [PATCH 5/8] Present: add PresentCapabilitySyncobj and
 PresentPixmapSynced

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xfree86/common/xf86Module.h |   2 +-
 hw/xwayland/xwayland-present.c |  12 ++-
 include/protocol-versions.h    |   2 +-
 meson.build                    |   2 +-
 present/present.c              |   9 ++
 present/present_execute.c      |  34 ++++++-
 present/present_priv.h         |  25 +++++
 present/present_request.c      | 170 ++++++++++++++++++++++++++-------
 present/present_scmd.c         |  11 +++
 present/present_screen.c       |   1 +
 present/present_vblank.c       |  36 +++++++
 11 files changed, 264 insertions(+), 40 deletions(-)

diff --git a/hw/xfree86/common/xf86Module.h b/hw/xfree86/common/xf86Module.h
index 6166e85590..b6eb806228 100644
--- a/hw/xfree86/common/xf86Module.h
+++ b/hw/xfree86/common/xf86Module.h
@@ -74,7 +74,7 @@
  * mask is 0xFFFF0000.
  */
 #define ABI_ANSIC_VERSION	SET_ABI_VERSION(0, 4)
-#define ABI_VIDEODRV_VERSION	SET_ABI_VERSION(26, 1)
+#define ABI_VIDEODRV_VERSION	SET_ABI_VERSION(27, 0)
 #define ABI_XINPUT_VERSION	SET_ABI_VERSION(24, 4)
 #define ABI_EXTENSION_VERSION	SET_ABI_VERSION(10, 0)
 
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index 6370c56840..deb9cd0b22 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -971,6 +971,10 @@ xwl_present_pixmap(WindowPtr window,
                    RRCrtcPtr target_crtc,
                    SyncFence *wait_fence,
                    SyncFence *idle_fence,
+                   struct dri3_syncobj *acquire_syncobj,
+                   struct dri3_syncobj *release_syncobj,
+                   uint64_t acquire_point,
+                   uint64_t release_point,
                    uint32_t options,
                    uint64_t target_window_msc,
                    uint64_t divisor,
@@ -992,6 +996,9 @@ xwl_present_pixmap(WindowPtr window,
     if (!window_priv)
         return BadAlloc;
 
+    if (acquire_syncobj || release_syncobj)
+        return BadValue;
+
     target_crtc = xwl_present_get_crtc(screen_priv, window);
 
     ret = xwl_present_get_ust_msc(screen, window, &ust, &crtc_msc);
@@ -1041,8 +1048,9 @@ xwl_present_pixmap(WindowPtr window,
 
     vblank = &event->vblank;
     if (!present_vblank_init(vblank, window, pixmap, serial, valid, update, x_off, y_off,
-                             target_crtc, wait_fence, idle_fence, options, XWL_PRESENT_CAPS,
-                             notifies, num_notifies, target_msc, crtc_msc)) {
+                             target_crtc, wait_fence, idle_fence,
+                             acquire_syncobj, release_syncobj, acquire_point, release_point,
+                             options, XWL_PRESENT_CAPS, notifies, num_notifies, target_msc, crtc_msc)) {
         present_vblank_destroy(vblank);
         return BadAlloc;
     }
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index 6d1b4daa53..d08ee0a278 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -68,7 +68,7 @@
 
 /* Present */
 #define SERVER_PRESENT_MAJOR_VERSION            1
-#define SERVER_PRESENT_MINOR_VERSION            2
+#define SERVER_PRESENT_MINOR_VERSION            4
 
 /* RandR */
 #define SERVER_RANDR_MAJOR_VERSION		1
diff --git a/meson.build b/meson.build
index cbfbb715ed..c26d1644f8 100644
--- a/meson.build
+++ b/meson.build
@@ -80,7 +80,7 @@ fixesproto_dep = dependency('fixesproto', version: '>= 6.0', fallback: ['xorgpro
 damageproto_dep = dependency('damageproto', version: '>= 1.1', fallback: ['xorgproto', 'ext_xorgproto'])
 xcmiscproto_dep = dependency('xcmiscproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'])
 bigreqsproto_dep = dependency('bigreqsproto', version: '>= 1.1.0', fallback: ['xorgproto', 'ext_xorgproto'])
-presentproto_dep = dependency('presentproto', version: '>= 1.3', fallback: ['xorgproto', 'ext_xorgproto'])
+presentproto_dep = dependency('presentproto', version: '>= 1.4', fallback: ['xorgproto', 'ext_xorgproto'])
 xtrans_dep = dependency('xtrans', version: '>= 1.3.5')
 
 videoproto_dep = dependency('videoproto', fallback: ['xorgproto', 'ext_xorgproto'])
diff --git a/present/present.c b/present/present.c
index 211868341d..e0764fab1f 100644
--- a/present/present.c
+++ b/present/present.c
@@ -230,6 +230,10 @@ present_pixmap(WindowPtr window,
                RRCrtcPtr target_crtc,
                SyncFence *wait_fence,
                SyncFence *idle_fence,
+               struct dri3_syncobj *acquire_syncobj,
+               struct dri3_syncobj *release_syncobj,
+               uint64_t acquire_point,
+               uint64_t release_point,
                uint32_t options,
                uint64_t window_msc,
                uint64_t divisor,
@@ -250,6 +254,10 @@ present_pixmap(WindowPtr window,
                                        target_crtc,
                                        wait_fence,
                                        idle_fence,
+                                       acquire_syncobj,
+                                       release_syncobj,
+                                       acquire_point,
+                                       release_point,
                                        options,
                                        window_msc,
                                        divisor,
@@ -272,6 +280,7 @@ present_notify_msc(WindowPtr window,
                           0, 0,
                           NULL,
                           NULL, NULL,
+                          NULL, NULL, 0, 0,
                           divisor == 0 ? PresentOptionAsync : 0,
                           target_msc, divisor, remainder, NULL, 0);
 }
diff --git a/present/present_execute.c b/present/present_execute.c
index 68a5878be9..913a8b67ba 100644
--- a/present/present_execute.c
+++ b/present/present_execute.c
@@ -21,6 +21,7 @@
  */
 
 #include "present_priv.h"
+#include <sys/eventfd.h>
 
 /*
  * Called when the wait fence is triggered; just gets the current msc/ust and
@@ -37,6 +38,19 @@ present_wait_fence_triggered(void *param)
     screen_priv->re_execute(vblank);
 }
 
+static void present_syncobj_triggered(int fd, int xevents, void *data)
+{
+    present_vblank_ptr vblank = data;
+    ScreenPtr screen = vblank->screen;
+    present_screen_priv_ptr screen_priv = present_screen_priv(screen);
+
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    vblank->efd = -1;
+
+    screen_priv->re_execute(vblank);
+}
+
 Bool
 present_execute_wait(present_vblank_ptr vblank, uint64_t crtc_msc)
 {
@@ -58,6 +72,18 @@ present_execute_wait(present_vblank_ptr vblank, uint64_t crtc_msc)
             return TRUE;
         }
     }
+
+    if (vblank->acquire_syncobj &&
+        !vblank->acquire_syncobj->is_signaled(vblank->acquire_syncobj,
+                                              vblank->acquire_point)) {
+        vblank->efd = eventfd(0, EFD_CLOEXEC);
+        SetNotifyFd(vblank->efd, present_syncobj_triggered, X_NOTIFY_READ, vblank);
+        vblank->acquire_syncobj->signaled_eventfd(vblank->acquire_syncobj,
+                                                  vblank->acquire_point,
+                                                  vblank->efd);
+        return TRUE;
+    }
+
     return FALSE;
 }
 
@@ -85,7 +111,13 @@ present_execute_copy(present_vblank_ptr vblank, uint64_t crtc_msc)
      * which is then freed, freeing the region
      */
     vblank->update = NULL;
-    screen_priv->flush(window);
+    if (vblank->release_syncobj) {
+        int fence_fd = screen_priv->flush_fenced(window);
+        vblank->release_syncobj->import_fence(vblank->release_syncobj,
+                                              vblank->release_point, fence_fd);
+    } else {
+        screen_priv->flush(window);
+    }
 
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 }
diff --git a/present/present_priv.h b/present/present_priv.h
index 4ad7298647..727d523109 100644
--- a/present/present_priv.h
+++ b/present/present_priv.h
@@ -36,6 +36,7 @@
 #include <xfixes.h>
 #include <randrstr.h>
 #include <inttypes.h>
+#include "dri3.h"
 
 #if 0
 #define DebugPresent(x) ErrorF x
@@ -90,6 +91,11 @@ struct present_vblank {
     Bool                abort_flip;     /* aborting this flip */
     PresentFlipReason   reason;         /* reason for which flip is not possible */
     Bool                has_suboptimal; /* whether client can support SuboptimalCopy mode */
+    struct dri3_syncobj *acquire_syncobj;
+    struct dri3_syncobj *release_syncobj;
+    uint64_t            acquire_point;
+    uint64_t            release_point;
+    int                 efd;
 };
 
 typedef struct present_screen_priv present_screen_priv_rec, *present_screen_priv_ptr;
@@ -124,6 +130,10 @@ typedef int (*present_priv_pixmap_ptr)(WindowPtr window,
                                        RRCrtcPtr target_crtc,
                                        SyncFence *wait_fence,
                                        SyncFence *idle_fence,
+                                       struct dri3_syncobj *acquire_syncobj,
+                                       struct dri3_syncobj *release_syncobj,
+                                       uint64_t acquire_point,
+                                       uint64_t release_point,
                                        uint32_t options,
                                        uint64_t window_msc,
                                        uint64_t divisor,
@@ -137,6 +147,7 @@ typedef int (*present_priv_queue_vblank_ptr)(ScreenPtr screen,
                                              uint64_t event_id,
                                              uint64_t msc);
 typedef void (*present_priv_flush_ptr)(WindowPtr window);
+typedef int (*present_priv_flush_fenced_ptr)(WindowPtr window);
 typedef void (*present_priv_re_execute_ptr)(present_vblank_ptr vblank);
 
 typedef void (*present_priv_abort_vblank_ptr)(ScreenPtr screen,
@@ -147,6 +158,7 @@ typedef void (*present_priv_abort_vblank_ptr)(ScreenPtr screen,
 typedef void (*present_priv_flip_destroy_ptr)(ScreenPtr screen);
 
 struct present_screen_priv {
+    ScreenPtr                   pScreen;
     CloseScreenProcPtr          CloseScreen;
     ConfigNotifyProcPtr         ConfigNotify;
     DestroyWindowProcPtr        DestroyWindow;
@@ -180,6 +192,7 @@ struct present_screen_priv {
 
     present_priv_queue_vblank_ptr       queue_vblank;
     present_priv_flush_ptr              flush;
+    present_priv_flush_fenced_ptr       flush_fenced;
     present_priv_re_execute_ptr         re_execute;
 
     present_priv_abort_vblank_ptr       abort_vblank;
@@ -290,6 +303,10 @@ present_pixmap(WindowPtr window,
                RRCrtcPtr target_crtc,
                SyncFence *wait_fence,
                SyncFence *idle_fence,
+               struct dri3_syncobj *acquire_syncobj,
+               struct dri3_syncobj *release_syncobj,
+               uint64_t acquire_point,
+               uint64_t release_point,
                uint32_t options,
                uint64_t target_msc,
                uint64_t divisor,
@@ -464,6 +481,10 @@ present_vblank_init(present_vblank_ptr vblank,
                     RRCrtcPtr target_crtc,
                     SyncFence *wait_fence,
                     SyncFence *idle_fence,
+                    struct dri3_syncobj *acquire_syncobj,
+                    struct dri3_syncobj *release_syncobj,
+                    uint64_t acquire_point,
+                    uint64_t release_point,
                     uint32_t options,
                     const uint32_t capabilities,
                     present_notify_ptr notifies,
@@ -482,6 +503,10 @@ present_vblank_create(WindowPtr window,
                       RRCrtcPtr target_crtc,
                       SyncFence *wait_fence,
                       SyncFence *idle_fence,
+                      struct dri3_syncobj *acquire_syncobj,
+                      struct dri3_syncobj *release_syncobj,
+                      uint64_t acquire_point,
+                      uint64_t release_point,
                       uint32_t options,
                       const uint32_t capabilities,
                       present_notify_ptr notifies,
diff --git a/present/present_request.c b/present/present_request.c
index f0e8d99090..fc33f35c73 100644
--- a/present/present_request.c
+++ b/present/present_request.c
@@ -79,79 +79,117 @@ proc_present_query_version(ClientPtr client)
     } while (0)
 
 static int
-proc_present_pixmap(ClientPtr client)
+proc_present_pixmap_common(ClientPtr client,
+                           Window req_window,
+                           Pixmap req_pixmap,
+                           CARD32 req_serial,
+                           CARD32 req_valid,
+                           CARD32 req_update,
+                           INT16 req_x_off,
+                           INT16 req_y_off,
+                           CARD32 req_target_crtc,
+                           XSyncFence req_wait_fence,
+                           XSyncFence req_idle_fence,
+                           struct dri3_syncobj *acquire_syncobj,
+                           struct dri3_syncobj *release_syncobj,
+                           CARD64 req_acquire_point,
+                           CARD64 req_release_point,
+                           CARD32 req_options,
+                           CARD64 req_target_msc,
+                           CARD64 req_divisor,
+                           CARD64 req_remainder,
+                           size_t base_req_size,
+                           xPresentNotify *req_notifies)
 {
-    REQUEST(xPresentPixmapReq);
-    WindowPtr           window;
-    PixmapPtr           pixmap;
-    RegionPtr           valid = NULL;
-    RegionPtr           update = NULL;
-    SyncFence           *wait_fence;
-    SyncFence           *idle_fence;
-    RRCrtcPtr           target_crtc;
-    int                 ret;
-    int                 nnotifies;
-    present_notify_ptr  notifies = NULL;
-
-    REQUEST_AT_LEAST_SIZE(xPresentPixmapReq);
-    ret = dixLookupWindow(&window, stuff->window, client, DixWriteAccess);
+    WindowPtr window;
+    PixmapPtr pixmap;
+    RegionPtr valid = NULL;
+    RegionPtr update = NULL;
+    RRCrtcPtr target_crtc;
+    SyncFence *wait_fence;
+    SyncFence *idle_fence;
+    int nnotifies;
+    present_notify_ptr notifies = NULL;
+    int ret;
+
+    ret = dixLookupWindow(&window, req_window, client, DixWriteAccess);
     if (ret != Success)
         return ret;
-    ret = dixLookupResourceByType((void **) &pixmap, stuff->pixmap, RT_PIXMAP, client, DixReadAccess);
+    ret = dixLookupResourceByType((void **) &pixmap, req_pixmap, RT_PIXMAP, client, DixReadAccess);
     if (ret != Success)
         return ret;
 
     if (window->drawable.depth != pixmap->drawable.depth)
         return BadMatch;
 
-    VERIFY_REGION_OR_NONE(valid, stuff->valid, client, DixReadAccess);
-    VERIFY_REGION_OR_NONE(update, stuff->update, client, DixReadAccess);
+    VERIFY_REGION_OR_NONE(valid, req_valid, client, DixReadAccess);
+    VERIFY_REGION_OR_NONE(update, req_update, client, DixReadAccess);
 
-    VERIFY_CRTC_OR_NONE(target_crtc, stuff->target_crtc, client, DixReadAccess);
+    VERIFY_CRTC_OR_NONE(target_crtc, req_target_crtc, client, DixReadAccess);
 
-    VERIFY_FENCE_OR_NONE(wait_fence, stuff->wait_fence, client, DixReadAccess);
-    VERIFY_FENCE_OR_NONE(idle_fence, stuff->idle_fence, client, DixWriteAccess);
+    VERIFY_FENCE_OR_NONE(wait_fence, req_wait_fence, client, DixReadAccess);
+    VERIFY_FENCE_OR_NONE(idle_fence, req_idle_fence, client, DixWriteAccess);
 
-    if (stuff->options & ~(PresentAllOptions)) {
-        client->errorValue = stuff->options;
+    if (req_options & ~(PresentAllOptions)) {
+        client->errorValue = req_options;
         return BadValue;
     }
 
     /*
      * Check to see if remainder is sane
      */
-    if (stuff->divisor == 0) {
-        if (stuff->remainder != 0) {
-            client->errorValue = (CARD32) stuff->remainder;
+    if (req_divisor == 0) {
+        if (req_remainder != 0) {
+            client->errorValue = (CARD32)req_remainder;
             return BadValue;
         }
     } else {
-        if (stuff->remainder >= stuff->divisor) {
-            client->errorValue = (CARD32) stuff->remainder;
+        if (req_remainder >= req_divisor) {
+            client->errorValue = (CARD32)req_remainder;
             return BadValue;
         }
     }
 
-    nnotifies = (client->req_len << 2) - sizeof (xPresentPixmapReq);
+    nnotifies = (client->req_len << 2) - base_req_size;
     if (nnotifies % sizeof (xPresentNotify))
         return BadLength;
 
     nnotifies /= sizeof (xPresentNotify);
     if (nnotifies) {
-        ret = present_create_notifies(client, nnotifies, (xPresentNotify *) (stuff + 1), &notifies);
+        ret = present_create_notifies(client, nnotifies, req_notifies, &notifies);
         if (ret != Success)
             return ret;
     }
 
-    ret = present_pixmap(window, pixmap, stuff->serial, valid, update,
-                         stuff->x_off, stuff->y_off, target_crtc,
-                         wait_fence, idle_fence, stuff->options,
-                         stuff->target_msc, stuff->divisor, stuff->remainder, notifies, nnotifies);
+    ret = present_pixmap(window, pixmap, req_serial,
+                         valid, update, req_x_off, req_y_off, target_crtc,
+                         wait_fence, idle_fence,
+                         acquire_syncobj, release_syncobj,
+                         req_acquire_point, req_release_point,
+                         req_options, req_target_msc, req_divisor, req_remainder,
+                         notifies, nnotifies);
+
     if (ret != Success)
         present_destroy_notifies(notifies, nnotifies);
     return ret;
 }
 
+static int
+proc_present_pixmap(ClientPtr client)
+{
+    REQUEST(xPresentPixmapReq);
+    REQUEST_AT_LEAST_SIZE(xPresentPixmapReq);
+    return proc_present_pixmap_common(client, stuff->window, stuff->pixmap, stuff->serial,
+                                      stuff->valid, stuff->update, stuff->x_off, stuff->y_off,
+                                      stuff->target_crtc,
+                                      stuff->wait_fence, stuff->idle_fence,
+                                      None, None, 0, 0,
+                                      stuff->options, stuff->target_msc,
+                                      stuff->divisor, stuff->remainder,
+                                      sizeof (xPresentPixmapReq),
+                                      (xPresentNotify *)(stuff + 1));
+}
+
 static int
 proc_present_notify_msc(ClientPtr client)
 {
@@ -240,12 +278,41 @@ proc_present_query_capabilities (ClientPtr client)
     return Success;
 }
 
+static int
+proc_present_pixmap_synced (ClientPtr client)
+{
+    REQUEST(xPresentPixmapSyncedReq);
+    struct dri3_syncobj *acquire_syncobj;
+    struct dri3_syncobj *release_syncobj;
+
+    REQUEST_AT_LEAST_SIZE(xPresentPixmapSyncedReq);
+    VERIFY_DRI3_SYNCOBJ(stuff->acquire_syncobj, acquire_syncobj, DixWriteAccess);
+    VERIFY_DRI3_SYNCOBJ(stuff->release_syncobj, release_syncobj, DixWriteAccess);
+
+    if (stuff->acquire_point == 0 || stuff->release_point == 0 ||
+        (stuff->acquire_syncobj == stuff->release_syncobj &&
+         stuff->acquire_point >= stuff->release_point))
+        return BadValue;
+
+    return proc_present_pixmap_common(client, stuff->window, stuff->pixmap, stuff->serial,
+                                      stuff->valid, stuff->update, stuff->x_off, stuff->y_off,
+                                      stuff->target_crtc,
+                                      None, None,
+                                      acquire_syncobj, release_syncobj,
+                                      stuff->acquire_point, stuff->release_point,
+                                      stuff->options, stuff->target_msc,
+                                      stuff->divisor, stuff->remainder,
+                                      sizeof (xPresentPixmapSyncedReq),
+                                      (xPresentNotify *)(stuff + 1));
+}
+
 static int (*proc_present_vector[PresentNumberRequests]) (ClientPtr) = {
     proc_present_query_version,            /* 0 */
     proc_present_pixmap,                   /* 1 */
     proc_present_notify_msc,               /* 2 */
     proc_present_select_input,             /* 3 */
     proc_present_query_capabilities,       /* 4 */
+    proc_present_pixmap_synced,            /* 5 */
 };
 
 int
@@ -325,12 +392,47 @@ sproc_present_query_capabilities (ClientPtr client)
     return (*proc_present_vector[stuff->presentReqType]) (client);
 }
 
+
+static int _X_COLD
+sproc_present_pixmap_synced(ClientPtr client)
+{
+    REQUEST(xPresentPixmapSyncedReq);
+    REQUEST_AT_LEAST_SIZE(xPresentPixmapSyncedReq);
+
+    swaps(&stuff->length);
+
+    swapl(&stuff->window);
+
+    swapl(&stuff->pixmap);
+    swapl(&stuff->serial);
+
+    swapl(&stuff->valid);
+    swapl(&stuff->update);
+
+    swaps(&stuff->x_off);
+    swaps(&stuff->y_off);
+    swapl(&stuff->target_crtc);
+
+    swapl(&stuff->acquire_syncobj);
+    swapl(&stuff->release_syncobj);
+    swapll(&stuff->acquire_point);
+    swapll(&stuff->release_point);
+
+    swapl(&stuff->options);
+
+    swapll(&stuff->target_msc);
+    swapll(&stuff->divisor);
+    swapll(&stuff->remainder);
+    return (*proc_present_vector[stuff->presentReqType]) (client);
+}
+
 static int (*sproc_present_vector[PresentNumberRequests]) (ClientPtr) = {
     sproc_present_query_version,           /* 0 */
     sproc_present_pixmap,                  /* 1 */
     sproc_present_notify_msc,              /* 2 */
     sproc_present_select_input,            /* 3 */
     sproc_present_query_capabilities,      /* 4 */
+    sproc_present_pixmap_synced,           /* 5 */
 };
 
 int _X_COLD
diff --git a/present/present_scmd.c b/present/present_scmd.c
index d378f00167..5a5f50ca43 100644
--- a/present/present_scmd.c
+++ b/present/present_scmd.c
@@ -738,6 +738,10 @@ present_scmd_pixmap(WindowPtr window,
                     RRCrtcPtr target_crtc,
                     SyncFence *wait_fence,
                     SyncFence *idle_fence,
+                    struct dri3_syncobj *acquire_syncobj,
+                    struct dri3_syncobj *release_syncobj,
+                    uint64_t acquire_point,
+                    uint64_t release_point,
                     uint32_t options,
                     uint64_t target_window_msc,
                     uint64_t divisor,
@@ -754,6 +758,9 @@ present_scmd_pixmap(WindowPtr window,
     present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
 
+    if (acquire_syncobj || release_syncobj)
+        return BadValue;
+
     if (!window_priv)
         return BadAlloc;
 
@@ -824,6 +831,10 @@ present_scmd_pixmap(WindowPtr window,
                                    target_crtc,
                                    wait_fence,
                                    idle_fence,
+                                   acquire_syncobj,
+                                   release_syncobj,
+                                   acquire_point,
+                                   release_point,
                                    options,
                                    screen_priv->info ? screen_priv->info->capabilities : 0,
                                    notifies,
diff --git a/present/present_screen.c b/present/present_screen.c
index ef56ff779a..0589b2ee91 100644
--- a/present/present_screen.c
+++ b/present/present_screen.c
@@ -187,6 +187,7 @@ present_screen_priv_init(ScreenPtr screen)
     wrap(screen_priv, screen, ClipNotify, present_clip_notify);
 
     dixSetPrivate(&screen->devPrivates, &present_screen_private_key, screen_priv);
+    screen_priv->pScreen = screen;
 
     return screen_priv;
 }
diff --git a/present/present_vblank.c b/present/present_vblank.c
index 4f94f16e44..2eb57abfff 100644
--- a/present/present_vblank.c
+++ b/present/present_vblank.c
@@ -55,6 +55,10 @@ present_vblank_init(present_vblank_ptr vblank,
                     RRCrtcPtr target_crtc,
                     SyncFence *wait_fence,
                     SyncFence *idle_fence,
+                    struct dri3_syncobj *acquire_syncobj,
+                    struct dri3_syncobj *release_syncobj,
+                    uint64_t acquire_point,
+                    uint64_t release_point,
                     uint32_t options,
                     const uint32_t capabilities,
                     present_notify_ptr notifies,
@@ -106,6 +110,7 @@ present_vblank_init(present_vblank_ptr vblank,
     vblank->notifies = notifies;
     vblank->num_notifies = num_notifies;
     vblank->has_suboptimal = (options & PresentOptionSuboptimal);
+    vblank->efd = -1;
 
     if (pixmap != NULL &&
         !(options & PresentOptionCopy) &&
@@ -135,6 +140,18 @@ present_vblank_init(present_vblank_ptr vblank,
             goto no_mem;
     }
 
+    if (acquire_syncobj) {
+        vblank->acquire_syncobj = acquire_syncobj;
+        ++acquire_syncobj->refcount;
+        vblank->acquire_point = acquire_point;
+    }
+
+    if (release_syncobj) {
+        vblank->release_syncobj = release_syncobj;
+        ++release_syncobj->refcount;
+        vblank->release_point = release_point;
+    }
+
     if (pixmap)
         DebugPresent(("q %" PRIu64 " %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 " (crtc %p) flip %d vsync %d serial %d\n",
                       vblank->event_id, vblank, target_msc,
@@ -158,6 +175,10 @@ present_vblank_create(WindowPtr window,
                       RRCrtcPtr target_crtc,
                       SyncFence *wait_fence,
                       SyncFence *idle_fence,
+                      struct dri3_syncobj *acquire_syncobj,
+                      struct dri3_syncobj *release_syncobj,
+                      uint64_t acquire_point,
+                      uint64_t release_point,
                       uint32_t options,
                       const uint32_t capabilities,
                       present_notify_ptr notifies,
@@ -172,6 +193,8 @@ present_vblank_create(WindowPtr window,
 
     if (present_vblank_init(vblank, window, pixmap, serial, valid, update,
                             x_off, y_off, target_crtc, wait_fence, idle_fence,
+                            acquire_syncobj, release_syncobj,
+                            acquire_point, release_point,
                             options, capabilities, notifies, num_notifies,
                             target_msc, crtc_msc))
         return vblank;
@@ -229,5 +252,18 @@ present_vblank_destroy(present_vblank_ptr vblank)
     if (vblank->notifies)
         present_destroy_notifies(vblank->notifies, vblank->num_notifies);
 
+    if (vblank->efd >= 0) {
+        SetNotifyFd(vblank->efd, NULL, 0, NULL);
+        close(vblank->efd);
+    }
+
+    if (vblank->acquire_syncobj &&
+        --vblank->acquire_syncobj->refcount == 0)
+        vblank->acquire_syncobj->free(vblank->acquire_syncobj);
+
+    if (vblank->release_syncobj &&
+        --vblank->release_syncobj->refcount == 0)
+        vblank->release_syncobj->free(vblank->release_syncobj);
+
     free(vblank);
 }
-- 
GitLab


From 5ac24042b3ce352cc649d033d9d7cfe5adfc0fd0 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Mon, 18 Mar 2024 11:36:35 -0700
Subject: [PATCH 6/8] xwayland: support DRI3 1.4 and Present 1.4

Together, DRI3 1.4 and Present 1.4 allow clients to explicitly
synchronize GPU rendering with presentation using DRM syncobjs. Here we
add the necessary support to Xwayland's glamor and Present
infrastructure to enable this functionality.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xwayland/xwayland-glamor-gbm.c | 201 +++++++++++++++++++++++++++++-
 hw/xwayland/xwayland-glamor.c     |  24 ++++
 hw/xwayland/xwayland-glamor.h     |   2 +
 hw/xwayland/xwayland-present.c    |  99 +++++++++++++--
 hw/xwayland/xwayland-present.h    |   5 +
 hw/xwayland/xwayland-screen.h     |   2 +
 6 files changed, 319 insertions(+), 14 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index b22e892487..add4f408d4 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -63,6 +63,7 @@ struct xwl_gbm_private {
     Bool dmabuf_capable;
     Bool glamor_gles;
     Bool implicit_sync;
+    Bool supports_syncobjs;
 
     /* Set if wl_drm is available */
     struct wl_drm *drm;
@@ -860,7 +861,187 @@ glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
     return -1;
 }
 
-static const dri3_screen_info_rec xwl_dri3_info = {
+struct xwl_dri3_syncobj
+{
+    struct dri3_syncobj base;
+    uint32_t handle;
+};
+
+static Bool
+xwl_dri3_check_syncobj(struct dri3_syncobj *syncobj, uint64_t point, Bool check_avail)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    return !drmSyncobjTimelineWait(xwl_gbm->drm_fd,
+                                   &xwl_syncobj->handle, &point, 1,
+                                   0 /* timeout */,
+                                   check_avail ?
+                                   DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE :
+                                   DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT,
+                                   NULL /* first_signaled */);
+}
+
+static Bool
+xwl_dri3_syncobj_has_fence(struct dri3_syncobj *syncobj, uint64_t point)
+{
+    return xwl_dri3_check_syncobj(syncobj, point, TRUE /* check_avail */);
+}
+
+static Bool
+xwl_dri3_syncobj_is_signaled(struct dri3_syncobj *syncobj, uint64_t point)
+{
+    return xwl_dri3_check_syncobj(syncobj, point, FALSE /* check_avail */);
+}
+
+static int
+xwl_dri3_syncobj_export_fence(struct dri3_syncobj *syncobj, uint64_t point)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    uint32_t temp_syncobj;
+    int fd = -1;
+
+    drmSyncobjCreate(xwl_gbm->drm_fd, 0, &temp_syncobj);
+    drmSyncobjTransfer(xwl_gbm->drm_fd, temp_syncobj, 0,
+                       xwl_syncobj->handle, point, 0);
+    drmSyncobjExportSyncFile(xwl_gbm->drm_fd, temp_syncobj, &fd);
+    drmSyncobjDestroy(xwl_gbm->drm_fd, temp_syncobj);
+    return fd;
+}
+
+static void
+xwl_dri3_syncobj_import_fence(struct dri3_syncobj *syncobj,
+                              uint64_t point, int fd)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    uint32_t temp_syncobj;
+
+    drmSyncobjCreate(xwl_gbm->drm_fd, 0, &temp_syncobj);
+    drmSyncobjImportSyncFile(xwl_gbm->drm_fd, temp_syncobj, fd);
+    drmSyncobjTransfer(xwl_gbm->drm_fd, xwl_syncobj->handle, point,
+                       temp_syncobj, 0, 0);
+    drmSyncobjDestroy(xwl_gbm->drm_fd, temp_syncobj);
+    close(fd);
+}
+
+static void
+xwl_dri3_signal_syncobj(struct dri3_syncobj *syncobj, uint64_t point)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    drmSyncobjTimelineSignal(xwl_gbm->drm_fd, &xwl_syncobj->handle, &point, 1);
+}
+
+static void
+xwl_dri3_free_syncobj(struct dri3_syncobj *syncobj)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    if (xwl_syncobj->handle)
+        drmSyncobjDestroy(xwl_gbm->drm_fd, xwl_syncobj->handle);
+
+    free(xwl_syncobj);
+}
+
+static void
+xwl_dri3_syncobj_eventfd(struct dri3_syncobj *syncobj, uint64_t point,
+                         int efd, Bool wait_avail)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    drmSyncobjEventfd(xwl_gbm->drm_fd, xwl_syncobj->handle, point, efd,
+                      wait_avail ? DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE : 0);
+}
+
+static void
+xwl_dri3_syncobj_submitted_eventfd(struct dri3_syncobj *syncobj,
+                                   uint64_t point, int efd)
+{
+    xwl_dri3_syncobj_eventfd(syncobj, point, efd, TRUE /* wait_avail */);
+}
+
+static void
+xwl_dri3_syncobj_signaled_eventfd(struct dri3_syncobj *syncobj,
+                                  uint64_t point, int efd)
+{
+    xwl_dri3_syncobj_eventfd(syncobj, point, efd, FALSE /* wait_avail */);
+}
+
+static struct dri3_syncobj *
+xwl_dri3_create_syncobj(struct xwl_screen *xwl_screen, uint32_t handle)
+{
+    struct xwl_dri3_syncobj *syncobj = calloc(1, sizeof (*syncobj));
+
+    if (!syncobj)
+        return NULL;
+
+    syncobj->handle = handle;
+    syncobj->base.screen = xwl_screen->screen;
+    syncobj->base.refcount = 1;
+
+    syncobj->base.free = xwl_dri3_free_syncobj;
+    syncobj->base.has_fence = xwl_dri3_syncobj_has_fence;
+    syncobj->base.is_signaled = xwl_dri3_syncobj_is_signaled;
+    syncobj->base.export_fence = xwl_dri3_syncobj_export_fence;
+    syncobj->base.import_fence = xwl_dri3_syncobj_import_fence;
+    syncobj->base.signal = xwl_dri3_signal_syncobj;
+    syncobj->base.signaled_eventfd = xwl_dri3_syncobj_signaled_eventfd;
+    syncobj->base.submitted_eventfd = xwl_dri3_syncobj_submitted_eventfd;
+    return &syncobj->base;
+}
+
+static struct dri3_syncobj *
+xwl_dri3_import_syncobj(ClientPtr client, ScreenPtr screen, XID id, int fd)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    struct xwl_dri3_syncobj *syncobj = NULL;
+    uint32_t handle;
+
+    if (drmSyncobjFDToHandle(xwl_gbm->drm_fd, fd, &handle))
+        return NULL;
+
+    syncobj = (struct xwl_dri3_syncobj *)xwl_dri3_create_syncobj(xwl_screen, handle);
+    if (!syncobj) {
+        drmSyncobjDestroy(xwl_gbm->drm_fd, handle);
+        return NULL;
+    }
+
+    syncobj->base.id = id;
+
+    return &syncobj->base;
+}
+
+static Bool
+xwl_gbm_supports_syncobjs(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    uint64_t syncobj_cap = 0;
+
+    if (drmGetCap(xwl_gbm->drm_fd, DRM_CAP_SYNCOBJ_TIMELINE,
+                  &syncobj_cap) || !syncobj_cap)
+        return FALSE;
+
+    /* Check if syncobj eventfd is supported. */
+    drmSyncobjEventfd(xwl_gbm->drm_fd, 0, 0, -1, 0);
+    if (errno != ENOENT)
+        return FALSE;
+
+    return TRUE;
+}
+
+static dri3_screen_info_rec xwl_dri3_info = {
     .version = 2,
     .open = NULL,
     .pixmap_from_fds = glamor_pixmap_from_fds,
@@ -869,6 +1050,7 @@ static const dri3_screen_info_rec xwl_dri3_info = {
     .get_formats = xwl_glamor_get_formats,
     .get_modifiers = xwl_glamor_get_modifiers,
     .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
+    .import_syncobj = NULL, /* need to check for kernel support */
 };
 
 static const char *
@@ -1029,6 +1211,13 @@ xwl_glamor_supports_implicit_sync(struct xwl_screen *xwl_screen)
         xwl_gbm_get(xwl_screen)->implicit_sync;
 }
 
+Bool
+xwl_glamor_supports_syncobjs(struct xwl_screen *xwl_screen)
+{
+    return xwl_screen->glamor &&
+        xwl_gbm_get(xwl_screen)->supports_syncobjs;
+}
+
 static Bool
 xwl_glamor_try_to_make_context_current(struct xwl_screen *xwl_screen)
 {
@@ -1246,6 +1435,11 @@ xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
     /* NVIDIA driver does not support implicit sync */
     xwl_gbm->implicit_sync = !strstr(egl_vendor, "NVIDIA");
 
+    if (xwl_gbm_supports_syncobjs(xwl_screen) &&
+        epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "ANDROID_native_fence_sync"))
+        xwl_gbm->supports_syncobjs = TRUE;
+
     return TRUE;
 error:
     if (xwl_screen->egl_display != EGL_NO_DISPLAY) {
@@ -1263,6 +1457,11 @@ xwl_glamor_gbm_init_screen(struct xwl_screen *xwl_screen)
 {
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
+    if (xwl_gbm->supports_syncobjs) {
+        xwl_dri3_info.version = 4;
+        xwl_dri3_info.import_syncobj = xwl_dri3_import_syncobj;
+    }
+
     if (!dri3_screen_init(xwl_screen->screen, &xwl_dri3_info)) {
         ErrorF("Failed to initialize dri3\n");
         goto error;
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index d2b7739e1c..eb15eea2db 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -269,6 +269,30 @@ glamor_egl_fd_name_from_pixmap(ScreenPtr screen,
     return 0;
 }
 
+int
+xwl_glamor_get_fence(struct xwl_screen *xwl_screen)
+{
+    EGLint attribs[3];
+    EGLSyncKHR sync;
+    int fence_fd = -1;
+
+    if (!xwl_screen->glamor)
+        return -1;
+
+    xwl_glamor_egl_make_current(xwl_screen);
+
+    attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+    attribs[1] = EGL_NO_NATIVE_FENCE_FD_ANDROID;
+    attribs[2] = EGL_NONE;
+    sync = eglCreateSyncKHR(xwl_screen->egl_display, EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+    if (sync != EGL_NO_SYNC_KHR) {
+        fence_fd = eglDupNativeFenceFDANDROID(xwl_screen->egl_display, sync);
+        eglDestroySyncKHR(xwl_screen->egl_display, sync);
+    }
+
+    return fence_fd;
+}
+
 Bool
 xwl_glamor_init(struct xwl_screen *xwl_screen)
 {
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index ff019feda4..d12cd31d61 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -58,6 +58,8 @@ void xwl_glamor_egl_make_current(struct xwl_screen *xwl_screen);
 Bool xwl_glamor_check_flip(WindowPtr present_window, PixmapPtr pixmap);
 PixmapPtr xwl_glamor_create_pixmap_for_window (struct xwl_window *xwl_window);
 Bool xwl_glamor_supports_implicit_sync(struct xwl_screen *xwl_screen);
+Bool xwl_glamor_supports_syncobjs(struct xwl_screen *xwl_screen);
+int xwl_glamor_get_fence(struct xwl_screen *screen);
 
 #ifdef XV
 /* glamor Xv Adaptor */
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index deb9cd0b22..5673c2a4c3 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -30,6 +30,7 @@
 #endif
 #include <windowstr.h>
 #include <present.h>
+#include <sys/eventfd.h>
 
 #include "xwayland-present.h"
 #include "xwayland-screen.h"
@@ -215,10 +216,18 @@ xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
 static void
 xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc);
 
+static int
+xwl_present_queue_vblank(ScreenPtr screen,
+                         WindowPtr present_window,
+                         RRCrtcPtr crtc,
+                         uint64_t event_id,
+                         uint64_t msc);
+
 static uint32_t
 xwl_present_query_capabilities(present_screen_priv_ptr screen_priv)
 {
-    return XWL_PRESENT_CAPS;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    return xwl_screen->present_capabilities;
 }
 
 static int
@@ -237,6 +246,16 @@ xwl_present_get_ust_msc(ScreenPtr screen,
     return Success;
 }
 
+static uint64_t
+xwl_present_get_exec_msc(uint32_t options, uint64_t target_msc)
+{
+    /* Synchronous Xwayland presentations always complete (at least) one frame after they
+     * are executed
+     */
+    return (options & PresentOptionAsyncMayTear) ?
+        target_msc : target_msc - 1;
+}
+
 /*
  * When the wait fence or previous flip is completed, it's time
  * to re-try the request
@@ -244,9 +263,27 @@ xwl_present_get_ust_msc(ScreenPtr screen,
 static void
 xwl_present_re_execute(present_vblank_ptr vblank)
 {
+    struct xwl_present_event *event = xwl_present_event_from_vblank(vblank);
     uint64_t ust = 0, crtc_msc = 0;
 
     (void) xwl_present_get_ust_msc(vblank->screen, vblank->window, &ust, &crtc_msc);
+    /* re-compute target / exec msc */
+    vblank->target_msc = present_get_target_msc(0, crtc_msc,
+                                                event->divisor,
+                                                event->remainder,
+                                                event->options);
+    vblank->exec_msc = xwl_present_get_exec_msc(event->options,
+                                                vblank->target_msc);
+
+    vblank->queued = TRUE;
+    if (msc_is_after(vblank->exec_msc, crtc_msc) &&
+        xwl_present_queue_vblank(vblank->screen, vblank->window,
+                                 vblank->crtc,
+                                 vblank->event_id,
+                                 vblank->exec_msc) == Success) {
+        return;
+    }
+
     xwl_present_execute(vblank, ust, crtc_msc);
 }
 
@@ -285,6 +322,10 @@ xwl_present_free_event(struct xwl_present_event *event)
 static void
 xwl_present_free_idle_vblank(present_vblank_ptr vblank)
 {
+    if (vblank->release_syncobj)
+        vblank->release_syncobj->signal(vblank->release_syncobj,
+                                        vblank->release_point);
+
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
     xwl_present_free_event(xwl_present_event_from_vblank(vblank));
 }
@@ -446,6 +487,11 @@ xwl_present_buffer_release(void *data)
         return;
 
     vblank = &event->vblank;
+
+    if (vblank->release_syncobj)
+        vblank->release_syncobj->signal(vblank->release_syncobj,
+                                        vblank->release_point);
+
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 
     xwl_present_window = xwl_present_window_priv(vblank->window);
@@ -642,6 +688,19 @@ xwl_present_maybe_set_reason(struct xwl_window *xwl_window, PresentFlipReason *r
     }
 }
 
+static int
+xwl_present_flush_fenced(WindowPtr window)
+{
+    int fence = -1;
+#ifdef XWL_HAS_GLAMOR
+    struct xwl_window *xwl_window = xwl_window_from_window(window);
+    if (xwl_window)
+        fence = xwl_glamor_get_fence(xwl_window->xwl_screen);
+    xwl_present_flush(window);
+#endif /* XWL_HAS_GLAMOR */
+    return fence;
+}
+
 static Bool
 xwl_present_check_flip(RRCrtcPtr crtc,
                        WindowPtr present_window,
@@ -819,7 +878,7 @@ xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
 
     if (xwl_window->tearing_control) {
         uint32_t hint;
-        if (event->async_may_tear)
+        if (event->options & PresentOptionAsyncMayTear)
             hint = WP_TEARING_CONTROL_V1_PRESENTATION_HINT_ASYNC;
         else
             hint = WP_TEARING_CONTROL_V1_PRESENTATION_HINT_VSYNC;
@@ -860,6 +919,7 @@ xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 
     xorg_list_del(&vblank->event_queue);
 
+retry:
     if (present_execute_wait(vblank, crtc_msc))
         return;
 
@@ -936,6 +996,8 @@ xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
             }
 
             vblank->flip = FALSE;
+            /* re-execute, falling through to copy */
+            goto retry;
         }
         DebugPresent(("\tc %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
                       vblank, crtc_msc, vblank->pixmap->drawable.id, vblank->window->drawable.id));
@@ -991,12 +1053,15 @@ xwl_present_pixmap(WindowPtr window,
     ScreenPtr                   screen = window->drawable.pScreen;
     present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
+    struct xwl_screen          *xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    uint32_t                    caps = xwl_screen->present_capabilities;
     struct xwl_present_event *event;
 
     if (!window_priv)
         return BadAlloc;
 
-    if (acquire_syncobj || release_syncobj)
+    if (!(caps & PresentCapabilitySyncobj) &&
+        (acquire_syncobj || release_syncobj))
         return BadValue;
 
     target_crtc = xwl_present_get_crtc(screen_priv, window);
@@ -1036,6 +1101,10 @@ xwl_present_pixmap(WindowPtr window,
             if (xwl_present_event_from_vblank(vblank)->copy_executed)
                 continue;
 
+            if (vblank->release_syncobj)
+                vblank->release_syncobj->signal(vblank->release_syncobj,
+                                                vblank->release_point);
+
             present_vblank_scrap(vblank);
             if (vblank->flip_ready)
                 xwl_present_re_execute(vblank);
@@ -1050,21 +1119,16 @@ xwl_present_pixmap(WindowPtr window,
     if (!present_vblank_init(vblank, window, pixmap, serial, valid, update, x_off, y_off,
                              target_crtc, wait_fence, idle_fence,
                              acquire_syncobj, release_syncobj, acquire_point, release_point,
-                             options, XWL_PRESENT_CAPS, notifies, num_notifies, target_msc, crtc_msc)) {
+                             options, caps, notifies, num_notifies, target_msc, crtc_msc)) {
         present_vblank_destroy(vblank);
         return BadAlloc;
     }
 
     vblank->event_id = ++xwl_present_event_id;
-    event->async_may_tear = options & PresentOptionAsyncMayTear;
-
-    /* Synchronous Xwayland presentations always complete (at least) one frame after they
-     * are executed
-     */
-    if (event->async_may_tear)
-        vblank->exec_msc = vblank->target_msc;
-    else
-        vblank->exec_msc = vblank->target_msc - 1;
+    event->options = options;
+    event->divisor = divisor;
+    event->remainder = remainder;
+    vblank->exec_msc = xwl_present_get_exec_msc(options, vblank->target_msc);
 
     vblank->queued = TRUE;
     if (crtc_msc < vblank->exec_msc) {
@@ -1094,6 +1158,7 @@ xwl_present_unrealize_window(struct xwl_present_window *xwl_present_window)
 Bool
 xwl_present_init(ScreenPtr screen)
 {
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
     present_screen_priv_ptr screen_priv;
 
     if (!present_screen_register_priv_keys())
@@ -1109,6 +1174,13 @@ xwl_present_init(ScreenPtr screen)
     if (!dixRegisterPrivateKey(&xwl_present_window_private_key, PRIVATE_WINDOW, 0))
         return FALSE;
 
+    xwl_screen->present_capabilities = XWL_PRESENT_CAPS;
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_glamor_supports_syncobjs(xwl_screen))
+        xwl_screen->present_capabilities |=
+            PresentCapabilitySyncobj;
+#endif /* XWL_HAS_GLAMOR */
+
     screen_priv->query_capabilities = xwl_present_query_capabilities;
     screen_priv->get_crtc = xwl_present_get_crtc;
 
@@ -1119,6 +1191,7 @@ xwl_present_init(ScreenPtr screen)
     screen_priv->present_pixmap = xwl_present_pixmap;
     screen_priv->queue_vblank = xwl_present_queue_vblank;
     screen_priv->flush = xwl_present_flush;
+    screen_priv->flush_fenced = xwl_present_flush_fenced;
     screen_priv->re_execute = xwl_present_re_execute;
 
     screen_priv->abort_vblank = xwl_present_abort_vblank;
diff --git a/hw/xwayland/xwayland-present.h b/hw/xwayland/xwayland-present.h
index 34ec0422f9..33c55b38bf 100644
--- a/hw/xwayland/xwayland-present.h
+++ b/hw/xwayland/xwayland-present.h
@@ -60,6 +60,11 @@ struct xwl_present_event {
     PixmapPtr pixmap;
     Bool async_may_tear;
     Bool copy_executed;
+    Bool released;
+
+    uint32_t options;
+    uint64_t divisor;
+    uint64_t remainder;
 };
 
 Bool xwl_present_entered_for_each_frame_callback(void);
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index 477473eea5..d0b510d1b4 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -142,6 +142,8 @@ struct xwl_screen {
     struct libdecor *libdecor_context;
 #endif
     const char *output_name;
+
+    uint32_t present_capabilities;
 };
 
 /* Apps which use randr/vidmode to change the mode when going fullscreen,
-- 
GitLab


From a92c4ff97466b2706ee57ac25e9a2feb81c1b7a0 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 15 Aug 2023 15:32:47 -0700
Subject: [PATCH 7/8] xwayland: add support for wp_linux_drm_syncobj_v1

This protocol allows for explicit synchronization of GPU operations by
Wayland clients and the compositor. Xwayland can make use of this to
ensure any rendering it initiates has completed before the target image
is accessed by the compositor, without having to rely on kernel-level
implicit synchronization.

Furthermore, for X11 clients that also support explicit synchronization
using the mechanisms exposed in the DRI3 and Present extensions, this
Wayland protocol allows us to simply forward the timeline, acquire, and
release points directly to the compositor, ideally avoiding any
premature stalls in the presentation pipeline.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xwayland/meson.build               |   3 +
 hw/xwayland/xwayland-glamor-gbm.c     | 146 ++++++++++++++++++++++++++
 hw/xwayland/xwayland-glamor.c         |  24 +++++
 hw/xwayland/xwayland-glamor.h         |  12 +++
 hw/xwayland/xwayland-present.c        | 110 +++++++++++++++++--
 hw/xwayland/xwayland-screen.h         |   1 +
 hw/xwayland/xwayland-window-buffers.c | 109 ++++++++++++++++++-
 hw/xwayland/xwayland-window.c         |   4 +
 hw/xwayland/xwayland-window.h         |   1 +
 meson.build                           |   2 +-
 present/present_execute.c             |   5 +-
 11 files changed, 400 insertions(+), 17 deletions(-)

diff --git a/hw/xwayland/meson.build b/hw/xwayland/meson.build
index 7a9645c00c..0097ca8b21 100644
--- a/hw/xwayland/meson.build
+++ b/hw/xwayland/meson.build
@@ -50,6 +50,7 @@ shortcuts_inhibit_xml = join_paths(protodir, 'unstable', 'keyboard-shortcuts-inh
 xwayland_shell_xml = join_paths(protodir, 'staging', 'xwayland-shell', 'xwayland-shell-v1.xml')
 tearing_xml = join_paths(protodir, 'staging', 'tearing-control', 'tearing-control-v1.xml')
 fractional_scale_xml = join_paths(protodir, 'staging', 'fractional-scale', 'fractional-scale-v1.xml')
+syncobj_xml = join_paths(protodir, 'staging', 'linux-drm-syncobj', 'linux-drm-syncobj-v1.xml')
 
 client_header = generator(scanner,
     output : '@BASENAME@-client-protocol.h',
@@ -80,6 +81,7 @@ srcs += client_header.process(shortcuts_inhibit_xml)
 srcs += client_header.process(xwayland_shell_xml)
 srcs += client_header.process(tearing_xml)
 srcs += client_header.process(fractional_scale_xml)
+srcs += client_header.process(syncobj_xml)
 srcs += code.process(relative_xml)
 srcs += code.process(pointer_xml)
 srcs += code.process(gestures_xml)
@@ -94,6 +96,7 @@ srcs += code.process(shortcuts_inhibit_xml)
 srcs += code.process(xwayland_shell_xml)
 srcs += code.process(tearing_xml)
 srcs += code.process(fractional_scale_xml)
+srcs += code.process(syncobj_xml)
 
 if build_ei
     xwayland_dep += libei_dep
diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index add4f408d4..977fa1520b 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -35,6 +35,9 @@
 #include <sys/stat.h>
 #include <xf86drm.h>
 #include <drm_fourcc.h>
+#include <linux/dma-buf.h>
+#include <linux/sync_file.h>
+#include <sys/ioctl.h>
 
 #define MESA_EGL_NO_X11_HEADERS
 #define EGL_NO_X11
@@ -52,6 +55,7 @@
 #include "xwayland-screen.h"
 
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "linux-drm-syncobj-v1-client-protocol.h"
 
 struct xwl_gbm_private {
     drmDevice *device;
@@ -617,6 +621,8 @@ xwl_glamor_gbm_cleanup(struct xwl_screen *xwl_screen)
         wl_drm_destroy(xwl_gbm->drm);
     if (xwl_gbm->gbm)
         gbm_device_destroy(xwl_gbm->gbm);
+    if (xwl_screen->explicit_sync)
+        wp_linux_drm_syncobj_manager_v1_destroy(xwl_screen->explicit_sync);
 
     free(xwl_gbm);
 }
@@ -861,12 +867,102 @@ glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
     return -1;
 }
 
+int xwl_glamor_dmabuf_export_sync_file(PixmapPtr pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pixmap->drawable.pScreen);
+    struct xwl_pixmap *xwl_pixmap;
+    int num_planes;
+    int sync_file = -1;
+    int p;
+
+    if (!xwl_screen->glamor)
+        return -1;
+
+    xwl_pixmap = xwl_pixmap_get(pixmap);
+    num_planes = gbm_bo_get_plane_count(xwl_pixmap->bo);
+
+    for (p = 0; p < num_planes; ++p) {
+        int plane_fd = gbm_bo_get_fd_for_plane(xwl_pixmap->bo, p);
+        struct dma_buf_export_sync_file export_args = { 0 };
+        export_args.fd = -1;
+        export_args.flags = DMA_BUF_SYNC_READ;
+        drmIoctl(plane_fd, DMA_BUF_IOCTL_EXPORT_SYNC_FILE, &export_args);
+        close(plane_fd);
+        if (sync_file == -1) {
+            sync_file = export_args.fd;
+        } else {
+            struct sync_merge_data merge_args = { 0 };
+            merge_args.fd2 = export_args.fd;
+            ioctl(sync_file, SYNC_IOC_MERGE, &merge_args);
+            close(export_args.fd);
+            close(sync_file);
+            sync_file = merge_args.fence;
+        }
+    }
+
+    return sync_file;
+}
+
+void xwl_glamor_dmabuf_import_sync_file(PixmapPtr pixmap, int sync_file)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(pixmap->drawable.pScreen);
+    struct xwl_pixmap *xwl_pixmap;
+    int num_planes;
+    int p;
+
+    if (!xwl_screen->glamor)
+        return;
+
+    xwl_pixmap = xwl_pixmap_get(pixmap);
+    num_planes = gbm_bo_get_plane_count(xwl_pixmap->bo);
+
+    for (p = 0; p < num_planes; ++p) {
+        int plane_fd = gbm_bo_get_fd_for_plane(xwl_pixmap->bo, p);
+        struct dma_buf_import_sync_file import_args = { 0 };
+        import_args.fd = sync_file;
+        import_args.flags = DMA_BUF_SYNC_READ;
+        drmIoctl(plane_fd, DMA_BUF_IOCTL_IMPORT_SYNC_FILE, &import_args);
+        close(plane_fd);
+    }
+    close(sync_file);
+}
+
 struct xwl_dri3_syncobj
 {
     struct dri3_syncobj base;
     uint32_t handle;
+    struct wp_linux_drm_syncobj_timeline_v1 *timeline;
 };
 
+void
+xwl_glamor_dri3_syncobj_passthrough(WindowPtr window,
+                                    struct dri3_syncobj *acquire_syncobj,
+                                    struct dri3_syncobj *release_syncobj,
+                                    uint64_t acquire_point,
+                                    uint64_t release_point)
+{
+    struct xwl_window *xwl_window = xwl_window_from_window(window);
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_dri3_syncobj *xwl_acquire_syncobj = (struct xwl_dri3_syncobj *)acquire_syncobj;
+    struct xwl_dri3_syncobj *xwl_release_syncobj = (struct xwl_dri3_syncobj *)release_syncobj;
+    uint32_t acquire_hi = acquire_point >> 32;
+    uint32_t acquire_lo = acquire_point & 0xffffffff;
+    uint32_t release_hi = release_point >> 32;
+    uint32_t release_lo = release_point & 0xffffffff;
+
+    if (!xwl_window->surface_sync)
+        xwl_window->surface_sync =
+            wp_linux_drm_syncobj_manager_v1_get_surface(xwl_screen->explicit_sync,
+                                                        xwl_window->surface);
+
+    wp_linux_drm_syncobj_surface_v1_set_acquire_point(xwl_window->surface_sync,
+                                                      xwl_acquire_syncobj->timeline,
+                                                      acquire_hi, acquire_lo);
+    wp_linux_drm_syncobj_surface_v1_set_release_point(xwl_window->surface_sync,
+                                                      xwl_release_syncobj->timeline,
+                                                      release_hi, release_lo);
+}
+
 static Bool
 xwl_dri3_check_syncobj(struct dri3_syncobj *syncobj, uint64_t point, Bool check_avail)
 {
@@ -946,6 +1042,9 @@ xwl_dri3_free_syncobj(struct dri3_syncobj *syncobj)
     struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
+    if (xwl_syncobj->timeline)
+        wp_linux_drm_syncobj_timeline_v1_destroy(xwl_syncobj->timeline);
+
     if (xwl_syncobj->handle)
         drmSyncobjDestroy(xwl_gbm->drm_fd, xwl_syncobj->handle);
 
@@ -982,10 +1081,28 @@ static struct dri3_syncobj *
 xwl_dri3_create_syncobj(struct xwl_screen *xwl_screen, uint32_t handle)
 {
     struct xwl_dri3_syncobj *syncobj = calloc(1, sizeof (*syncobj));
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    Bool create = !handle;
 
     if (!syncobj)
         return NULL;
 
+    if (create && drmSyncobjCreate(xwl_gbm->drm_fd, 0, &handle))
+        goto fail;
+
+    if (xwl_screen->explicit_sync) {
+        int syncobj_fd = -1;
+        if (drmSyncobjHandleToFD(xwl_gbm->drm_fd, handle, &syncobj_fd))
+            goto fail;
+
+        syncobj->timeline =
+            wp_linux_drm_syncobj_manager_v1_import_timeline(xwl_screen->explicit_sync,
+                                                            syncobj_fd);
+        close(syncobj_fd);
+        if (!syncobj->timeline)
+            goto fail;
+    }
+
     syncobj->handle = handle;
     syncobj->base.screen = xwl_screen->screen;
     syncobj->base.refcount = 1;
@@ -999,6 +1116,18 @@ xwl_dri3_create_syncobj(struct xwl_screen *xwl_screen, uint32_t handle)
     syncobj->base.signaled_eventfd = xwl_dri3_syncobj_signaled_eventfd;
     syncobj->base.submitted_eventfd = xwl_dri3_syncobj_submitted_eventfd;
     return &syncobj->base;
+
+fail:
+    if (create && handle)
+        drmSyncobjDestroy(xwl_gbm->drm_fd, handle);
+    free(syncobj);
+    return NULL;
+}
+
+struct dri3_syncobj *
+xwl_glamor_dri3_syncobj_create(struct xwl_screen *xwl_screen)
+{
+    return xwl_dri3_create_syncobj(xwl_screen, 0 /* allocate new handle */);
 }
 
 static struct dri3_syncobj *
@@ -1196,6 +1325,17 @@ xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
     return TRUE;
 }
 
+Bool
+xwl_screen_set_syncobj_interface(struct xwl_screen *xwl_screen,
+                                 uint32_t id, uint32_t version)
+{
+    xwl_screen->explicit_sync =
+        wl_registry_bind(xwl_screen->registry, id,
+                         &wp_linux_drm_syncobj_manager_v1_interface,
+                         version);
+    return TRUE;
+}
+
 static Bool
 xwl_glamor_gbm_has_egl_extension(void)
 {
@@ -1440,6 +1580,12 @@ xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
                                 "ANDROID_native_fence_sync"))
         xwl_gbm->supports_syncobjs = TRUE;
 
+    if (!xwl_gbm->supports_syncobjs && xwl_screen->explicit_sync) {
+        /* explicit sync requires syncobj support */
+        wp_linux_drm_syncobj_manager_v1_destroy(xwl_screen->explicit_sync);
+        xwl_screen->explicit_sync = NULL;
+    }
+
     return TRUE;
 error:
     if (xwl_screen->egl_display != EGL_NO_DISPLAY) {
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index eb15eea2db..f033664375 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -41,6 +41,7 @@
 
 #include "drm-client-protocol.h"
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "linux-drm-syncobj-v1-client-protocol.h"
 
 #include "xwayland-dmabuf.h"
 #include "xwayland-glamor.h"
@@ -111,6 +112,8 @@ xwl_glamor_init_wl_registry(struct xwl_screen *xwl_screen,
         xwl_screen_set_drm_interface(xwl_screen, id, version);
     else if (strcmp(interface, zwp_linux_dmabuf_v1_interface.name) == 0)
         xwl_screen_set_dmabuf_interface(xwl_screen, id, version);
+    else if (strcmp(interface, wp_linux_drm_syncobj_manager_v1_interface.name) == 0)
+        xwl_screen_set_syncobj_interface(xwl_screen, id, version);
 }
 
 static Bool
@@ -293,6 +296,27 @@ xwl_glamor_get_fence(struct xwl_screen *xwl_screen)
     return fence_fd;
 }
 
+void
+xwl_glamor_wait_fence(struct xwl_screen *xwl_screen, int fence_fd)
+{
+    EGLint attribs[3];
+    EGLSyncKHR sync;
+
+    if (!xwl_screen->glamor)
+        return;
+
+    xwl_glamor_egl_make_current(xwl_screen);
+
+    attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+    attribs[1] = fence_fd;
+    attribs[2] = EGL_NONE;
+    sync = eglCreateSyncKHR(xwl_screen->egl_display, EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+    if (sync != EGL_NO_SYNC_KHR) {
+        eglWaitSyncKHR(xwl_screen->egl_display, sync, 0);
+        eglDestroySyncKHR(xwl_screen->egl_display, sync);
+    }
+}
+
 Bool
 xwl_glamor_init(struct xwl_screen *xwl_screen)
 {
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index d12cd31d61..f90ff4a9af 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -35,6 +35,7 @@
 
 #include "xwayland-types.h"
 #include "xwayland-glamor-gbm.h"
+#include "dri3.h"
 
 typedef enum _xwl_glamor_mode_flags{
     XWL_GLAMOR_NONE = 0,
@@ -49,6 +50,8 @@ Bool xwl_glamor_init(struct xwl_screen *xwl_screen);
 
 Bool xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
                                   uint32_t id, uint32_t version);
+Bool xwl_screen_set_syncobj_interface(struct xwl_screen *xwl_screen,
+                                      uint32_t id, uint32_t version);
 struct wl_buffer *xwl_glamor_pixmap_get_wl_buffer(PixmapPtr pixmap);
 void xwl_glamor_init_wl_registry(struct xwl_screen *xwl_screen,
                                  struct wl_registry *registry,
@@ -60,6 +63,15 @@ PixmapPtr xwl_glamor_create_pixmap_for_window (struct xwl_window *xwl_window);
 Bool xwl_glamor_supports_implicit_sync(struct xwl_screen *xwl_screen);
 Bool xwl_glamor_supports_syncobjs(struct xwl_screen *xwl_screen);
 int xwl_glamor_get_fence(struct xwl_screen *screen);
+void xwl_glamor_wait_fence(struct xwl_screen *xwl_screen, int fence);
+int xwl_glamor_dmabuf_export_sync_file(PixmapPtr pixmap);
+void xwl_glamor_dmabuf_import_sync_file(PixmapPtr pixmap, int sync_file);
+struct dri3_syncobj *xwl_glamor_dri3_syncobj_create(struct xwl_screen *xwl_screen);
+void xwl_glamor_dri3_syncobj_passthrough(WindowPtr window,
+                                         struct dri3_syncobj *acquire_syncobj,
+                                         struct dri3_syncobj *release_syncobj,
+                                         uint64_t acquire_point,
+                                         uint64_t release_point);
 
 #ifdef XV
 /* glamor Xv Adaptor */
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index 5673c2a4c3..e88c750f12 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -40,6 +40,7 @@
 #include "xwayland-pixmap.h"
 
 #include "tearing-control-v1-client-protocol.h"
+#include "linux-drm-syncobj-v1-client-protocol.h"
 
 #define XWL_PRESENT_CAPS PresentCapabilityAsync | PresentCapabilityAsyncMayTear
 
@@ -322,10 +323,6 @@ xwl_present_free_event(struct xwl_present_event *event)
 static void
 xwl_present_free_idle_vblank(present_vblank_ptr vblank)
 {
-    if (vblank->release_syncobj)
-        vblank->release_syncobj->signal(vblank->release_syncobj,
-                                        vblank->release_point);
-
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
     xwl_present_free_event(xwl_present_event_from_vblank(vblank));
 }
@@ -480,6 +477,7 @@ static void
 xwl_present_buffer_release(void *data)
 {
     struct xwl_present_window *xwl_present_window;
+    struct xwl_screen *xwl_screen;
     struct xwl_present_event *event = data;
     present_vblank_ptr vblank;
 
@@ -488,9 +486,16 @@ xwl_present_buffer_release(void *data)
 
     vblank = &event->vblank;
 
-    if (vblank->release_syncobj)
-        vblank->release_syncobj->signal(vblank->release_syncobj,
-                                        vblank->release_point);
+    xwl_screen = xwl_screen_get(vblank->screen);
+#ifdef XWL_HAS_GLAMOR
+    if (vblank->release_syncobj && !xwl_screen->explicit_sync) {
+        /* transfer implicit fence to release syncobj */
+        int fence_fd = xwl_glamor_dmabuf_export_sync_file(vblank->pixmap);
+        vblank->release_syncobj->import_fence(vblank->release_syncobj,
+                                              vblank->release_point,
+                                              fence_fd);
+    }
+#endif /* XWL_HAS_GLAMOR */
 
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 
@@ -756,7 +761,8 @@ xwl_present_check_flip(RRCrtcPtr crtc,
         !xwl_glamor_check_flip(present_window, pixmap))
         return FALSE;
 
-    if (!xwl_glamor_supports_implicit_sync(xwl_screen))
+    if (!xwl_glamor_supports_implicit_sync(xwl_screen) &&
+        !xwl_screen->explicit_sync)
         return FALSE;
 #endif /* XWL_HAS_GLAMOR */
 
@@ -831,6 +837,18 @@ xwl_present_clear_window_flip(WindowPtr window)
     /* xwl_present_cleanup cleaned up everything */
 }
 
+static void
+xwl_present_release_fence_avail(int fd, int xevents, void *data)
+{
+    present_vblank_ptr vblank = data;
+
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    vblank->efd = -1;
+
+    xwl_present_buffer_release(xwl_present_event_from_vblank(vblank));
+}
+
 static Bool
 xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
 {
@@ -841,6 +859,7 @@ xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
     BoxPtr                      damage_box;
     struct wl_buffer            *buffer;
     struct xwl_present_event    *event = xwl_present_event_from_vblank(vblank);
+    Bool                        implicit_sync = TRUE;
 
     if (!xwl_window)
         return FALSE;
@@ -857,7 +876,38 @@ xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
 
     event->pixmap = pixmap;
 
-    xwl_pixmap_set_buffer_release_cb(pixmap, xwl_present_buffer_release, event);
+#ifdef XWL_HAS_GLAMOR
+    if (vblank->acquire_syncobj && vblank->release_syncobj) {
+        if (xwl_window->xwl_screen->explicit_sync) {
+            xwl_glamor_dri3_syncobj_passthrough(present_window,
+                                                vblank->acquire_syncobj,
+                                                vblank->release_syncobj,
+                                                vblank->acquire_point,
+                                                vblank->release_point);
+            implicit_sync = FALSE;
+            /* set up release callback */
+            vblank->efd = eventfd(0, EFD_CLOEXEC);
+            SetNotifyFd(vblank->efd, xwl_present_release_fence_avail, X_NOTIFY_READ, vblank);
+            vblank->release_syncobj->submitted_eventfd(vblank->release_syncobj,
+                                                       vblank->release_point,
+                                                       vblank->efd);
+        } else {
+            /* transfer from acquire syncobj to implicit fence */
+            int fence_fd =
+                vblank->acquire_syncobj->export_fence(vblank->acquire_syncobj,
+                                                      vblank->acquire_point);
+            xwl_glamor_dmabuf_import_sync_file(vblank->pixmap, fence_fd);
+        }
+    }
+#endif /* XWL_HAS_GLAMOR */
+
+    if (vblank->efd == -1)
+        xwl_pixmap_set_buffer_release_cb(pixmap, xwl_present_buffer_release, event);
+
+    if (implicit_sync && xwl_window->surface_sync) {
+        wp_linux_drm_syncobj_surface_v1_destroy(xwl_window->surface_sync);
+        xwl_window->surface_sync = NULL;
+    }
 
     /* We can flip directly to the main surface (full screen window without clips) */
     wl_surface_attach(xwl_window->surface, buffer, 0, 0);
@@ -888,6 +938,11 @@ xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
 
     wl_surface_commit(xwl_window->surface);
 
+    if (xwl_window->surface_sync) {
+        wp_linux_drm_syncobj_surface_v1_destroy(xwl_window->surface_sync);
+        xwl_window->surface_sync = NULL;
+    }
+
     if (!vblank->sync_flip) {
         xwl_present_window->sync_callback =
             wl_display_sync(xwl_window->xwl_screen->display);
@@ -900,6 +955,38 @@ xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
     return TRUE;
 }
 
+static void
+xwl_present_acquire_fence_avail(int fd, int xevents, void *data)
+{
+    present_vblank_ptr vblank = data;
+
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    vblank->efd = -1;
+
+    xwl_present_re_execute(vblank);
+}
+
+static Bool
+xwl_present_wait_acquire_fence_avail(struct xwl_screen *xwl_screen,
+                                     present_vblank_ptr vblank)
+{
+    /* If the compositor does not support explicit sync we need to wait for the
+     * acquire fence to be submitted before flipping. */
+    if (vblank->flip && !xwl_screen->explicit_sync &&
+        vblank->pixmap && vblank->acquire_syncobj &&
+        !vblank->acquire_syncobj->has_fence(vblank->acquire_syncobj,
+                                            vblank->acquire_point)) {
+        vblank->efd = eventfd(0, EFD_CLOEXEC);
+        SetNotifyFd(vblank->efd, xwl_present_acquire_fence_avail, X_NOTIFY_READ, vblank);
+        vblank->acquire_syncobj->submitted_eventfd(vblank->acquire_syncobj,
+                                                   vblank->acquire_point,
+                                                   vblank->efd);
+        return TRUE;
+    }
+    return FALSE;
+}
+
 /*
  * Once the required MSC has been reached, execute the pending request.
  *
@@ -916,11 +1003,13 @@ xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
     present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
     struct xwl_present_event *event = xwl_present_event_from_vblank(vblank);
+    struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
 
     xorg_list_del(&vblank->event_queue);
 
 retry:
-    if (present_execute_wait(vblank, crtc_msc))
+    if (present_execute_wait(vblank, crtc_msc) ||
+        xwl_present_wait_acquire_fence_avail(xwl_screen, vblank))
         return;
 
     if (flip_pending && vblank->flip && vblank->pixmap && vblank->window) {
@@ -956,7 +1045,6 @@ retry:
             if (xwl_present_flip(vblank, damage)) {
                 WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(vblank->window);
                 struct xwl_window *xwl_window = xwl_window_from_window(window);
-                struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
                 PixmapPtr old_pixmap = screen->GetWindowPixmap(window);
 
                 /* Replace window pixmap with flip pixmap */
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index d0b510d1b4..2b3bdb29e8 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -112,6 +112,7 @@ struct xwl_screen {
     struct xwayland_shell_v1 *xwayland_shell;
     struct wp_tearing_control_manager_v1 *tearing_control_manager;
     struct wp_fractional_scale_manager_v1 *fractional_scale_manager;
+    struct wp_linux_drm_syncobj_manager_v1 *explicit_sync;
     struct xorg_list drm_lease_devices;
     struct xorg_list queued_drm_lease_devices;
     struct xorg_list drm_leases;
diff --git a/hw/xwayland/xwayland-window-buffers.c b/hw/xwayland/xwayland-window-buffers.c
index 85c987de72..9f73c7a0e4 100644
--- a/hw/xwayland/xwayland-window-buffers.c
+++ b/hw/xwayland/xwayland-window-buffers.c
@@ -35,6 +35,11 @@
 #ifdef XWL_HAS_GLAMOR
 #include "glamor.h"
 #endif
+#include "dri3.h"
+
+#include <poll.h>
+#include <sys/eventfd.h>
+#include "linux-drm-syncobj-v1-client-protocol.h"
 
 #define BUFFER_TIMEOUT 1 * 1000 /* ms */
 
@@ -42,6 +47,9 @@ struct xwl_window_buffer {
     struct xwl_window *xwl_window;
     PixmapPtr pixmap;
     RegionPtr damage_region;
+    struct dri3_syncobj *syncobj;
+    uint64_t timeline_point;
+    int efd;
     int refcnt;
     uint32_t time;
     struct xorg_list link_buffer;
@@ -79,6 +87,7 @@ xwl_window_buffer_new(struct xwl_window *xwl_window)
     xwl_window_buffer->xwl_window = xwl_window;
     xwl_window_buffer->damage_region = RegionCreate(NullBox, 1);
     xwl_window_buffer->pixmap = NullPixmap;
+    xwl_window_buffer->efd = -1;
     xwl_window_buffer->refcnt = 1;
 
     xorg_list_init(&xwl_window_buffer->link_buffer);
@@ -109,6 +118,14 @@ xwl_window_buffer_maybe_dispose(struct xwl_window_buffer *xwl_window_buffer)
     if (xwl_window_buffer->pixmap)
         xwl_window_buffer_destroy_pixmap (xwl_window_buffer);
 
+    if (xwl_window_buffer->syncobj)
+        xwl_window_buffer->syncobj->free(xwl_window_buffer->syncobj);
+
+    if (xwl_window_buffer->efd >= 0) {
+        SetNotifyFd(xwl_window_buffer->efd, NULL, 0, NULL);
+        close(xwl_window_buffer->efd);
+    }
+
     xorg_list_del(&xwl_window_buffer->link_buffer);
     free(xwl_window_buffer);
 
@@ -215,6 +232,18 @@ xwl_window_buffer_release_callback(void *data)
                  xwl_window);
 }
 
+static void
+xwl_window_buffers_release_fence_avail(int fd, int xevents, void *data)
+{
+    struct xwl_window_buffer *xwl_window_buffer = data;
+
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    xwl_window_buffer->efd = -1;
+
+    xwl_window_buffer_release_callback(data);
+}
+
 void
 xwl_window_buffers_init(struct xwl_window *xwl_window)
 {
@@ -333,12 +362,53 @@ xwl_window_realloc_pixmap(struct xwl_window *xwl_window)
     screen->DestroyPixmap(window_pixmap);
 }
 
+#ifdef XWL_HAS_GLAMOR
+static Bool
+xwl_window_buffers_set_syncpts(struct xwl_window_buffer *xwl_window_buffer)
+{
+    struct xwl_window *xwl_window = xwl_window_buffer->xwl_window;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    uint64_t acquire_point = ++xwl_window_buffer->timeline_point;
+    uint64_t release_point = ++xwl_window_buffer->timeline_point;
+
+    if (!xwl_window_buffer->syncobj) {
+        struct dri3_syncobj *syncobj = xwl_glamor_dri3_syncobj_create(xwl_screen);
+        if (!syncobj)
+            goto fail;
+        xwl_window_buffer->syncobj = syncobj;
+    }
+
+    int fence_fd = xwl_glamor_get_fence(xwl_screen);
+    if (fence_fd >= 0)
+        xwl_window_buffer->syncobj->import_fence(xwl_window_buffer->syncobj,
+                                                 acquire_point, fence_fd);
+    else
+        goto fail;
+
+    xwl_glamor_dri3_syncobj_passthrough(xwl_window->window,
+                                        xwl_window_buffer->syncobj,
+                                        xwl_window_buffer->syncobj,
+                                        acquire_point,
+                                        release_point);
+    return TRUE;
+
+fail:
+    /* can't use explicit sync, we will do a glFinish() before presenting */
+    if (xwl_window_buffer->syncobj) {
+        xwl_window_buffer->syncobj->free(xwl_window_buffer->syncobj);
+        xwl_window_buffer->syncobj = NULL;
+    }
+    return FALSE;
+}
+#endif /* XWL_HAS_GLAMOR */
+
 PixmapPtr
 xwl_window_swap_pixmap(struct xwl_window *xwl_window)
 {
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     struct xwl_window_buffer *xwl_window_buffer;
     PixmapPtr window_pixmap;
+    Bool implicit_sync = TRUE;
 
     window_pixmap = (*xwl_screen->screen->GetWindowPixmap) (xwl_window->window);
 
@@ -350,6 +420,16 @@ xwl_window_swap_pixmap(struct xwl_window *xwl_window)
         BoxPtr pBox = RegionRects(full_damage);
         int nBox = RegionNumRects(full_damage);
 
+#ifdef XWL_HAS_GLAMOR
+        if (xwl_window_buffer->syncobj) {
+            int fence_fd =
+                xwl_window_buffer->syncobj->export_fence(xwl_window_buffer->syncobj,
+                                                         xwl_window_buffer->timeline_point);
+            xwl_glamor_wait_fence(xwl_screen, fence_fd);
+            close(fence_fd);
+        }
+#endif /* XWL_HAS_GLAMOR */
+
         while (nBox--) {
             copy_pixmap_area(window_pixmap,
                              xwl_window_buffer->pixmap,
@@ -390,12 +470,33 @@ xwl_window_swap_pixmap(struct xwl_window *xwl_window)
 
 #ifdef XWL_HAS_GLAMOR
     if (!xwl_glamor_supports_implicit_sync(xwl_screen)) {
-        glamor_finish(xwl_screen->screen);
+        if (xwl_screen->explicit_sync && xwl_window_buffers_set_syncpts(xwl_window_buffer)) {
+            implicit_sync = FALSE;
+            /* wait until the release fence is available before re-using this buffer */
+            xwl_window_buffer->efd = eventfd(0, EFD_CLOEXEC);
+            SetNotifyFd(xwl_window_buffer->efd, xwl_window_buffers_release_fence_avail,
+                        X_NOTIFY_READ, xwl_window_buffer);
+            xwl_window_buffer->syncobj->submitted_eventfd(xwl_window_buffer->syncobj,
+                                                          xwl_window_buffer->timeline_point,
+                                                          xwl_window_buffer->efd);
+        } else
+            /* If glamor does not support implicit sync and we can't use
+             * explicit sync, wait for the GPU to be idle before presenting.
+             * Note that buffer re-use will still be unsynchronized :(
+             */
+            glamor_finish(xwl_screen->screen);
     }
 #endif /* XWL_HAS_GLAMOR */
-    xwl_pixmap_set_buffer_release_cb(xwl_window_buffer->pixmap,
-                                     xwl_window_buffer_release_callback,
-                                     xwl_window_buffer);
+
+    if (xwl_window_buffer->efd == -1)
+        xwl_pixmap_set_buffer_release_cb(xwl_window_buffer->pixmap,
+                                         xwl_window_buffer_release_callback,
+                                         xwl_window_buffer);
+
+    if (implicit_sync && xwl_window->surface_sync) {
+        wp_linux_drm_syncobj_surface_v1_destroy(xwl_window->surface_sync);
+        xwl_window->surface_sync = NULL;
+    }
 
     xorg_list_append(&xwl_window_buffer->link_buffer,
                      &xwl_window->window_buffers_unavailable);
diff --git a/hw/xwayland/xwayland-window.c b/hw/xwayland/xwayland-window.c
index f4d8a0227e..a8731f4dda 100644
--- a/hw/xwayland/xwayland-window.c
+++ b/hw/xwayland/xwayland-window.c
@@ -55,6 +55,7 @@
 #include "xdg-shell-client-protocol.h"
 #include "xwayland-shell-v1-client-protocol.h"
 #include "fractional-scale-v1-client-protocol.h"
+#include "linux-drm-syncobj-v1-client-protocol.h"
 
 #define DELAYED_WL_SURFACE_DESTROY 1000 /* ms */
 
@@ -1496,6 +1497,9 @@ xwl_unrealize_window(WindowPtr window)
     if (xwl_window->fractional_scale)
         wp_fractional_scale_v1_destroy(xwl_window->fractional_scale);
 
+    if (xwl_window->surface_sync)
+        wp_linux_drm_syncobj_surface_v1_destroy(xwl_window->surface_sync);
+
     release_wl_surface_for_window(xwl_window);
     xorg_list_del(&xwl_window->link_damage);
     xorg_list_del(&xwl_window->link_window);
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
index 108c19e09c..a00284fde9 100644
--- a/hw/xwayland/xwayland-window.h
+++ b/hw/xwayland/xwayland-window.h
@@ -84,6 +84,7 @@ struct xwl_window {
     struct wp_tearing_control_v1 *tearing_control;
     struct wp_fractional_scale_v1 *fractional_scale;
     int fractional_scale_numerator;
+    struct wp_linux_drm_syncobj_surface_v1 *surface_sync;
 };
 
 struct xwl_window *xwl_window_get(WindowPtr window);
diff --git a/meson.build b/meson.build
index c26d1644f8..93a9ecf872 100644
--- a/meson.build
+++ b/meson.build
@@ -64,7 +64,7 @@ libdrm_req = '>= 2.4.109'
 libselinux_req = '>= 2.0.86'
 xext_req = '>= 1.0.99.4'
 wayland_req = '>= 1.21.0'
-wayland_protocols_req = '>= 1.31'
+wayland_protocols_req = '>= 1.34'
 gbm_req = '>= 10.2'
 xf86dgaproto_req = '>= 2.0.99.1'
 xshmfence_req = '>= 1.1'
diff --git a/present/present_execute.c b/present/present_execute.c
index 913a8b67ba..2fb49749eb 100644
--- a/present/present_execute.c
+++ b/present/present_execute.c
@@ -73,7 +73,10 @@ present_execute_wait(present_vblank_ptr vblank, uint64_t crtc_msc)
         }
     }
 
-    if (vblank->acquire_syncobj &&
+    /* Defer execution of explicitly synchronized copies.
+     * Flip synchronization is managed by the driver.
+     */
+    if (!vblank->flip && vblank->acquire_syncobj &&
         !vblank->acquire_syncobj->is_signaled(vblank->acquire_syncobj,
                                               vblank->acquire_point)) {
         vblank->efd = eventfd(0, EFD_CLOEXEC);
-- 
GitLab


From 6084919abd962ab4a9de7325a0877e58f169d2d2 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Wed, 31 Jan 2024 11:36:45 -0800
Subject: [PATCH 8/8] xwayland: don't scrap pending present requests

When a present request is received, Xwayland will check if there is an
existing request targeting the same window and msc and scrap the older
request if so. Alas, this does not interact well the older fence-based
or newer syncobj-based synchronization features of the Present
extension.

Since execution of a request may be delayed for an unknown length of
time while waiting for a fence to be signaled, the target msc computed
upon receiving a request may not match the actual msc at which the
request is executed. Therefore, we cannot determine in advance whether a
more recently received request will make an older request redundant.

This change removes the code to scrap pending present requests.

We must also ensure requests are executed in the correct order even if
their fences are signaled out of order. To achieve this, whenever
execution of a request needs to wait for a fence, execution of any
later-received requests will be blocked until the earlier request is
ready. The blocked requests will be added to a list tracked in the
xwl_present_window struct. Once the earlier request's fence is signaled,
any blocked requests will be re-executed.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xwayland/xwayland-present.c | 93 ++++++++++++++++++++--------------
 hw/xwayland/xwayland-present.h |  4 ++
 2 files changed, 60 insertions(+), 37 deletions(-)

diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index e88c750f12..4cbb38c693 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -81,6 +81,7 @@ xwl_present_window_get_priv(WindowPtr window)
         xorg_list_init(&xwl_present_window->wait_list);
         xorg_list_init(&xwl_present_window->flip_queue);
         xorg_list_init(&xwl_present_window->idle_queue);
+        xorg_list_init(&xwl_present_window->blocked_queue);
 
         dixSetPrivate(&window->devPrivates,
                       &xwl_present_window_private_key,
@@ -172,7 +173,8 @@ xwl_present_has_pending_events(struct xwl_present_window *xwl_present_window)
     present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
 
     return (flip_pending && flip_pending->sync_flip) ||
-           !xorg_list_is_empty(&xwl_present_window->wait_list);
+           !xorg_list_is_empty(&xwl_present_window->wait_list) ||
+           !xorg_list_is_empty(&xwl_present_window->blocked_queue);
 }
 
 void
@@ -987,6 +989,34 @@ xwl_present_wait_acquire_fence_avail(struct xwl_screen *xwl_screen,
     return FALSE;
 }
 
+static void
+xwl_present_flush_blocked(struct xwl_present_window *xwl_present_window,
+                          uint64_t crtc_msc)
+{
+    struct xwl_screen *xwl_screen =
+        xwl_screen_get(xwl_present_window->window->drawable.pScreen);
+    struct xwl_present_event *blocked_event, *tmp;
+
+    if (!xwl_present_window->blocking_event)
+        return;
+
+    xwl_present_window->blocking_event = 0;
+
+    xorg_list_for_each_entry_safe(blocked_event, tmp,
+                                  &xwl_present_window->blocked_queue,
+                                  blocked) {
+        present_vblank_ptr blocked_vblank = &blocked_event->vblank;
+        xorg_list_del(&blocked_event->blocked);
+        if (present_execute_wait(blocked_vblank, crtc_msc) ||
+            xwl_present_wait_acquire_fence_avail(xwl_screen, blocked_vblank)) {
+            xwl_present_window->blocking_event = blocked_vblank->event_id;
+            return;
+        }
+
+        xwl_present_re_execute(blocked_vblank);
+    }
+}
+
 /*
  * Once the required MSC has been reached, execute the pending request.
  *
@@ -1004,15 +1034,28 @@ xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
     present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
     struct xwl_present_event *event = xwl_present_event_from_vblank(vblank);
     struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
+    Bool notify_only = !vblank->window || !vblank->pixmap;
 
     xorg_list_del(&vblank->event_queue);
 
+    if (!notify_only && !event->copy_executed &&
+        xwl_present_window->blocking_event &&
+        xwl_present_window->blocking_event != event->vblank.event_id) {
+        /* an earlier request is blocking execution */
+        xorg_list_append(&event->blocked, &xwl_present_window->blocked_queue);
+        return;
+    }
+
 retry:
     if (present_execute_wait(vblank, crtc_msc) ||
-        xwl_present_wait_acquire_fence_avail(xwl_screen, vblank))
+        xwl_present_wait_acquire_fence_avail(xwl_screen, vblank)) {
+        if (!notify_only)
+            /* block execution of subsequent requests until this request is ready */
+            xwl_present_window->blocking_event = event->vblank.event_id;
         return;
+    }
 
-    if (flip_pending && vblank->flip && vblank->pixmap && vblank->window) {
+    if (flip_pending && vblank->flip && !notify_only) {
         DebugPresent(("\tr %" PRIu64 " %p (pending %p)\n",
                       vblank->event_id, vblank, flip_pending));
         xorg_list_append(&vblank->event_queue, &xwl_present_window->flip_queue);
@@ -1022,8 +1065,9 @@ retry:
 
     vblank->queued = FALSE;
 
-    if (vblank->pixmap && vblank->window && !event->copy_executed) {
+    if (!notify_only && !event->copy_executed) {
         ScreenPtr screen = window->drawable.pScreen;
+        int ret;
 
         if (vblank->flip) {
             RegionPtr damage;
@@ -1080,6 +1124,7 @@ retry:
                 /* Realign timer */
                 xwl_present_reset_timer(xwl_present_window);
 
+                xwl_present_flush_blocked(xwl_present_window, crtc_msc);
                 return;
             }
 
@@ -1101,9 +1146,12 @@ retry:
         /* Set the copy_executed field, so this will fall through to present_execute_post next time */
         event->copy_executed = TRUE;
 
-        if (xwl_present_queue_vblank(screen, window, vblank->crtc,
-                                     vblank->event_id, crtc_msc + 1)
-            == Success)
+        ret = xwl_present_queue_vblank(screen, window, vblank->crtc,
+                                       vblank->event_id, crtc_msc + 1);
+
+        xwl_present_flush_blocked(xwl_present_window, crtc_msc);
+
+        if (ret == Success)
             return;
     }
 
@@ -1137,7 +1185,7 @@ xwl_present_pixmap(WindowPtr window,
     uint64_t                    target_msc;
     uint64_t                    crtc_msc = 0;
     int                         ret;
-    present_vblank_ptr          vblank, tmp;
+    present_vblank_ptr          vblank;
     ScreenPtr                   screen = window->drawable.pScreen;
     present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
@@ -1170,35 +1218,6 @@ xwl_present_pixmap(WindowPtr window,
                                         remainder,
                                         options);
 
-    /*
-     * Look for a matching presentation already on the list...
-     */
-
-    if (!update && pixmap) {
-        xorg_list_for_each_entry_safe(vblank, tmp, &window_priv->vblank, window_list) {
-
-            if (!vblank->pixmap)
-                continue;
-
-            if (!vblank->queued)
-                continue;
-
-            if (vblank->target_msc != target_msc)
-                continue;
-
-            if (xwl_present_event_from_vblank(vblank)->copy_executed)
-                continue;
-
-            if (vblank->release_syncobj)
-                vblank->release_syncobj->signal(vblank->release_syncobj,
-                                                vblank->release_point);
-
-            present_vblank_scrap(vblank);
-            if (vblank->flip_ready)
-                xwl_present_re_execute(vblank);
-        }
-    }
-
     event = calloc(1, sizeof(*event));
     if (!event)
         return BadAlloc;
diff --git a/hw/xwayland/xwayland-present.h b/hw/xwayland/xwayland-present.h
index 33c55b38bf..a2390adaf2 100644
--- a/hw/xwayland/xwayland-present.h
+++ b/hw/xwayland/xwayland-present.h
@@ -50,8 +50,10 @@ struct xwl_present_window {
     struct xorg_list wait_list;
     struct xorg_list flip_queue;
     struct xorg_list idle_queue;
+    struct xorg_list blocked_queue;
 
     present_vblank_ptr flip_active;
+    uint64_t blocking_event;
 };
 
 struct xwl_present_event {
@@ -65,6 +67,8 @@ struct xwl_present_event {
     uint32_t options;
     uint64_t divisor;
     uint64_t remainder;
+
+    struct xorg_list blocked;
 };
 
 Bool xwl_present_entered_for_each_frame_callback(void);
-- 
GitLab

