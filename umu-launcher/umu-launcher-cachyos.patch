From 40f2a860741ce8920be076ca19e807f2b8e6719d Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 20 Mar 2025 11:57:43 +0200
Subject: [PATCH 01/43] Reapply "umu_run: handle Protons without an explicit
 runtime requirement"

This reverts commit 6494ecd8007f64d245740e78f71d3008d862214f.
---
 tests/test_config.sh    |   1 +
 umu/umu_plugins.py      |   6 +-
 umu/umu_run.py          | 115 ++++++++++++++++++++++---------------
 umu/umu_runtime.py      |   5 --
 umu/umu_test.py         | 124 +++++++++++++++++++++++-----------------
 umu/umu_test_plugins.py |  37 ++++++------
 6 files changed, 163 insertions(+), 125 deletions(-)

diff --git a/tests/test_config.sh b/tests/test_config.sh
index 367f1ac..7bed18f 100644
--- a/tests/test_config.sh
+++ b/tests/test_config.sh
@@ -19,5 +19,6 @@ store = 'gog'
 " >> "$tmp"
 
 
+# This works only for an existing prefix, the prefix `~/Games/umu/umu-0` is created in the previous workflow steps
 RUNTIMEPATH=steamrt3 UMU_LOG=debug GAMEID=umu-1141086411 STORE=gog "$PWD/.venv/bin/python" "$HOME/.local/bin/umu-run" --config "$tmp" 2> /tmp/umu-log.txt && grep -E "INFO: Non-steam game Silent Hill 4: The Room \(umu-1141086411\)" /tmp/umu-log.txt
 # Run the 'game' using UMU-Proton9.0-3.2 and ensure the protonfixes module finds its fix in umu-database.csv
diff --git a/umu/umu_plugins.py b/umu/umu_plugins.py
index ec859f0..887dab7 100644
--- a/umu/umu_plugins.py
+++ b/umu/umu_plugins.py
@@ -52,9 +52,9 @@ def set_env_toml(
     _check_env_toml(toml)
 
     # Required environment variables
-    env["WINEPREFIX"] = toml["umu"]["prefix"]
-    env["PROTONPATH"] = toml["umu"]["proton"]
-    env["EXE"] = toml["umu"]["exe"]
+    env["WINEPREFIX"] = str(Path(toml["umu"]["prefix"]).expanduser())
+    env["PROTONPATH"] = str(Path(toml["umu"]["proton"]).expanduser())
+    env["EXE"] = str(Path(toml["umu"]["exe"]).expanduser())
     # Optional
     env["GAMEID"] = toml["umu"].get("game_id", "")
     env["STORE"] = toml["umu"].get("store", "")
diff --git a/umu/umu_run.py b/umu/umu_run.py
index b127c0c..a8474f3 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -39,7 +39,7 @@ from umu.umu_consts import (
 from umu.umu_log import log
 from umu.umu_plugins import set_env_toml
 from umu.umu_proton import get_umu_proton
-from umu.umu_runtime import setup_umu
+from umu.umu_runtime import create_shim, setup_umu
 from umu.umu_util import (
     get_libc,
     get_library_paths,
@@ -88,9 +88,7 @@ def setup_pfx(path: str) -> None:
         wineuser.symlink_to("steamuser")
 
 
-def check_env(
-    env: dict[str, str], session_pools: tuple[ThreadPoolExecutor, PoolManager]
-) -> dict[str, str] | dict[str, Any]:
+def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], bool]:
     """Before executing a game, check for environment variables and set them.
 
     GAMEID is strictly required and the client is responsible for setting this.
@@ -122,9 +120,10 @@ def check_env(
 
     env["WINEPREFIX"] = os.environ.get("WINEPREFIX", "")
 
+    do_download = False
     # Skip Proton if running a native Linux executable
     if os.environ.get("UMU_NO_PROTON") == "1":
-        return env
+        return env, do_download
 
     # Proton Version
     path: Path = STEAM_COMPAT.joinpath(os.environ.get("PROTONPATH", ""))
@@ -133,16 +132,28 @@ def check_env(
 
     # Proton Codename
     if os.environ.get("PROTONPATH") in {"GE-Proton", "GE-Latest", "UMU-Latest"}:
-        get_umu_proton(env, session_pools)
+        do_download = True
 
     if "PROTONPATH" not in os.environ:
         os.environ["PROTONPATH"] = ""
-        get_umu_proton(env, session_pools)
+        do_download = True
 
     env["PROTONPATH"] = os.environ["PROTONPATH"]
 
+    return env, do_download
+
+
+def download_proton(download: bool, env: dict[str, str], session_pools: tuple[ThreadPoolExecutor, PoolManager]) -> None:
+    """Check if umu should download proton and check if PROTONPATH is set.
+
+    I am not gonna lie about it, this only exists to satisfy the tests, because downloading
+    was previously nested in `check_env()`
+    """
+    if download:
+        get_umu_proton(env, session_pools)
+
     # If download fails/doesn't exist in the system, raise an error
-    if not os.environ["PROTONPATH"]:
+    if os.environ.get("UMU_NO_PROTON") != "1" and not os.environ["PROTONPATH"]:
         err: str = (
             "Environment variable not set or is empty: PROTONPATH\n"
             f"Possible reason: GE-Proton or UMU-Proton not found in '{STEAM_COMPAT}'"
@@ -150,8 +161,6 @@ def check_env(
         )
         raise FileNotFoundError(err)
 
-    return env
-
 
 def set_env(
     env: dict[str, str], args: Namespace | tuple[str, list[str]]
@@ -288,12 +297,17 @@ def enable_steam_game_drive(env: dict[str, str]) -> dict[str, str]:
 def build_command(
     env: dict[str, str],
     local: Path,
-    opts: list[str] = [],
+    version: str,
+    opts: list[str] | None = None,
 ) -> tuple[Path | str, ...]:
     """Build the command to be executed."""
     shim: Path = local.joinpath("umu-shim")
     proton: Path = Path(env["PROTONPATH"], "proton")
-    entry_point: Path = local.joinpath("umu")
+    entry_point: tuple[Path, str, str, str] | tuple[()] = (
+        local.joinpath(version, "umu"), "--verb", env["PROTON_VERB"], "--"
+    ) if version != "host" else ()
+    if opts is None:
+        opts = []
 
     if env.get("UMU_NO_PROTON") != "1" and not proton.is_file():
         err: str = "The following file was not found in PROTONPATH: proton"
@@ -302,7 +316,7 @@ def build_command(
     # Exit if the entry point is missing
     # The _v2-entry-point script and container framework tools are included in
     # the same image, so this can happen if the image failed to download
-    if not entry_point.is_file():
+    if entry_point and not entry_point[0].is_file():
         err: str = (
             f"_v2-entry-point (umu) cannot be found in '{local}'\n"
             "Runtime Platform missing or download incomplete"
@@ -314,10 +328,7 @@ def build_command(
         # The position of arguments matter for winetricks
         # Usage: ./winetricks [options] [command|verb|path-to-verb] ...
         return (
-            entry_point,
-            "--verb",
-            env["PROTON_VERB"],
-            "--",
+            *entry_point,
             proton,
             env["PROTON_VERB"],
             env["EXE"],
@@ -329,7 +340,7 @@ def build_command(
     # Ideally, for reliability, executables should be compiled within
     # the Steam Runtime
     if env.get("UMU_NO_PROTON") == "1":
-        return (entry_point, "--verb", env["PROTON_VERB"], "--", env["EXE"], *opts)
+        return *entry_point, env["EXE"], *opts
 
     # Will run the game outside the Steam Runtime w/ Proton
     if env.get("UMU_NO_RUNTIME") == "1":
@@ -337,10 +348,7 @@ def build_command(
         return proton, env["PROTON_VERB"], env["EXE"], *opts
 
     return (
-        entry_point,
-        "--verb",
-        env["PROTON_VERB"],
-        "--",
+        *entry_point,
         shim,
         proton,
         env["PROTON_VERB"],
@@ -703,6 +711,9 @@ def resolve_umu_version(runtimes: tuple[RuntimeVersion, ...]) -> RuntimeVersion
     path = Path(os.environ["PROTONPATH"], "toolmanifest.vdf").resolve()
     if path.is_file():
         version = get_umu_version_from_manifest(path, runtimes)
+    else:
+        err: str = f"PROTONPATH '{os.environ['PROTONPATH']}' is not valid, toolmanifest.vdf not found"
+        raise FileNotFoundError(err)
 
     return version
 
@@ -724,7 +735,7 @@ def get_umu_version_from_manifest(
                 break
 
     if not appid:
-        return None
+        return "host", "host", "host"
 
     if appid not in set(filter(None, appids)):
         return None
@@ -812,6 +823,12 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         )
         raise RuntimeError(err)
 
+    if isinstance(args, Namespace):
+        env, opts = set_env_toml(env, args)
+        os.environ.update({k: v for k, v in env.items() if bool(v)})
+    else:
+        opts = args[1]  # Reference the executable options
+
     # Resolve the runtime version for PROTONPATH
     version = resolve_umu_version(__runtime_versions__)
     if not version:
@@ -849,6 +866,9 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
     else:
         timeouts = NET_TIMEOUT
 
+    # ensure base directory exists
+    UMU_LOCAL.mkdir(parents=True, exist_ok=True)
+
     thread_pool = ThreadPoolExecutor()
     http_pool = PoolManager(
         timeout=Timeout(connect=timeouts, read=timeouts),
@@ -858,17 +878,29 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         session_pools: tuple[ThreadPoolExecutor, PoolManager] = (thread_pool, http_pool)
 
         # Setup the launcher and runtime files
-        future: Future = thread_pool.submit(
-            setup_umu, UMU_LOCAL / version[1], version, session_pools
-        )
+        _, do_download = check_env(env)
+
+        if version[1] != "host":
+            UMU_LOCAL.joinpath(version[1]).mkdir(parents=True, exist_ok=True)
+
+            future: Future = thread_pool.submit(
+                setup_umu, UMU_LOCAL / version[1], version, session_pools
+            )
 
-        if isinstance(args, Namespace):
-            env, opts = set_env_toml(env, args)
-        else:
-            opts = args[1]  # Reference the executable options
-            check_env(env, session_pools)
+            download_proton(do_download, env, session_pools)
 
-        UMU_LOCAL.joinpath(version[1]).mkdir(parents=True, exist_ok=True)
+            try:
+                future.result()
+            except HTTPError as e:
+                if not has_umu_setup():
+                    err: str = (
+                        "umu has not been setup for the user\n"
+                        "An internet connection is required to setup umu"
+                    )
+                    raise RuntimeError(err)
+                log.debug(e)
+            except Exception as e:
+                log.exception(e)
 
         # Prepare the prefix
         with unix_flock(f"{UMU_LOCAL}/{FileLock.Prefix.value}"):
@@ -877,25 +909,16 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         # Configure the environment
         set_env(env, args)
 
+        # Restore shim if missing
+        if not UMU_LOCAL.joinpath("umu-shim").is_file():
+            create_shim(UMU_LOCAL / "umu-shim")
+
         # Set all environment variables
         # NOTE: `env` after this block should be read only
         for key, val in env.items():
             log.debug("%s=%s", key, val)
             os.environ[key] = val
 
-        try:
-            future.result()
-        except HTTPError as e:
-            if not has_umu_setup():
-                err: str = (
-                    "umu has not been setup for the user\n"
-                    "An internet connection is required to setup umu"
-                )
-                raise RuntimeError(err)
-            log.debug(e)
-        except Exception as e:
-            log.exception(e)
-
     # Exit if the winetricks verb is already installed to avoid reapplying it
     if env["EXE"].endswith("winetricks") and is_installed_verb(
         opts, Path(env["WINEPREFIX"])
@@ -903,7 +926,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         sys.exit(1)
 
     # Build the command
-    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL / version[1], opts)
+    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL, version[1], opts)
     log.debug("%s", command)
 
     # Run the command
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index b7d9843..5f6df5b 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -226,7 +226,6 @@ def _install_umu(
         finally:
             log.debug("Linking: umu -> _v2-entry-point")
             local.joinpath("umu").symlink_to("_v2-entry-point")
-            create_shim(local.joinpath("umu-shim"))
 
 
 def setup_umu(
@@ -330,10 +329,6 @@ def _update_umu(
     # Update our runtime
     _update_umu_platform(local, runtime_ver, session_pools, resp)
 
-    # Restore shim if missing
-    if not local.joinpath("umu-shim").is_file():
-        create_shim(local / "umu-shim")
-
     log.info("%s is up to date", variant)
 
 
diff --git a/umu/umu_test.py b/umu/umu_test.py
index db60082..a421228 100644
--- a/umu/umu_test.py
+++ b/umu/umu_test.py
@@ -1893,7 +1893,8 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["WINEPREFIX"] = self.test_file
             os.environ["GAMEID"] = self.test_file
             os.environ["PROTONPATH"] = "GE-Proton"
-            umu_run.check_env(self.env, self.test_session_pools)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, self.test_session_pools)
             self.assertEqual(
                 self.env["PROTONPATH"],
                 self.test_compat.joinpath(
@@ -1920,7 +1921,8 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["WINEPREFIX"] = self.test_file
             os.environ["GAMEID"] = self.test_file
             os.environ["PROTONPATH"] = "GE-Proton"
-            umu_run.check_env(self.env, mock_session_pools)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, mock_session_pools)
             self.assertFalse(os.environ.get("PROTONPATH"), "Expected empty string")
 
     def test_latest_interrupt(self):
@@ -2219,7 +2221,7 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, self.test_session_pools)
+            result_env, result_dl = umu_run.check_env(self.env)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2283,7 +2285,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2380,7 +2383,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2460,7 +2464,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result_args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2499,7 +2504,7 @@ class TestGameLauncher(unittest.TestCase):
             )
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share)
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
@@ -2547,7 +2552,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result_args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2586,7 +2592,7 @@ class TestGameLauncher(unittest.TestCase):
         os.environ |= self.env
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share)
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
@@ -2625,7 +2631,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result_args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2640,7 +2647,7 @@ class TestGameLauncher(unittest.TestCase):
 
         # Since we didn't create the proton file, an exception should be raised
         with self.assertRaises(FileNotFoundError):
-            umu_run.build_command(self.env, self.test_local_share)
+            umu_run.build_command(self.env, self.test_local_share, self.test_runtime_version[1])
 
     def test_build_command(self):
         """Test build command.
@@ -2658,7 +2665,7 @@ class TestGameLauncher(unittest.TestCase):
         Path(self.test_file, "proton").touch()
 
         # Mock the shim file
-        shim_path = Path(self.test_local_share, "umu-shim")
+        shim_path = Path(self.test_local_share_parent, "umu-shim")
         shim_path.touch()
 
         with (
@@ -2673,7 +2680,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result_args = __main__.parse_args()
             # Config
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2713,7 +2721,7 @@ class TestGameLauncher(unittest.TestCase):
             )
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share)
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
@@ -2765,7 +2773,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result = __main__.parse_args()
             # Check
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
 
@@ -2846,7 +2855,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result = __main__.parse_args()
             # Check
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2954,7 +2964,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result = __main__.parse_args()
             # Check
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -3070,7 +3081,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result = __main__.parse_args()
             # Check
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -3200,7 +3212,8 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result = __main__.parse_args()
             # Check
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -3684,12 +3697,11 @@ class TestGameLauncher(unittest.TestCase):
         Expects the directory $HOME/Games/umu/$GAMEID to not be created
         when UMU_NO_PROTON=1 and GAMEID is set in the host environment.
         """
-        result = None
+        result_env, result_dl = None, None
         # Mock $HOME
         mock_home = Path(self.test_file)
 
         with (
-            ThreadPoolExecutor() as thread_pool,
             # Mock the internal call to Path.home(). Otherwise, some of our
             # assertions may fail when running this test suite locally if
             # the user already has that dir
@@ -3697,8 +3709,8 @@ class TestGameLauncher(unittest.TestCase):
         ):
             os.environ["UMU_NO_PROTON"] = "1"
             os.environ["GAMEID"] = "foo"
-            result = umu_run.check_env(self.env, thread_pool)
-            self.assertTrue(result is self.env)
+            result_env, result_dl = umu_run.check_env(self.env)
+            self.assertTrue(result_env is self.env)
             path = mock_home.joinpath("Games", "umu", os.environ["GAMEID"])
             # Ensure we did not create the target nor its parents up to $HOME
             self.assertFalse(path.exists(), f"Expected {path} to not exist")
@@ -3717,20 +3729,17 @@ class TestGameLauncher(unittest.TestCase):
         Expects the WINE prefix directory to not be created when
         UMU_NO_PROTON=1 and WINEPREFIX is set in the host environment.
         """
-        result = None
+        result_env, result_dl = None, None
 
-        with (
-            ThreadPoolExecutor() as thread_pool,
-        ):
-            os.environ["WINEPREFIX"] = "123"
-            os.environ["UMU_NO_PROTON"] = "1"
-            os.environ["GAMEID"] = "foo"
-            result = umu_run.check_env(self.env, thread_pool)
-            self.assertTrue(result is self.env)
-            self.assertFalse(
-                Path(os.environ["WINEPREFIX"]).exists(),
-                f"Expected directory {os.environ['WINEPREFIX']} to not exist",
-            )
+        os.environ["WINEPREFIX"] = "123"
+        os.environ["UMU_NO_PROTON"] = "1"
+        os.environ["GAMEID"] = "foo"
+        result_env, result_dl = umu_run.check_env(self.env)
+        self.assertTrue(result_env is self.env)
+        self.assertFalse(
+            Path(os.environ["WINEPREFIX"]).exists(),
+            f"Expected directory {os.environ['WINEPREFIX']} to not exist",
+        )
 
     def test_env_proton_nodir(self):
         """Test check_env when $PROTONPATH in the case we failed to set it.
@@ -3745,7 +3754,8 @@ class TestGameLauncher(unittest.TestCase):
         ):
             os.environ["WINEPREFIX"] = self.test_file
             os.environ["GAMEID"] = self.test_file
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
 
     def test_env_wine_empty(self):
         """Test check_env when $WINEPREFIX is empty.
@@ -3761,7 +3771,8 @@ class TestGameLauncher(unittest.TestCase):
         ):
             os.environ["WINEPREFIX"] = ""
             os.environ["GAMEID"] = self.test_file
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
 
     def test_env_gameid_empty(self):
         """Test check_env when $GAMEID is empty.
@@ -3777,7 +3788,8 @@ class TestGameLauncher(unittest.TestCase):
         ):
             os.environ["WINEPREFIX"] = ""
             os.environ["GAMEID"] = ""
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
 
     def test_env_wine_dir(self):
         """Test check_env when $WINEPREFIX is not a directory.
@@ -3798,7 +3810,8 @@ class TestGameLauncher(unittest.TestCase):
         )
 
         with ThreadPoolExecutor() as thread_pool:
-            umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
 
         # After this, the WINEPREFIX and new dirs should be created
         self.assertTrue(
@@ -3827,15 +3840,16 @@ class TestGameLauncher(unittest.TestCase):
             path_to_tmp,
         )
 
-        result = None
+        result_env, result_dl = None, None
         os.environ["WINEPREFIX"] = unexpanded_path
         os.environ["GAMEID"] = self.test_file
         os.environ["PROTONPATH"] = unexpanded_path
 
         with ThreadPoolExecutor() as thread_pool:
-            result = umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
 
-        self.assertTrue(result is self.env, "Expected the same reference")
+        self.assertTrue(result_env is self.env, "Expected the same reference")
         self.assertEqual(
             self.env["WINEPREFIX"],
             unexpanded_path,
@@ -3852,15 +3866,16 @@ class TestGameLauncher(unittest.TestCase):
 
     def test_env_vars(self):
         """Test check_env when setting $WINEPREFIX, $GAMEID and $PROTONPATH."""
-        result = None
+        result_env, result_dl = None, None
         os.environ["WINEPREFIX"] = self.test_file
         os.environ["GAMEID"] = self.test_file
         os.environ["PROTONPATH"] = self.test_file
 
         with ThreadPoolExecutor() as thread_pool:
-            result = umu_run.check_env(self.env, thread_pool)
+            result_env, result_dl = umu_run.check_env(self.env)
+            umu_run.download_proton(result_dl, result_env, thread_pool)
 
-        self.assertTrue(result is self.env, "Expected the same reference")
+        self.assertTrue(result_env is self.env, "Expected the same reference")
         self.assertEqual(
             self.env["WINEPREFIX"],
             self.test_file,
@@ -3891,8 +3906,9 @@ class TestGameLauncher(unittest.TestCase):
             ):
                 os.environ["WINEPREFIX"] = self.test_file
                 os.environ["GAMEID"] = self.test_file
-                result = umu_run.check_env(self.env, thread_pool)
-                self.assertTrue(result is self.env, "Expected the same reference")
+                result_env, result_dl = umu_run.check_env(self.env)
+                umu_run.download_proton(result_dl, result_env, thread_pool)
+                self.assertTrue(result_env is self.env, "Expected the same reference")
                 self.assertFalse(os.environ["PROTONPATH"])
 
     def test_env_vars_wine(self):
@@ -3900,7 +3916,7 @@ class TestGameLauncher(unittest.TestCase):
 
         Expects GAMEID and PROTONPATH to be set for the command line:
         """
-        result = None
+        result_env, result_dl = None, None
         mock_gameid = "umu-default"
         mock_protonpath = str(self.test_proton_dir)
 
@@ -3913,8 +3929,8 @@ class TestGameLauncher(unittest.TestCase):
         # and the GAMEID is 'umu-default'
         with patch.object(umu_run, "get_umu_proton", new_callable=mock_get_umu_proton):
             os.environ["WINEPREFIX"] = self.test_file
-            result = umu_run.check_env(self.env, self.test_session_pools)
-            self.assertTrue(result, self.env)
+            result_env, result_dl = umu_run.check_env(self.env)
+            self.assertTrue(result_env, self.env)
             self.assertEqual(os.environ["GAMEID"], mock_gameid)
             self.assertEqual(os.environ["GAMEID"], self.env["GAMEID"])
             self.assertEqual(os.environ["PROTONPATH"], mock_protonpath)
@@ -3928,7 +3944,7 @@ class TestGameLauncher(unittest.TestCase):
 
         Expects PROTONPATH, GAMEID, and WINEPREFIX to be set
         """
-        result = None
+        result_env, result_dl = None, None
         mock_gameid = "umu-default"
         mock_protonpath = str(self.test_proton_dir)
         mock_wineprefix = "/home/foo/Games/umu/umu-default"
@@ -3948,8 +3964,8 @@ class TestGameLauncher(unittest.TestCase):
             patch.object(umu_run, "get_umu_proton", new_callable=mock_get_umu_proton),
             patch.object(Path, "mkdir", return_value=mock_set_wineprefix()),
         ):
-            result = umu_run.check_env(self.env, self.test_session_pools)
-            self.assertTrue(result, self.env)
+            result_env, result_dl = umu_run.check_env(self.env)
+            self.assertTrue(result_env, self.env)
             self.assertEqual(os.environ["GAMEID"], mock_gameid)
             self.assertEqual(os.environ["GAMEID"], self.env["GAMEID"])
             self.assertEqual(os.environ["PROTONPATH"], mock_protonpath)
diff --git a/umu/umu_test_plugins.py b/umu/umu_test_plugins.py
index 7230139..d3463b6 100644
--- a/umu/umu_test_plugins.py
+++ b/umu/umu_test_plugins.py
@@ -64,11 +64,14 @@ class TestGameLauncherPlugins(unittest.TestCase):
         # /usr/share/umu
         self.test_user_share = Path("./tmp.jl3W4MtO57")
         # ~/.local/share/Steam/compatibilitytools.d
-        self.test_local_share = Path("./tmp.WUaQAk7hQJ")
         self.test_runtime_version = ("sniper", "steamrt3", "1628350")
+        self.test_local_share_parent = Path("./tmp.WUaQAk7hQJ")
+        self.test_local_share = self.test_local_share_parent.joinpath(
+            self.test_runtime_version[1]
+        )
 
         self.test_user_share.mkdir(exist_ok=True)
-        self.test_local_share.mkdir(exist_ok=True)
+        self.test_local_share.mkdir(parents=True, exist_ok=True)
         self.test_cache.mkdir(exist_ok=True)
         self.test_compat.mkdir(exist_ok=True)
         self.test_proton_dir.mkdir(exist_ok=True)
@@ -223,7 +226,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
 
         # Build
         with self.assertRaisesRegex(FileNotFoundError, "_v2-entry-point"):
-            umu_run.build_command(self.env, self.test_local_share, test_command)
+            umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1], test_command)
 
     def test_build_command_proton(self):
         """Test build_command.
@@ -301,7 +304,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
 
         # Build
         with self.assertRaisesRegex(FileNotFoundError, "proton"):
-            umu_run.build_command(self.env, self.test_local_share, test_command)
+            umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1], test_command)
 
     def test_build_command_toml(self):
         """Test build_command.
@@ -326,7 +329,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
         Path(toml_path).touch()
 
         # Mock the shim file
-        shim_path = Path(self.test_local_share, "umu-shim")
+        shim_path = Path(self.test_local_share_parent, "umu-shim")
         shim_path.touch()
 
         with Path(toml_path).open(mode="w", encoding="utf-8") as file:
@@ -381,7 +384,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
             os.environ[key] = val
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share)
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
 
         # Verify contents of the command
         entry_point, opt1, verb, opt2, shim, proton, verb2, exe = [*test_command]
@@ -619,23 +622,23 @@ class TestGameLauncherPlugins(unittest.TestCase):
             # prepare for building the command
             self.assertEqual(
                 self.env["EXE"],
-                unexpanded_exe,
-                "Expected path not to be expanded",
+                str(Path(unexpanded_exe).expanduser()),
+                "Expected path to be expanded",
             )
             self.assertEqual(
                 self.env["PROTONPATH"],
-                unexpanded_path,
-                "Expected path not to be expanded",
+                str(Path(unexpanded_path).expanduser()),
+                "Expected path to be expanded",
             )
             self.assertEqual(
                 self.env["WINEPREFIX"],
-                unexpanded_path,
-                "Expected path not to be expanded",
+                str(Path(unexpanded_path).expanduser()),
+                "Expected path to be expanded",
             )
             self.assertEqual(
                 self.env["GAMEID"],
                 unexpanded_path,
-                "Expectd path not to be expanded",
+                "Expected path to be expanded",
             )
 
     def test_set_env_toml_opts(self):
@@ -699,12 +702,12 @@ class TestGameLauncherPlugins(unittest.TestCase):
             self.assertTrue(self.env["EXE"], "Expected EXE to be set")
             self.assertEqual(
                 self.env["PROTONPATH"],
-                self.test_file,
+                str(Path(self.test_file).expanduser()),
                 "Expected PROTONPATH to be set",
             )
             self.assertEqual(
                 self.env["WINEPREFIX"],
-                self.test_file,
+                str(Path(self.test_file).expanduser()),
                 "Expected WINEPREFIX to be set",
             )
             self.assertEqual(
@@ -753,12 +756,12 @@ class TestGameLauncherPlugins(unittest.TestCase):
             self.assertTrue(self.env["EXE"], "Expected EXE to be set")
             self.assertEqual(
                 self.env["PROTONPATH"],
-                self.test_file,
+                str(Path(self.test_file).expanduser()),
                 "Expected PROTONPATH to be set",
             )
             self.assertEqual(
                 self.env["WINEPREFIX"],
-                self.test_file,
+                str(Path(self.test_file).expanduser()),
                 "Expected WINEPREFIX to be set",
             )
             self.assertEqual(
-- 
2.53.0


From 83113086b2ba8e00f57846d28d8f94c1c4a08fbb Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 20 Mar 2025 14:20:29 +0200
Subject: [PATCH 02/43] umu_run: only allow no runtime tools if
 `UMU_NO_RUNTIME=1` is set

---
 umu/umu_run.py | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index a8474f3..767d181 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -342,11 +342,6 @@ def build_command(
     if env.get("UMU_NO_PROTON") == "1":
         return *entry_point, env["EXE"], *opts
 
-    # Will run the game outside the Steam Runtime w/ Proton
-    if env.get("UMU_NO_RUNTIME") == "1":
-        log.warning("Runtime Platform disabled")
-        return proton, env["PROTON_VERB"], env["EXE"], *opts
-
     return (
         *entry_point,
         shim,
@@ -735,7 +730,10 @@ def get_umu_version_from_manifest(
                 break
 
     if not appid:
-        return "host", "host", "host"
+        if os.environ.get("UMU_NO_RUNTIME", None) == "1":
+            log.warning("Runtime Platform disabled")
+            return "host", "host", "host"
+        return None
 
     if appid not in set(filter(None, appids)):
         return None
-- 
2.53.0


From 442225e4bf53145532634ca47dbd07124f6af622 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 20 Mar 2025 14:21:35 +0200
Subject: [PATCH 03/43] umu_tests: add test to ensure the runtime is used even
 if `UMU_NO_RUNTIME=1` is set if the tool requires a runtime

---
 umu/umu_test.py | 200 ++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 160 insertions(+), 40 deletions(-)

diff --git a/umu/umu_test.py b/umu/umu_test.py
index a421228..0981621 100644
--- a/umu/umu_test.py
+++ b/umu/umu_test.py
@@ -99,10 +99,14 @@ class TestGameLauncher(unittest.TestCase):
         # /usr/share/umu
         self.test_user_share = Path("./tmp.BXk2NnvW2m")
         # ~/.local/share/Steam/compatibilitytools.d
-        self.test_runtime_version = ("sniper", "steamrt3", "1628350")
+        self.test_runtime_versions = (
+            ("sniper", "steamrt3", "1628350"),
+            ("soldier", "steamrt2", "1391110"),
+        )
+        self.test_runtime_default = self.test_runtime_versions[0]
         self.test_local_share_parent = Path("./tmp.aDl73CbQCP")
         self.test_local_share = self.test_local_share_parent.joinpath(
-            self.test_runtime_version[1]
+            self.test_runtime_default[1]
         )
         # Wine prefix
         self.test_winepfx = Path("./tmp.AlfLPDhDvA")
@@ -1380,7 +1384,7 @@ class TestGameLauncher(unittest.TestCase):
         # Mock a new install
         with TemporaryDirectory() as file:
             # Populate our fake $XDG_DATA_HOME/umu
-            mock_subdir = Path(file, self.test_runtime_version[1])
+            mock_subdir = Path(file, self.test_runtime_default[1])
             mock_subdir.mkdir()
             mock_subdir.joinpath("umu").touch()
             # Mock the runtime ver
@@ -1403,7 +1407,7 @@ class TestGameLauncher(unittest.TestCase):
         # Mock a new install
         with TemporaryDirectory() as file:
             # Populate our fake $XDG_DATA_HOME/umu
-            mock_subdir = Path(file, self.test_runtime_version[1])
+            mock_subdir = Path(file, self.test_runtime_default[1])
             mock_subdir.mkdir()
             mock_subdir.joinpath("umu").touch()
             # Mock the runtime ver
@@ -1424,7 +1428,7 @@ class TestGameLauncher(unittest.TestCase):
 
         # Mock a new install
         with TemporaryDirectory() as file:
-            mock_subdir = Path(file, self.test_runtime_version[1])
+            mock_subdir = Path(file, self.test_runtime_default[1])
             mock_subdir.mkdir()
             mock_subdir.joinpath("umu").touch()
             # Mock the runtime ver
@@ -1755,7 +1759,7 @@ class TestGameLauncher(unittest.TestCase):
         """
         self.test_user_share.joinpath("pressure-vessel", "bin", "pv-verify").unlink()
         result = umu_runtime.check_runtime(
-            self.test_user_share, self.test_runtime_version
+            self.test_user_share, self.test_runtime_default
         )
         self.assertEqual(result, 1, "Expected the exit code 1")
 
@@ -1764,7 +1768,7 @@ class TestGameLauncher(unittest.TestCase):
         mock = CompletedProcess(["foo"], 0)
         with patch.object(umu_runtime, "run", return_value=mock):
             result = umu_runtime.check_runtime(
-                self.test_user_share, self.test_runtime_version
+                self.test_user_share, self.test_runtime_default
             )
             self.assertEqual(result, 0, "Expected the exit code 0")
 
@@ -1782,7 +1786,7 @@ class TestGameLauncher(unittest.TestCase):
         mock = CompletedProcess(["foo"], 1)
         with patch.object(umu_runtime, "run", return_value=mock):
             result = umu_runtime.check_runtime(
-                self.test_user_share, self.test_runtime_version
+                self.test_user_share, self.test_runtime_default
             )
             self.assertEqual(result, 1, "Expected the exit code 1")
 
@@ -2217,7 +2221,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["PROTONPATH"] = self.test_file
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             args = __main__.parse_args()
             # Config
@@ -2281,7 +2285,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["PROTONPATH"] = self.test_file
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             args = __main__.parse_args()
             # Config
@@ -2379,7 +2383,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["PROTONPATH"] = self.test_file
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             args = __main__.parse_args()
             # Config
@@ -2460,7 +2464,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_PROTON"] = "1"
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result_args = __main__.parse_args()
             # Config
@@ -2481,7 +2485,7 @@ class TestGameLauncher(unittest.TestCase):
         ):
             umu_runtime.setup_umu(
                 self.test_local_share,
-                self.test_runtime_version,
+                self.test_runtime_default,
                 self.test_session_pools,
             )
             copytree(
@@ -2504,7 +2508,7 @@ class TestGameLauncher(unittest.TestCase):
             )
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_default[1])
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
@@ -2525,19 +2529,32 @@ class TestGameLauncher(unittest.TestCase):
         self.assertEqual(sep, "--", "Expected --")
         self.assertEqual(exe, self.env["EXE"], "Expected the EXE")
 
-    def test_build_command_nopv(self):
-        """Test build_command when disabling Pressure Vessel.
+    def test_build_command_nopv_appid(self):
+        """Test build_command when disabling Pressure Vessel but the tool requests a runtime.
 
-        UMU_NO_RUNTIME=1 disables Pressure Vessel, allowing
-        the launcher to run Proton on the host -- Flatpak environment.
+        UMU_NO_RUNTIME=1 disables Pressure Vessel, but the tool needs
+        a runtime, so use the correct runtime disregarding the env variable.
 
-        Expects the list to contain 3 string elements.
+        Expects the list to contain 8 string elements.
         """
         result_args = None
         test_command = []
 
         # Mock the proton file
         Path(self.test_file, "proton").touch()
+        # Mock a runtime toolmanifest.vdf
+        Path(self.test_file, "toolmanifest.vdf").write_text(
+            '''
+            "manifest"
+            {
+              "version" "2"
+              "commandline" "/proton %verb%"
+              "require_tool_appid" "1628350"
+              "use_sessions" "1"
+              "compatmanager_layer_name" "proton"
+            }
+            '''
+        )
 
         with (
             patch("sys.argv", ["", self.test_exe]),
@@ -2548,12 +2565,14 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_RUNTIME"] = "1"
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            version = umu_run.resolve_umu_version(self.test_runtime_versions)
+            os.environ["RUNTIMEPATH"] = version[1]
             # Args
             result_args = __main__.parse_args()
             # Config
-            result_env, result_dl = umu_run.check_env(self.env)
-            umu_run.download_proton(result_dl, result_env, thread_pool)
+            _, result_dl = umu_run.check_env(self.env)
+            if version[1] != "host":
+                umu_run.download_proton(result_dl, self.env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
             # Env
@@ -2567,7 +2586,7 @@ class TestGameLauncher(unittest.TestCase):
         ):
             umu_runtime.setup_umu(
                 self.test_local_share,
-                self.test_runtime_version,
+                self.test_runtime_default,
                 self.test_session_pools,
             )
             copytree(
@@ -2592,16 +2611,16 @@ class TestGameLauncher(unittest.TestCase):
         os.environ |= self.env
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, version[1])
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
         self.assertEqual(
             len(test_command),
-            3,
+            8,
             f"Expected 3 elements, received {len(test_command)}",
         )
-        proton, verb, exe, *_ = [*test_command]
+        _, _, verb, _, _, proton, _, exe = [*test_command]
         self.assertIsInstance(proton, os.PathLike, "Expected proton to be PathLike")
         self.assertEqual(
             proton,
@@ -2611,6 +2630,107 @@ class TestGameLauncher(unittest.TestCase):
         self.assertEqual(verb, "waitforexitandrun", "Expected PROTON_VERB")
         self.assertEqual(exe, self.env["EXE"], "Expected EXE")
 
+    def test_build_command_nopv_noappid(self):
+        """Test build_command when disabling Pressure Vessel and the tool doesn't request a runtime.
+
+        UMU_NO_RUNTIME=1 disables Pressure Vessel, and the tool doesn't set
+        a runtime, allow the tool to run using the host's libraries as it expects.
+
+        Expects the list to contain 4 string elements.
+        """
+        result_args = None
+        test_command = []
+
+        # Mock the proton file
+        Path(self.test_file, "proton").touch()
+        # Mock a non-runtime toolmanifest.vdf
+        Path(self.test_file, "toolmanifest.vdf").write_text(
+            '''
+            "manifest"
+            {
+              "version" "2"
+              "commandline" "/proton %verb%"
+              "use_sessions" "1"
+              "compatmanager_layer_name" "proton"
+            }
+            '''
+        )
+
+        with (
+            patch("sys.argv", ["", self.test_exe]),
+            ThreadPoolExecutor() as thread_pool,
+        ):
+            os.environ["WINEPREFIX"] = self.test_file
+            os.environ["PROTONPATH"] = self.test_file
+            os.environ["GAMEID"] = self.test_file
+            os.environ["STORE"] = self.test_file
+            os.environ["UMU_NO_RUNTIME"] = "1"
+            version = umu_run.resolve_umu_version(self.test_runtime_versions)
+            os.environ["RUNTIMEPATH"] = version[1]
+            # Args
+            result_args = __main__.parse_args()
+            # Config
+            _, result_dl = umu_run.check_env(self.env)
+            if version[1] != "host":
+                umu_run.download_proton(result_dl, self.env, thread_pool)
+            # Prefix
+            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            # Env
+            umu_run.set_env(self.env, result_args)
+            # Game drive
+            umu_run.enable_steam_game_drive(self.env)
+
+        # Mock setting up the runtime
+        with (
+            patch.object(umu_runtime, "_install_umu", return_value=None),
+        ):
+            umu_runtime.setup_umu(
+                self.test_local_share,
+                self.test_runtime_default,
+                self.test_session_pools,
+            )
+            copytree(
+                Path(self.test_user_share, "sniper_platform_0.20240125.75305"),
+                Path(self.test_local_share, "sniper_platform_0.20240125.75305"),
+                dirs_exist_ok=True,
+                symlinks=True,
+            )
+            copy(
+                Path(self.test_user_share, "run"),
+                Path(self.test_local_share, "run"),
+            )
+            copy(
+                Path(self.test_user_share, "run-in-sniper"),
+                Path(self.test_local_share, "run-in-sniper"),
+            )
+            copy(
+                Path(self.test_user_share, "umu"),
+                Path(self.test_local_share, "umu"),
+            )
+
+        os.environ |= self.env
+
+        # Build
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, version[1])
+        self.assertIsInstance(
+            test_command, tuple, "Expected a tuple from build_command"
+        )
+        self.assertEqual(
+            len(test_command),
+            4,
+            f"Expected 3 elements, received {len(test_command)}",
+        )
+        _, proton, verb, exe, *_ = [*test_command]
+        self.assertIsInstance(proton, os.PathLike, "Expected proton to be PathLike")
+        self.assertEqual(
+            proton,
+            Path(self.env["PROTONPATH"], "proton"),
+            "Expected PROTONPATH",
+        )
+        self.assertEqual(verb, "waitforexitandrun", "Expected PROTON_VERB")
+        self.assertEqual(exe, self.env["EXE"], "Expected EXE")
+
+
     def test_build_command_noproton(self):
         """Test build_command when $PROTONPATH/proton is not found.
 
@@ -2627,7 +2747,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_RUNTIME"] = "pressure-vessel"
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result_args = __main__.parse_args()
             # Config
@@ -2647,7 +2767,7 @@ class TestGameLauncher(unittest.TestCase):
 
         # Since we didn't create the proton file, an exception should be raised
         with self.assertRaises(FileNotFoundError):
-            umu_run.build_command(self.env, self.test_local_share, self.test_runtime_version[1])
+            umu_run.build_command(self.env, self.test_local_share, self.test_runtime_default[1])
 
     def test_build_command(self):
         """Test build command.
@@ -2676,7 +2796,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["PROTONPATH"] = self.test_file
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result_args = __main__.parse_args()
             # Config
@@ -2698,7 +2818,7 @@ class TestGameLauncher(unittest.TestCase):
         ):
             umu_runtime.setup_umu(
                 self.test_local_share,
-                self.test_runtime_version,
+                self.test_runtime_default,
                 self.test_session_pools,
             )
             copytree(
@@ -2721,7 +2841,7 @@ class TestGameLauncher(unittest.TestCase):
             )
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
+        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_default[1])
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
@@ -2769,7 +2889,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = test_str
             os.environ["STORE"] = test_str
             os.environ["PROTON_VERB"] = self.test_verb
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result = __main__.parse_args()
             # Check
@@ -2851,7 +2971,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = umu_id
             os.environ["STORE"] = test_str
             os.environ["PROTON_VERB"] = self.test_verb
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result = __main__.parse_args()
             # Check
@@ -2929,7 +3049,7 @@ class TestGameLauncher(unittest.TestCase):
                 self.env["PROTONPATH"]
                 + ":"
                 + Path.home()
-                .joinpath(".local", "share", "umu", self.test_runtime_version[1])
+                .joinpath(".local", "share", "umu", self.test_runtime_default[1])
                 .as_posix(),
                 "Expected STEAM_COMPAT_TOOL_PATHS to be set",
             )
@@ -2960,7 +3080,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = test_str
             os.environ["STORE"] = test_str
             os.environ["PROTON_VERB"] = self.test_verb
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result = __main__.parse_args()
             # Check
@@ -3046,7 +3166,7 @@ class TestGameLauncher(unittest.TestCase):
                 self.env["PROTONPATH"]
                 + ":"
                 + Path.home()
-                .joinpath(".local", "share", "umu", self.test_runtime_version[1])
+                .joinpath(".local", "share", "umu", self.test_runtime_default[1])
                 .as_posix(),
                 "Expected STEAM_COMPAT_TOOL_PATHS to be set",
             )
@@ -3077,7 +3197,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["STORE"] = test_str
             os.environ["PROTON_VERB"] = self.test_verb
             os.environ["UMU_RUNTIME_UPDATE"] = "0"
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result = __main__.parse_args()
             # Check
@@ -3168,7 +3288,7 @@ class TestGameLauncher(unittest.TestCase):
                 self.env["PROTONPATH"]
                 + ":"
                 + Path.home()
-                .joinpath(".local", "share", "umu", self.test_runtime_version[1])
+                .joinpath(".local", "share", "umu", self.test_runtime_default[1])
                 .as_posix(),
                 "Expected STEAM_COMPAT_TOOL_PATHS to be set",
             )
@@ -3208,7 +3328,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["PROTONPATH"] = test_dir.as_posix()
             os.environ["GAMEID"] = test_str
             os.environ["PROTON_VERB"] = proton_verb
-            os.environ["RUNTIMEPATH"] = self.test_runtime_version[1]
+            os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
             # Args
             result = __main__.parse_args()
             # Check
@@ -3298,7 +3418,7 @@ class TestGameLauncher(unittest.TestCase):
                 self.env["PROTONPATH"]
                 + ":"
                 + Path.home()
-                .joinpath(".local", "share", "umu", self.test_runtime_version[1])
+                .joinpath(".local", "share", "umu", self.test_runtime_default[1])
                 .as_posix(),
                 "Expected STEAM_COMPAT_TOOL_PATHS to be set",
             )
-- 
2.53.0


From b443d6a495495f835b5ae0f174e0e0e44d3a9224 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Fri, 21 Mar 2025 00:58:50 +0200
Subject: [PATCH 04/43] umu_run: do not set fault runtime path if case proton
 is using the host libraries

---
 umu/umu_run.py | 26 ++++++++++++++------------
 1 file changed, 14 insertions(+), 12 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 767d181..dc31829 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -232,14 +232,16 @@ def set_env(
     env["SteamGameId"] = env["SteamAppId"]
     env["UMU_INVOCATION_ID"] = token_hex(16)
 
+    runtime_path = f"{UMU_LOCAL}/{os.environ['RUNTIMEPATH']}" if os.environ['RUNTIMEPATH'] != "host" else ""
+
     # PATHS
     env["WINEPREFIX"] = str(pfx)
     env["PROTONPATH"] = str(protonpath)
     env["STEAM_COMPAT_DATA_PATH"] = env["WINEPREFIX"]
     env["STEAM_COMPAT_SHADER_PATH"] = f"{env['STEAM_COMPAT_DATA_PATH']}/shadercache"
-    env["STEAM_COMPAT_TOOL_PATHS"] = (
-        f"{env['PROTONPATH']}:{UMU_LOCAL}/{os.environ['RUNTIMEPATH']}"
-    )
+    env["STEAM_COMPAT_TOOL_PATHS"] = ":".join(
+        [f"{env['PROTONPATH']}", runtime_path]
+    ) if runtime_path else f"{env['PROTONPATH']}"
     env["STEAM_COMPAT_MOUNTS"] = env["STEAM_COMPAT_TOOL_PATHS"]
 
     # Zenity
@@ -258,7 +260,7 @@ def set_env(
     env["UMU_NO_RUNTIME"] = os.environ.get("UMU_NO_RUNTIME") or ""
     env["UMU_RUNTIME_UPDATE"] = os.environ.get("UMU_RUNTIME_UPDATE") or ""
     env["UMU_NO_PROTON"] = os.environ.get("UMU_NO_PROTON") or ""
-    env["RUNTIMEPATH"] = f"{UMU_LOCAL}/{os.environ['RUNTIMEPATH']}"
+    env["RUNTIMEPATH"] = runtime_path
 
     return env
 
@@ -780,7 +782,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
     }
     opts: list[str] = []
     prereq: bool = False
-    version: RuntimeVersion | None = None
+    runtime_version: RuntimeVersion | None = None
 
     log.info("umu-launcher version %s (%s)", __version__, sys.version)
 
@@ -828,13 +830,13 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         opts = args[1]  # Reference the executable options
 
     # Resolve the runtime version for PROTONPATH
-    version = resolve_umu_version(__runtime_versions__)
-    if not version:
+    runtime_version = resolve_umu_version(__runtime_versions__)
+    if not runtime_version:
         err: str = (
             f"Failed to match '{os.environ.get('PROTONPATH')}' with a container runtime"
         )
         raise ValueError(err)
-    os.environ["RUNTIMEPATH"] = version[1]
+    os.environ["RUNTIMEPATH"] = runtime_version[1]
 
     # Opt to use the system's native CA bundle rather than certifi's
     with suppress(ModuleNotFoundError):
@@ -878,11 +880,11 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         # Setup the launcher and runtime files
         _, do_download = check_env(env)
 
-        if version[1] != "host":
-            UMU_LOCAL.joinpath(version[1]).mkdir(parents=True, exist_ok=True)
+        if runtime_version[1] != "host":
+            UMU_LOCAL.joinpath(runtime_version[1]).mkdir(parents=True, exist_ok=True)
 
             future: Future = thread_pool.submit(
-                setup_umu, UMU_LOCAL / version[1], version, session_pools
+                setup_umu, UMU_LOCAL / runtime_version[1], runtime_version, session_pools
             )
 
             download_proton(do_download, env, session_pools)
@@ -924,7 +926,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         sys.exit(1)
 
     # Build the command
-    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL, version[1], opts)
+    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL, runtime_version[1], opts)
     log.debug("%s", command)
 
     # Run the command
-- 
2.53.0


From 244f5538374e0e303b099141e2ff5a07dd276035 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Fri, 21 Mar 2025 01:03:08 +0200
Subject: [PATCH 05/43] umu_run: make message clearer

---
 umu/umu_run.py | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index dc31829..d039978 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -733,7 +733,10 @@ def get_umu_version_from_manifest(
 
     if not appid:
         if os.environ.get("UMU_NO_RUNTIME", None) == "1":
-            log.warning("Runtime Platform disabled")
+            log.warning(
+                "Runtime Platform disabled. This mode is UNSUPPORTED by umu and remains only for convenience. "
+                "Issues created while using this mode will be automatically closed."
+            )
             return "host", "host", "host"
         return None
 
-- 
2.53.0


From 683cefd5e1b80c0906ed49fb5f29df9f4f5c0949 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Fri, 21 Mar 2025 20:05:49 +0200
Subject: [PATCH 06/43] doc: add documentation around UMU_NO_RUNTIME

---
 README.md      | 7 +++++++
 docs/umu.1.scd | 7 +++++++
 2 files changed, 14 insertions(+)

diff --git a/README.md b/README.md
index deeb4bb..b533713 100644
--- a/README.md
+++ b/README.md
@@ -84,6 +84,13 @@ Borderlands 3 from EGS store.
 3. In our umu unified database, we create a 'title' column, 'store' column, 'codename' column, 'umu-ID' column. We add a line for Borderlands 3 and fill in the details for each column.
 4. Now the launcher can search 'Catnip' and 'egs' as the codename and store in the database and correlate it with Borderlands 3 and umu-12345. It can then feed umu-12345 to the `umu-run` script.
 
+## Reporting issues
+
+When reporting issues for games that fail to run, be sure to attach a log with your issue report. To acquire a log from umu, add `UMU_LOG=1` to your environment variables for verbose logging. Furthermore, you can use `PROTON_LOG=1` for proton to create a verbose log in your `$HOME` directory. The log will be named `steam-<appid>.log`, where `<appid>` will be `default` if you haven't set a `GAMEID` or a number, depending on what you have set for `GAMEID`.
+
+Do **NOT** report issues when using `UMU_NO_RUNTIME=1`, this option is provided for convenience for compatibility tools that do not set their runtime requirements, such as Proton < `5.13`, and they do not work with any of the supported runtimes.
+This mode does not make use of a container runtime, and issues while using it are irrelevant to umu-launcher in general. Thus such issues will be automatically closed.
+
 ## Building
 
 Building umu-launcher currently requires `bash`, `make`, and `scdoc` for distribution, as well as the following Python build tools: [build](https://github.com/pypa/build), [hatchling](https://github.com/pypa/hatch), [installer](https://github.com/pypa/installer), and [pip](https://github.com/pypa/pip).
diff --git a/docs/umu.1.scd b/docs/umu.1.scd
index 8cd09ba..5ae232d 100644
--- a/docs/umu.1.scd
+++ b/docs/umu.1.scd
@@ -186,6 +186,13 @@ _UMU_HTTP_RETRIES_
 
 	Set _0_ to disable retries for HTTP requests. Set a positive integer to override the default.
 
+_UMU_NO_RUNTIME_
+	Optional. Allows for the configured compatibility tool to run outside of the Steam Linux Runtime.
+	This option is effective only if the compatibility tool doesn't require a runtime through its configuration.
+	On compatibility tools that require a runtime, this option is ignored.
+
+	Set _1_ to silence umu's error that it couldn't resolve a runtime to use, and run using the host's libraries.
+
 # SEE ALSO
 
 _umu_(5), _winetricks_(1)
-- 
2.53.0


From 6820152e37ef49f01e367de0819920bd1dda5d39 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Wed, 9 Apr 2025 11:22:33 +0300
Subject: [PATCH 07/43] umu_run: unpack runtime_version tuple instead of
 accessing by index

---
 umu/umu_run.py | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index d039978..e59a28f 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -839,7 +839,9 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
             f"Failed to match '{os.environ.get('PROTONPATH')}' with a container runtime"
         )
         raise ValueError(err)
-    os.environ["RUNTIMEPATH"] = runtime_version[1]
+    # runtime_name, runtime_variant, runtime_appid
+    _, runtime_variant, _ = runtime_version
+    os.environ["RUNTIMEPATH"] = runtime_variant
 
     # Opt to use the system's native CA bundle rather than certifi's
     with suppress(ModuleNotFoundError):
@@ -883,11 +885,11 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         # Setup the launcher and runtime files
         _, do_download = check_env(env)
 
-        if runtime_version[1] != "host":
-            UMU_LOCAL.joinpath(runtime_version[1]).mkdir(parents=True, exist_ok=True)
+        if runtime_variant != "host":
+            UMU_LOCAL.joinpath(runtime_variant).mkdir(parents=True, exist_ok=True)
 
             future: Future = thread_pool.submit(
-                setup_umu, UMU_LOCAL / runtime_version[1], runtime_version, session_pools
+                setup_umu, UMU_LOCAL / runtime_variant, runtime_version, session_pools
             )
 
             download_proton(do_download, env, session_pools)
@@ -929,7 +931,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         sys.exit(1)
 
     # Build the command
-    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL, runtime_version[1], opts)
+    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL, runtime_variant, opts)
     log.debug("%s", command)
 
     # Run the command
-- 
2.53.0


From 70cc061a6599bf91fb2143fe374c71a6c7e9401a Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 15 May 2025 14:34:43 +0300
Subject: [PATCH 08/43] project: add vdf requirement, submodule and vendor it

---
 .gitmodules                 |  3 +++
 Makefile.in                 |  9 +++++++++
 configure.sh                |  6 ++++++
 packaging/nix/unwrapped.nix | 27 +++++++++++++++++++++++++--
 pyproject.toml              |  2 +-
 requirements.in             |  1 +
 subprojects/vdf             |  1 +
 7 files changed, 46 insertions(+), 3 deletions(-)
 create mode 160000 subprojects/vdf

diff --git a/.gitmodules b/.gitmodules
index ed80a68..746dd8f 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -7,3 +7,6 @@
 [submodule "subprojects/python-xlib"]
 	path = subprojects/python-xlib
 	url = https://github.com/python-xlib/python-xlib.git
+[submodule "subprojects/vdf"]
+	path = subprojects/vdf
+	url = https://github.com/ValvePython/vdf.git
diff --git a/Makefile.in b/Makefile.in
index 1ad390f..65a4f63 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -23,6 +23,7 @@ FLATPAK ?= xfalse
 # Ex. Arch and Fedora have pyzstd but ubuntu and debian don't
 USE_SYSTEM_PYZSTD ?= xfalse
 USE_SYSTEM_URLLIB ?= xfalse
+USE_SYSTEM_VDF ?= xfalse
 
 INSTALLER_ARGS := -m installer $(OBJDIR)/umu_launcher*.whl
 ifdef DESTDIR
@@ -85,12 +86,16 @@ umu-install: umu-dist-install umu-delta-install umu-docs-install
 endif
 
 
+
 $(OBJDIR)/.build-umu-vendored: | $(OBJDIR)
 	$(info :: Building vendored dependencies )
 	@if [ "$(USE_SYSTEM_PYZSTD)" != "xtrue" ]; then \
 		sed -i 's/setuptools>=64,<74/setuptools/' subprojects/pyzstd/pyproject.toml; \
 		cd subprojects/pyzstd && $(PYTHON_INTERPRETER) -m build -wn -C=--build-option=--dynamic-link-zstd --outdir=$(OBJDIR); \
 	fi
+	@if [ "$(USE_SYSTEM_VDF)" != "xtrue" ]; then \
+		cd subprojects/vdf && $(PYTHON_INTERPRETER) -m build -wn --outdir=$(OBJDIR); \
+	fi
 	@if [ "$(USE_SYSTEM_URLLIB)" != "xtrue" ]; then \
 		cd subprojects/urllib3 && \
 		sed -i 's/license-files = \["LICENSE.txt"\]//g' pyproject.toml && \
@@ -108,6 +113,10 @@ umu-vendored-install: umu-vendored
 		$(PYTHON_INTERPRETER) -m installer --destdir=$(DESTDIR)$(PYTHONDIR)/umu/_vendor subprojects/pyzstd/$(OBJDIR)/pyzstd*.whl; \
 		find $(DESTDIR)$(PYTHONDIR)/umu/_vendor -type d -name pyzstd | xargs -I {} mv {} $(DESTDIR)$(PYTHONDIR)/umu/_vendor; \
 	fi
+	@if [ "$(USE_SYSTEM_VDF)" != "xtrue" ]; then \
+		$(PYTHON_INTERPRETER) -m installer --destdir=$(DESTDIR)$(PYTHONDIR)/umu/_vendor subprojects/vdf/$(OBJDIR)/vdf*.whl; \
+		find $(DESTDIR)$(PYTHONDIR)/umu/_vendor -type d -name vdf | xargs -I {} mv {} $(DESTDIR)$(PYTHONDIR)/umu/_vendor; \
+	fi
 	@if [ "$(USE_SYSTEM_URLLIB)" != "xtrue" ]; then \
 		$(PYTHON_INTERPRETER) -m installer --destdir=$(DESTDIR)$(PYTHONDIR)/umu/_vendor subprojects/urllib3/$(OBJDIR)/urllib3*.whl; \
 		find $(DESTDIR)$(PYTHONDIR)/umu/_vendor -type d -name urllib3 | xargs -I {} mv {} $(DESTDIR)$(PYTHONDIR)/umu/_vendor; \
diff --git a/configure.sh b/configure.sh
index 27d3efd..f5ecd93 100755
--- a/configure.sh
+++ b/configure.sh
@@ -75,6 +75,9 @@ function configure() {
     if [[ -n "$arg_use_system_urllib" ]]; then
       echo "USE_SYSTEM_URLLIB := xtrue"
     fi
+    if [[ -n "$arg_use_system_vdf" ]]; then
+      echo "USE_SYSTEM_VDF := xtrue"
+    fi
 
     # Prefix was specified, baking it into the Makefile
     if [[ -n $arg_prefix ]]; then
@@ -98,6 +101,7 @@ arg_user_install=""
 arg_help=""
 arg_use_system_pyzstd=""
 arg_use_system_urllib=""
+arg_use_system_vdf=""
 function parse_args() {
   local arg;
   local val;
@@ -147,6 +151,8 @@ function parse_args() {
       arg_use_system_pyzstd="1"
     elif [[ $arg = --use-system-urllib ]]; then
       arg_use_system_urllib="1"
+    elif [[ $arg = --use-system-vdf ]]; then
+      arg_use_system_vdf="1"
     else
       err "Unrecognized option $arg"
       return 1
diff --git a/packaging/nix/unwrapped.nix b/packaging/nix/unwrapped.nix
index e216d96..1d1ddfb 100644
--- a/packaging/nix/unwrapped.nix
+++ b/packaging/nix/unwrapped.nix
@@ -2,6 +2,7 @@
   # Dependencies
   lib,
   rustPlatform,
+  python3Packages,
   umu-launcher-unwrapped,
   version,
   # Freeform overrides
@@ -19,6 +20,7 @@ assert lib.assertMsg (lib.versionAtLeast umu-launcher-unwrapped.version "1.2.0")
   overrideArgs = builtins.removeAttrs args [
     "lib"
     "rustPlatform"
+    "python3Packages"
     "umu-launcher-unwrapped"
     "version"
   ];
@@ -30,13 +32,25 @@ assert lib.assertMsg (lib.versionAtLeast umu-launcher-unwrapped.version "1.2.0")
     then umu-launcher-unwrapped
     else umu-launcher-unwrapped.override overrideArgs;
 in
-  package.overridePythonAttrs {
+  package.overridePythonAttrs (old: {
     inherit version;
     src = ../../.;
     cargoDeps = rustPlatform.importCargoLock {
       lockFile = ../../Cargo.lock;
     };
 
+    pythonPath =
+      (old.pythonPath or [])
+      ++ [
+        python3Packages.vdf
+      ];
+
+    configureFlags =
+      (old.configureFlags or [])
+      ++ [
+        "--use-system-vdf"
+      ];
+
     # Specify ourselves which tests are disabled
     disabledTests = [
       # Broken? Asserts that $STEAM_RUNTIME_LIBRARY_PATH is non-empty
@@ -47,5 +61,14 @@ in
       # Broken? Tests parse_args with no options (./umu_run.py)
       # Fails with AssertionError: SystemExit not raised
       "test_parse_args_noopts"
+
+      # FileNotFoundError: [Errno 2] No such file or directory: .local/share/umu/toolmanifest.vdf
+      "test_build_command"
+      "test_build_command_linux_exe"
+      "test_build_command_nopv"
+
+      # TypeError: cannot unpack non-iterable ThreadPoolExecutor object
+      "test_env_nowine_noproton"
+      "test_env_wine_noproton"
     ];
-  }
+  })
diff --git a/pyproject.toml b/pyproject.toml
index 37acf27..fc1d2ef 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -35,7 +35,7 @@ classifiers = [
 urls = { repository = "https://github.com/Open-Wine-Components/umu-launcher" }
 # Note: urllib3 is a vendored dependency. When using our Makefile, it will be
 # installed automatically.
-dependencies = ["python-xlib>=0.33", "urllib3>=2.0.0"]
+dependencies = ["python-xlib>=0.33", "urllib3>=2.0.0", "vdf>=3.4"]
 
 [project.optional-dependencies]
 # Recommended
diff --git a/requirements.in b/requirements.in
index 32fe129..c9449f0 100644
--- a/requirements.in
+++ b/requirements.in
@@ -1,5 +1,6 @@
 python-xlib>=0.33
 urllib3>=2.0.0,<3.0.0
+vdf>=3.4
 xxhash>=3.2.0
 pyzstd>=0.16.2
 cbor2>=5.4.6
diff --git a/subprojects/vdf b/subprojects/vdf
new file mode 160000
index 0000000..d762926
--- /dev/null
+++ b/subprojects/vdf
@@ -0,0 +1 @@
+Subproject commit d76292623e326fb165fe3bdb684832cdf30959d4
-- 
2.53.0


From 088f4c9e82b4f082b54f979e99302b74e1430afa Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 15 May 2025 16:42:07 +0300
Subject: [PATCH 09/43] umu_runtime: implement Steam compatibility layer class

---
 umu/umu_runtime.py | 115 ++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 114 insertions(+), 1 deletion(-)

diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 5f6df5b..4d68f43 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -1,6 +1,8 @@
 import os
+import shlex
 from collections.abc import Callable
 from concurrent.futures import ThreadPoolExecutor
+from dataclasses import dataclass
 from hashlib import sha256
 from http import HTTPStatus
 from pathlib import Path
@@ -9,11 +11,12 @@ from shutil import move
 from subprocess import run
 from tempfile import TemporaryDirectory, mkdtemp
 
+import vdf
 from urllib3.exceptions import HTTPError
 from urllib3.poolmanager import PoolManager
 from urllib3.response import BaseHTTPResponse
 
-from umu.umu_consts import UMU_CACHE, FileLock, HTTPMethod
+from umu.umu_consts import UMU_CACHE, UMU_LOCAL, FileLock, HTTPMethod
 from umu.umu_log import log
 from umu.umu_util import (
     exchange,
@@ -419,3 +422,113 @@ def _update_umu_platform(
         log.info("Updating %s to latest...", variant)
         _install_umu(runtime_ver, session_pools, local)
         log.debug("Released file lock '%s'", lock)
+
+
+@dataclass
+class UmuRuntime:
+    """Holds information about a runtime."""
+
+    name: str
+    variant: str
+    path: Path | None = None
+
+    def __post_init__(self) -> None:  # noqa: D105
+        if not self.variant:
+            return
+        if self.path is None:
+            self.path = UMU_LOCAL.joinpath(self.variant)
+
+    def __bool__(self) -> bool:
+        """Return if the runtime's path has been populated."""
+        return self.path.is_dir() and self.path.joinpath("mtree.txt.gz").is_file()
+
+RUNTIME_VERSIONS = {
+    "host":    UmuRuntime("host",    ""        ),
+    "1070560": UmuRuntime("scout",   "steamrt1"),
+    "1391110": UmuRuntime("soldier", "steamrt2"),
+    "1628350": UmuRuntime("sniper",  "steamrt3"),
+    # ""       : UmuRuntime("medic",   "steamrt4"),
+}
+
+
+RUNTIME_NAMES = {RUNTIME_VERSIONS[key].name: key for key in RUNTIME_VERSIONS}
+
+
+class CompatLayer:
+    """Class to describe a Steam compatibility layer."""
+
+    def __init__(self, path: str, shim: Path) -> None:  # noqa: D107
+        self.tool_path = path
+        with Path(path).joinpath("toolmanifest.vdf").open(encoding="utf-8") as f:
+            self.tool_manifest = vdf.load(f)["manifest"]
+
+        self.runtime: CompatLayer = (
+            CompatLayer(str(self.required_runtime.path), shim)
+            if self.required_tool_appid is not None
+            else None
+        )
+        _path = Path(path)
+        if _path.joinpath("compatibilitytool.vdf").exists():
+            with _path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
+                # There can be multiple tools definitions in `compatibilitytools.vdf`
+                # Take the first one and hope it is the one with the correct display_name
+                compat_tools = tuple(vdf.load(f)["compatibilitytools"]["compat_tools"].values())
+                self.compatibility_tool = compat_tools[0]
+        else:
+            self.compatibility_tool = {"display_name": _path.name}
+
+        self.shim = shim
+
+    @property
+    def required_tool_appid(self) -> str | None:  # noqa: D102
+        return str(ret) if (ret := self.tool_manifest.get("require_tool_appid")) else None
+
+    @property
+    def required_runtime(self) -> UmuRuntime:
+        """Map the required tool's appid to a runtime known by umu."""
+        if self.required_tool_appid is None:
+            return RUNTIME_VERSIONS["host"]
+        return RUNTIME_VERSIONS[self.required_tool_appid]
+
+    @property
+    def layer_name(self) -> str | None:  # noqa: D102
+        return str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else None
+
+    @property
+    def display_name(self) -> str | None:  # noqa: D102
+        return str(ret) if (ret := self.compatibility_tool.get("display_name")) else None
+
+    @property
+    def has_runtime(self) -> bool:
+        """Report if the compatibility tool has a configured runtime."""
+        return self.runtime is not None
+
+    def _command(self, verb: str) -> list[str]:
+        """Return the tool specific entry point."""
+        tool_path = os.path.normpath(self.tool_path)
+        cmd = "".join([shlex.quote(tool_path), self.tool_manifest["commandline"]])
+        # # Temporary override for backwards compatibility
+        # if self.tool_path == str(UMU_LOCAL):
+        #     cmd = cmd.replace("_v2-entry-point", "umu")
+        cmd = cmd.replace("%verb%", verb)
+        cmd = shlex.split(cmd)
+        return cmd
+
+    def command(self, verb: str) -> list[str]:
+        """Return the fully qualified command for the runtime.
+
+        If the runtime uses another runtime, its entry point is prepended to the local command.
+        """
+        log.info("Running '%s' using runtime '%s'", self.display_name, self.required_runtime.name)
+        cmd = self.runtime.command(verb) if self.runtime is not None else []
+        target = self._command(verb)
+        if self.layer_name in {"container-runtime"}:
+            cmd.extend([*target, self.shim.as_posix()])
+        elif self.runtime is None:
+            cmd.extend([self.shim.as_posix(), *target])
+        else:
+            cmd.extend(target)
+        return cmd
+
+    def as_str(self, verb: str):  # noqa: D102
+        return " ".join(map(shlex.quote, self.command(verb)))
-- 
2.53.0


From ce02305cb341ce4a4c234bc0f3cfea4a54608c04 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 15 May 2025 22:18:41 +0300
Subject: [PATCH 10/43] umu_run: use CompatLayer to construct umu's entry point

override the entry point for now to use `umu` for runtimes.
---
 umu/umu_run.py     | 68 +++++++++++++++++++++-------------------------
 umu/umu_runtime.py | 14 ++++++----
 umu/umu_test.py    |  4 +--
 3 files changed, 41 insertions(+), 45 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index e59a28f..a3999e2 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -39,7 +39,7 @@ from umu.umu_consts import (
 from umu.umu_log import log
 from umu.umu_plugins import set_env_toml
 from umu.umu_proton import get_umu_proton
-from umu.umu_runtime import create_shim, setup_umu
+from umu.umu_runtime import CompatLayer, create_shim, setup_umu
 from umu.umu_util import (
     get_libc,
     get_library_paths,
@@ -298,57 +298,46 @@ def enable_steam_game_drive(env: dict[str, str]) -> dict[str, str]:
 
 def build_command(
     env: dict[str, str],
-    local: Path,
-    version: str,
+    layer: CompatLayer,
     opts: list[str] | None = None,
 ) -> tuple[Path | str, ...]:
     """Build the command to be executed."""
-    shim: Path = local.joinpath("umu-shim")
-    proton: Path = Path(env["PROTONPATH"], "proton")
-    entry_point: tuple[Path, str, str, str] | tuple[()] = (
-        local.joinpath(version, "umu"), "--verb", env["PROTON_VERB"], "--"
-    ) if version != "host" else ()
     if opts is None:
         opts = []
 
-    if env.get("UMU_NO_PROTON") != "1" and not proton.is_file():
-        err: str = "The following file was not found in PROTONPATH: proton"
-        raise FileNotFoundError(err)
-
-    # Exit if the entry point is missing
-    # The _v2-entry-point script and container framework tools are included in
-    # the same image, so this can happen if the image failed to download
-    if entry_point and not entry_point[0].is_file():
-        err: str = (
-            f"_v2-entry-point (umu) cannot be found in '{local}'\n"
-            "Runtime Platform missing or download incomplete"
-        )
-        raise FileNotFoundError(err)
+    # if env.get("UMU_NO_PROTON") != "1" and not proton.is_file():
+    #     err: str = "The following file was not found in PROTONPATH: proton"
+    #     raise FileNotFoundError(err)
+    #
+    # # Exit if the entry point is missing
+    # # The _v2-entry-point script and container framework tools are included in
+    # # the same image, so this can happen if the image failed to download
+    # if entry_point and not entry_point[0].is_file():
+    #     err: str = (
+    #         f"_v2-entry-point (umu) cannot be found in '{local}'\n"
+    #         "Runtime Platform missing or download incomplete"
+    #     )
+    #     raise FileNotFoundError(err)
 
     # Winetricks
     if env.get("EXE", "").endswith("winetricks") and opts:
         # The position of arguments matter for winetricks
         # Usage: ./winetricks [options] [command|verb|path-to-verb] ...
         return (
-            *entry_point,
-            proton,
-            env["PROTON_VERB"],
+            *layer.command(env["PROTON_VERB"]),
             env["EXE"],
             "-q",
             *opts,
         )
 
-    # Will run the game within the Steam Runtime w/o Proton
-    # Ideally, for reliability, executables should be compiled within
-    # the Steam Runtime
-    if env.get("UMU_NO_PROTON") == "1":
-        return *entry_point, env["EXE"], *opts
+    # # Will run the game within the Steam Runtime w/o Proton
+    # # Ideally, for reliability, executables should be compiled within
+    # # the Steam Runtime
+    # if env.get("UMU_NO_PROTON") == "1":
+    #     return *entry_point, env["EXE"], *opts
 
     return (
-        *entry_point,
-        shim,
-        proton,
-        env["PROTON_VERB"],
+        *layer.command(env["PROTON_VERB"]),
         env["EXE"],
         *opts,
     )
@@ -674,7 +663,7 @@ def run_command(command: tuple[Path | str, ...]) -> int:
     return ret
 
 
-def resolve_umu_version(runtimes: tuple[RuntimeVersion, ...]) -> RuntimeVersion | None:
+def resolve_runtime(runtimes: tuple[RuntimeVersion, ...]) -> RuntimeVersion | None:
     """Resolve the required runtime of a compatibility tool."""
     version: tuple[str, str, str] | None = None
 
@@ -705,7 +694,7 @@ def resolve_umu_version(runtimes: tuple[RuntimeVersion, ...]) -> RuntimeVersion
     if os.environ.get("PROTONPATH") and path.is_dir():
         os.environ["PROTONPATH"] = str(STEAM_COMPAT.joinpath(os.environ["PROTONPATH"]))
 
-    path = Path(os.environ["PROTONPATH"], "toolmanifest.vdf").resolve()
+    path = Path(os.environ["PROTONPATH"], "toolmanifest.vdf").expanduser().resolve()
     if path.is_file():
         version = get_umu_version_from_manifest(path, runtimes)
     else:
@@ -833,7 +822,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         opts = args[1]  # Reference the executable options
 
     # Resolve the runtime version for PROTONPATH
-    runtime_version = resolve_umu_version(__runtime_versions__)
+    runtime_version = resolve_runtime(__runtime_versions__)
     if not runtime_version:
         err: str = (
             f"Failed to match '{os.environ.get('PROTONPATH')}' with a container runtime"
@@ -930,8 +919,13 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
     ):
         sys.exit(1)
 
+    layer = CompatLayer(
+        env["RUNTIMEPATH"] if env.get("UMU_NO_PROTON", False) else env["PROTONPATH"],
+        UMU_LOCAL.joinpath("umu-shim")
+    )
+
     # Build the command
-    command: tuple[Path | str, ...] = build_command(env, UMU_LOCAL, runtime_variant, opts)
+    command: tuple[Path | str, ...] = build_command(env, layer, opts)
     log.debug("%s", command)
 
     # Run the command
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 4d68f43..a99c252 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -442,6 +442,7 @@ class UmuRuntime:
         """Return if the runtime's path has been populated."""
         return self.path.is_dir() and self.path.joinpath("mtree.txt.gz").is_file()
 
+
 RUNTIME_VERSIONS = {
     "host":    UmuRuntime("host",    ""        ),
     "1070560": UmuRuntime("scout",   "steamrt1"),
@@ -467,6 +468,7 @@ class CompatLayer:
             if self.required_tool_appid is not None
             else None
         )
+
         _path = Path(path)
         if _path.joinpath("compatibilitytool.vdf").exists():
             with _path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
@@ -507,19 +509,18 @@ class CompatLayer:
         """Return the tool specific entry point."""
         tool_path = os.path.normpath(self.tool_path)
         cmd = "".join([shlex.quote(tool_path), self.tool_manifest["commandline"]])
-        # # Temporary override for backwards compatibility
-        # if self.tool_path == str(UMU_LOCAL):
-        #     cmd = cmd.replace("_v2-entry-point", "umu")
+        # Temporary override entry point for backwards compatibility
+        if self.layer_name in {"container-runtime"}:
+            cmd = cmd.replace("_v2-entry-point", "umu")
         cmd = cmd.replace("%verb%", verb)
-        cmd = shlex.split(cmd)
-        return cmd
+        return shlex.split(cmd)
 
     def command(self, verb: str) -> list[str]:
         """Return the fully qualified command for the runtime.
 
         If the runtime uses another runtime, its entry point is prepended to the local command.
         """
-        log.info("Running '%s' using runtime '%s'", self.display_name, self.required_runtime.name)
+        log.info("Running '%s' using runtime on '%s'", self.display_name, self.required_runtime.name)
         cmd = self.runtime.command(verb) if self.runtime is not None else []
         target = self._command(verb)
         if self.layer_name in {"container-runtime"}:
@@ -532,3 +533,4 @@ class CompatLayer:
 
     def as_str(self, verb: str):  # noqa: D102
         return " ".join(map(shlex.quote, self.command(verb)))
+
diff --git a/umu/umu_test.py b/umu/umu_test.py
index 0981621..bf654c6 100644
--- a/umu/umu_test.py
+++ b/umu/umu_test.py
@@ -2565,7 +2565,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_RUNTIME"] = "1"
-            version = umu_run.resolve_umu_version(self.test_runtime_versions)
+            version = umu_run.resolve_runtime(self.test_runtime_versions)
             os.environ["RUNTIMEPATH"] = version[1]
             # Args
             result_args = __main__.parse_args()
@@ -2665,7 +2665,7 @@ class TestGameLauncher(unittest.TestCase):
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_RUNTIME"] = "1"
-            version = umu_run.resolve_umu_version(self.test_runtime_versions)
+            version = umu_run.resolve_runtime(self.test_runtime_versions)
             os.environ["RUNTIMEPATH"] = version[1]
             # Args
             result_args = __main__.parse_args()
-- 
2.53.0


From 57c6167e940a5bfa241abae11b2310b99ebec305 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Thu, 29 May 2025 11:25:55 +0300
Subject: [PATCH 11/43] umu: add `umu-scout` tool download and introduce
 `umu-soldier` and `umu-sniper` passthrough tools

`umu-soldier` and `umu-sniper` as simple passthrough tools that use
the respective runtimes to run linux-native executables.

This removes the need for confusing variables such as `RUNTIMEPATH` and `UMU_NO_PROTON`

This is still heavy WIP, needs cleanup and tests. Will be squashed with future commits.
---
 umu/umu_proton.py  |  99 +++++++++++++++++++----
 umu/umu_run.py     | 192 ++++++++++++++++++++-------------------------
 umu/umu_runtime.py |  37 +++++----
 umu/umu_test.py    |   4 +-
 4 files changed, 191 insertions(+), 141 deletions(-)

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index 6ae3957..0982ef5 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -1,4 +1,5 @@
 import os
+import shutil
 import time
 from concurrent.futures import ALL_COMPLETED, FIRST_EXCEPTION, ThreadPoolExecutor
 from concurrent.futures import wait as futures_wait
@@ -13,6 +14,7 @@ from shutil import move
 from tempfile import TemporaryDirectory, mkdtemp
 from typing import Any
 
+import vdf
 from urllib3.exceptions import HTTPError
 from urllib3.poolmanager import PoolManager
 from urllib3.response import BaseHTTPResponse
@@ -27,6 +29,7 @@ from umu.umu_consts import (
     HTTPMethod,
 )
 from umu.umu_log import log
+from umu.umu_runtime import RUNTIME_NAMES, RUNTIME_VERSIONS
 from umu.umu_util import (
     extract_tarfile,
     file_digest,
@@ -50,6 +53,9 @@ class ProtonVersion(Enum):
     UMU = "UMU-Proton"
     GELatest = "GE-Latest"
     UMULatest = "UMU-Latest"
+    UMUScout = "umu-scout"
+    UMUSoldier = "umu-soldier"
+    UMUSniper = "umu-sniper"
 
 
 def get_umu_proton(env: dict[str, str], session_pools: SessionPools) -> dict[str, str]:
@@ -84,6 +90,8 @@ def get_umu_proton(env: dict[str, str], session_pools: SessionPools) -> dict[str
     with TemporaryDirectory(dir=UMU_CACHE) as tmpcache:
         tmpdirs: SessionCaches = (get_tempdir(), Path(tmpcache))
         compatdirs = (UMU_COMPAT, STEAM_COMPAT)
+        if _get_umu_runtime_tool(env, os.environ.get("PROTONPATH", "")) is env:
+            return env
         if _get_delta(env, UMU_COMPAT, patch, assets, session_pools) is env:
             return env
         if _get_latest(env, compatdirs, tmpdirs, assets, session_pools) is env:
@@ -96,6 +104,64 @@ def get_umu_proton(env: dict[str, str], session_pools: SessionPools) -> dict[str
     return env
 
 
+def _get_umu_runtime_tool(env: dict[str, str], name: str) -> dict[str, str] | None:
+    """Create  a 'passthrough' compatibility tool for native linux applications.
+
+    When 'PROTONPATH' is 'umu-soldier' or 'umu-sniper', create a shim compatibility
+    tool that requires the respective runtime and launches the application in that runtime.
+    """
+    if not (name and name in {ProtonVersion.UMUSoldier.value, ProtonVersion.UMUSniper.value}):
+        return None
+
+    rt_appid = RUNTIME_VERSIONS[RUNTIME_NAMES[name.removeprefix("umu-")]].appid
+    tool_path: Path = UMU_COMPAT.joinpath(name)
+    entry_point_file: Path = tool_path.joinpath("entry-point")
+    compatibilitytool_file: Path = tool_path.joinpath("compatibilitytool.vdf")
+    toolmanifest_file: Path = tool_path.joinpath("toolmanifest.vdf")
+    files = (entry_point_file, compatibilitytool_file, toolmanifest_file)
+
+    if tool_path.is_dir():
+        if all(f.is_file() for f in files):
+            os.environ["PROTONPATH"] = str(tool_path)
+            env["PROTONPATH"] = os.environ["PROTONPATH"]
+            return env
+        shutil.rmtree(tool_path)
+
+    entry_point = "#!/bin/sh\nexec \"$@\"\n"
+    compatibilitytool = {
+        "compatibilitytools": {
+            "compat_tools": {
+                name: {"display_name": name, "install_path": ".", "from_oslist": "linux", "to_oslist": "linux",}
+            }
+        }
+    }
+    toolmanifest = {
+        "manifest": {
+            "version": "2",
+            "commandline": "/entry-point",
+            "require_tool_appid": rt_appid,
+            "use_sessions": "1",
+            "compatmanager_layer_name": "umu-passthrough",
+        }
+    }
+
+    if not tool_path.is_dir():
+        tool_path.mkdir(parents=True, exist_ok=True)
+
+    with entry_point_file.open("w") as fd:
+        fd.write(entry_point)
+    entry_point_file.chmod(0o700)
+
+    with compatibilitytool_file.open("w") as fd:
+        vdf.dump(compatibilitytool, fd, pretty=True)
+
+    with toolmanifest_file.open("w") as fd:
+        vdf.dump(toolmanifest, fd, pretty=True)
+
+    os.environ["PROTONPATH"] = str(tool_path)
+    env["PROTONPATH"] = str(tool_path)
+    return env
+
 def _fetch_patch(session_pools: SessionPools) -> bytes:
     resp: BaseHTTPResponse
     _, http_pool = session_pools
@@ -164,6 +230,9 @@ def _fetch_releases(
     }:
         repo = "/repos/GloriousEggroll/proton-ge-custom/releases/latest"
 
+    if os.environ.get("PROTONPATH") in {ProtonVersion.UMUScout.value}:
+        repo = "/repos/loathingKernel/umu-scout/releases/latest"
+
     resp = http_pool.request(HTTPMethod.GET.value, f"{url}{repo}", headers=headers)
     if resp.status != HTTPStatus.OK:
         return ()
@@ -177,8 +246,8 @@ def _fetch_releases(
             digest_asset = (release["name"], release["browser_download_url"])
             asset_count += 1
             continue
-        if release["name"].endswith("tar.gz") and release["name"].startswith(
-            ("UMU-Proton", "GE-Proton")
+        if release["name"].endswith(("tar.gz", "tar.xz")) and release["name"].startswith(
+            ("UMU-Proton", "GE-Proton", "umu-scout")
         ):
             proton_asset = (release["name"], release["browser_download_url"])
             asset_count += 1
@@ -206,7 +275,8 @@ def _fetch_proton(
     _, http_pool = session_pools
     proton_hash, proton_hash_url = assets[0]
     tarball, tar_url = assets[1]
-    proton: str = tarball.removesuffix(".tar.gz")
+    # remove any combination of .abc.xy suffix (realistically .tar.gz|xz)
+    proton = ".".join(tarball.split(".")[:-2])
     ret: int = 0  # Exit code from zenity
     digest: str = ""  # Digest of the Proton archive
     hashsum = sha512()
@@ -384,10 +454,12 @@ def _get_latest(
         return None
 
     tarball = assets[1][0]
-    proton = tarball.removesuffix(".tar.gz")
+    # remove any combination of .abc.xy suffix (realistically .tar.gz|xz)
+    proton = ".".join(tarball.split(".")[:-2])
     latest_candidates = {
         ProtonVersion.GELatest.value,
         ProtonVersion.UMULatest.value,
+        ProtonVersion.UMUScout.value
     }
 
     if os.environ.get("PROTONPATH") in {member.value for member in ProtonVersion}:
@@ -453,6 +525,7 @@ def _install_proton(
     latest_candidates: set[str] = {
         ProtonVersion.GELatest.value,
         ProtonVersion.UMULatest.value,
+        ProtonVersion.UMUScout.value,
     }
 
     # Move our file and extract within our cache
@@ -475,19 +548,15 @@ def _install_proton(
 
     # Move decompressed archive to compatibilitytools.d or
     # $XDG_DATA_HOME/umu/compatibilitytools
+    # remove any combination of .abc.xy suffix (realistically .tar.gz|xz)
+    name = ".".join(tarball.split(".")[:-2])
+    folder = cache.joinpath(name)
     if os.environ.get("PROTONPATH") in latest_candidates:
-        log.info(
-            "%s -> %s", cache.joinpath(tarball.removesuffix(".tar.gz")), umu_compat
-        )
-        move(
-            cache.joinpath(tarball.removesuffix(".tar.gz")),
-            umu_compat / os.environ["PROTONPATH"],
-        )
+        log.info("%s -> %s", folder, umu_compat)
+        move(folder, umu_compat / os.environ["PROTONPATH"])
     else:
-        log.info(
-            "%s -> %s", cache.joinpath(tarball.removesuffix(".tar.gz")), steam_compat
-        )
-        move(cache.joinpath(tarball.removesuffix(".tar.gz")), steam_compat)
+        log.info("%s -> %s", folder, steam_compat)
+        move(folder, steam_compat)
 
 
 def _get_delta(
diff --git a/umu/umu_run.py b/umu/umu_run.py
index a3999e2..7a3bd58 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -1,5 +1,4 @@
 import os
-import re
 import sys
 import threading
 from _ctypes import CFuncPtr
@@ -10,7 +9,6 @@ from concurrent.futures import Future, ThreadPoolExecutor
 from contextlib import suppress
 from ctypes import CDLL, c_int, c_ulong
 from errno import ENETUNREACH
-from itertools import chain
 from pathlib import Path
 from pwd import getpwuid
 from re import match
@@ -27,7 +25,7 @@ from Xlib.error import DisplayConnectionError
 from Xlib.protocol.request import GetProperty
 from Xlib.xobject.drawable import Window
 
-from umu import __runtime_versions__, __version__
+from umu import __version__
 from umu.umu_consts import (
     PR_SET_CHILD_SUBREAPER,
     PROTON_VERBS,
@@ -39,7 +37,13 @@ from umu.umu_consts import (
 from umu.umu_log import log
 from umu.umu_plugins import set_env_toml
 from umu.umu_proton import get_umu_proton
-from umu.umu_runtime import CompatLayer, create_shim, setup_umu
+from umu.umu_runtime import (
+    RUNTIME_NAMES,
+    RUNTIME_VERSIONS,
+    CompatLayer,
+    create_shim,
+    setup_umu,
+)
 from umu.umu_util import (
     get_libc,
     get_library_paths,
@@ -56,35 +60,38 @@ NET_RETRIES = 3
 RuntimeVersion = tuple[str, str, str]
 
 
-def setup_pfx(path: str) -> None:
+def setup_pfx(path: Path) -> None:
     """Prepare a Proton compatible WINE prefix."""
-    pfx: Path = Path(path).joinpath("pfx").expanduser()
-    steam: Path = Path(path).expanduser().joinpath("drive_c", "users", "steamuser")
+    if not path.is_dir():
+        path.mkdir(parents=True, exist_ok=True)
+
+    pfx: Path = path.joinpath("pfx")
+    steamuser: Path = path.joinpath("drive_c", "users", "steamuser")
     # Login name of the user as determined by the password database (pwd)
-    user: str = getpwuid(os.getuid()).pw_name
-    wineuser: Path = Path(path).expanduser().joinpath("drive_c", "users", user)
+    unixuser: str = getpwuid(os.getuid()).pw_name
+    wineuser: Path = path.joinpath("drive_c", "users", unixuser)
 
-    if os.environ.get("UMU_NO_PROTON") == "1":
-        return
+    path.joinpath("shadercache").mkdir(parents=True, exist_ok=True)
+    path.joinpath("gstreamer-1.0").mkdir(parents=True, exist_ok=True)
 
     if pfx.is_symlink():
         pfx.unlink()
 
     if not pfx.is_dir():
-        pfx.symlink_to(Path(path).expanduser().resolve(strict=True))
+        pfx.symlink_to(path.resolve(strict=True))
 
-    Path(path).joinpath("tracked_files").expanduser().touch()
+    path.joinpath("tracked_files").touch()
 
     # Create a symlink of the current user to the steamuser dir or vice versa
     # Default for a new prefix is: unixuser -> steamuser
-    if not wineuser.exists() and not steam.exists():
+    if not wineuser.exists() and not steamuser.exists():
         # For new prefixes with our Proton: user -> steamuser
-        steam.mkdir(parents=True)
+        steamuser.mkdir(parents=True)
         wineuser.symlink_to("steamuser")
-    elif wineuser.is_dir() and not steam.exists():
+    elif wineuser.is_dir() and not steamuser.exists():
         # When there's a user dir: steamuser -> user
-        steam.symlink_to(user)
-    elif not wineuser.exists() and steam.is_dir():
+        steamuser.symlink_to(unixuser)
+    elif not wineuser.exists() and steamuser.is_dir():
         wineuser.symlink_to("steamuser")
 
 
@@ -105,20 +112,17 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
         err: str = "Environment variable is empty: WINEPREFIX"
         raise ValueError(err)
 
-    if os.environ.get("UMU_NO_PROTON") != "1" and "WINEPREFIX" not in os.environ:
+    if "WINEPREFIX" not in os.environ:
         pfx: Path = Path.home().joinpath("Games", "umu", env["GAMEID"])
-        pfx.mkdir(parents=True, exist_ok=True)
-        os.environ["WINEPREFIX"] = str(pfx)
+    else:
+        pfx: Path = Path(os.environ["WINEPREFIX"]).expanduser()
 
-    if (
-        os.environ.get("UMU_NO_PROTON") != "1"
-        and not Path(os.environ["WINEPREFIX"]).expanduser().is_dir()
-    ):
-        pfx: Path = Path(os.environ["WINEPREFIX"])
-        pfx.mkdir(parents=True, exist_ok=True)
-        os.environ["WINEPREFIX"] = str(pfx)
+    if not pfx.is_absolute():
+        err: str = "WINEPREFIX is set but not an absolute path."
+        raise RuntimeError(err)
 
-    env["WINEPREFIX"] = os.environ.get("WINEPREFIX", "")
+    os.environ["WINEPREFIX"] = str(pfx)
+    env["WINEPREFIX"] = str(pfx)
 
     do_download = False
     # Skip Proton if running a native Linux executable
@@ -131,7 +135,9 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
         os.environ["PROTONPATH"] = str(STEAM_COMPAT.joinpath(os.environ["PROTONPATH"]))
 
     # Proton Codename
-    if os.environ.get("PROTONPATH") in {"GE-Proton", "GE-Latest", "UMU-Latest"}:
+    if os.environ.get("PROTONPATH") in {
+        "GE-Proton", "GE-Latest", "UMU-Latest", "umu-scout", "umu-soldier", "umu-sniper"
+    }:
         do_download = True
 
     if "PROTONPATH" not in os.environ:
@@ -166,7 +172,7 @@ def set_env(
     env: dict[str, str], args: Namespace | tuple[str, list[str]]
 ) -> dict[str, str]:
     """Set various environment variables for the Steam Runtime."""
-    pfx: Path = Path(env["WINEPREFIX"]).expanduser().resolve(strict=True)
+    pfx: Path = Path(env["WINEPREFIX"]).expanduser().resolve(strict=False)
     protonpath: Path = Path(env["PROTONPATH"]).expanduser().resolve(strict=True)
     # Command execution usage
     is_cmd: bool = isinstance(args, tuple)
@@ -232,16 +238,16 @@ def set_env(
     env["SteamGameId"] = env["SteamAppId"]
     env["UMU_INVOCATION_ID"] = token_hex(16)
 
-    runtime_path = f"{UMU_LOCAL}/{os.environ['RUNTIMEPATH']}" if os.environ['RUNTIMEPATH'] != "host" else ""
+    runtime_path = f"{UMU_LOCAL}/{os.environ['RUNTIMEPATH']}" if os.environ['RUNTIMEPATH'] else ""
 
     # PATHS
     env["WINEPREFIX"] = str(pfx)
+    env["STEAM_COMPAT_DATA_PATH"] = str(pfx)
+    env["STEAM_COMPAT_SHADER_PATH"] = str(pfx.joinpath("shadercache"))
     env["PROTONPATH"] = str(protonpath)
-    env["STEAM_COMPAT_DATA_PATH"] = env["WINEPREFIX"]
-    env["STEAM_COMPAT_SHADER_PATH"] = f"{env['STEAM_COMPAT_DATA_PATH']}/shadercache"
     env["STEAM_COMPAT_TOOL_PATHS"] = ":".join(
-        [f"{env['PROTONPATH']}", runtime_path]
-    ) if runtime_path else f"{env['PROTONPATH']}"
+        [f"{str(protonpath)}", runtime_path]
+    ) if runtime_path else f"{str(protonpath)}"
     env["STEAM_COMPAT_MOUNTS"] = env["STEAM_COMPAT_TOOL_PATHS"]
 
     # Zenity
@@ -320,7 +326,7 @@ def build_command(
     #     raise FileNotFoundError(err)
 
     # Winetricks
-    if env.get("EXE", "").endswith("winetricks") and opts:
+    if layer.is_proton and env.get("EXE", "").endswith("winetricks") and opts:
         # The position of arguments matter for winetricks
         # Usage: ./winetricks [options] [command|verb|path-to-verb] ...
         return (
@@ -663,76 +669,44 @@ def run_command(command: tuple[Path | str, ...]) -> int:
     return ret
 
 
-def resolve_runtime(runtimes: tuple[RuntimeVersion, ...]) -> RuntimeVersion | None:
+def resolve_runtime() -> RuntimeVersion | None:
     """Resolve the required runtime of a compatibility tool."""
-    version: tuple[str, str, str] | None = None
-
-    if os.environ.get("RUNTIMEPATH") in set(chain.from_iterable(runtimes)):
-        # Skip the parsing and trust the client
-        log.debug("RUNTIMEPATH is codename, skipping version resolution")
-        return next(
-            member for member in runtimes if os.environ["RUNTIMEPATH"] in member
-        )
-
+    # default to UMU-Latest if PROTONPATH is not set
     if not os.environ.get("PROTONPATH"):
-        log.debug("PROTONPATH unset, defaulting to '%s'", runtimes[0][1])
-        return runtimes[0]
+        os.environ["PROTONPATH"] = "UMU-Latest"
 
-    # Default to latest runtime for codenames
-    if os.environ.get("PROTONPATH") in {"GE-Proton", "GE-Latest", "UMU-Latest"}:
-        log.debug("PROTONPATH is codename, defaulting to '%s'", runtimes[0][1])
-        return runtimes[0]
+    named_runtimes = {
+        RUNTIME_NAMES["sniper"]: {"GE-Proton", "GE-Latest", "UMU-Latest", "umu-sniper"},
+        RUNTIME_NAMES["soldier"]: {"umu-scout", "umu-soldier"},
+    }
 
-    # Default to latest runtime for native Linux executables
-    if os.environ.get("UMU_NO_PROTON"):
-        log.debug("UMU_NO_PROTON set, defaulting to '%s'", runtimes[0][1])
-        return runtimes[0]
+    for name in named_runtimes:
+        if (protonpath := os.environ.get("PROTONPATH")) in named_runtimes[name]:
+            runtime = RUNTIME_VERSIONS[name]
+            log.debug(
+                "PROTONPATH is codename '%s', defaulting to '%s'",
+                protonpath,
+                runtime.name,
+            )
+            return runtime.as_tuple()
 
     # Solve the required runtime for PROTONPATH
     log.debug("PROTONPATH set, resolving its required runtime")
-    path: Path = STEAM_COMPAT.joinpath(os.environ.get("PROTONPATH", ""))
-    if os.environ.get("PROTONPATH") and path.is_dir():
-        os.environ["PROTONPATH"] = str(STEAM_COMPAT.joinpath(os.environ["PROTONPATH"]))
-
-    path = Path(os.environ["PROTONPATH"], "toolmanifest.vdf").expanduser().resolve()
-    if path.is_file():
-        version = get_umu_version_from_manifest(path, runtimes)
+    path: Path = Path(os.environ.get("PROTONPATH", "")).expanduser()
+    if not path.is_absolute():
+        path: Path = STEAM_COMPAT.joinpath(path).resolve()
+        if os.environ.get("PROTONPATH") and path.is_dir():
+            os.environ["PROTONPATH"] = str(path)
+
+    toolmanifest = path.joinpath("toolmanifest.vdf")
+    if toolmanifest.is_file():
+        layer = CompatLayer(toolmanifest.parent, Path())
+        runtime = layer.required_runtime
     else:
         err: str = f"PROTONPATH '{os.environ['PROTONPATH']}' is not valid, toolmanifest.vdf not found"
         raise FileNotFoundError(err)
 
-    return version
-
-
-def get_umu_version_from_manifest(
-    path: Path, runtimes: tuple[RuntimeVersion, ...]
-) -> RuntimeVersion | None:
-    """Find the required runtime from a compatibility tool's configuration file."""
-    key: str = "require_tool_appid"
-    appids: set[str] = {member[2] for member in runtimes}
-    appid: str = ""
-
-    with path.open(mode="r", encoding="utf-8") as file:
-        for line in file:
-            if key not in line:
-                continue
-            if match := re.search(r'"require_tool_appid"\s+"(\d+)', line):
-                appid = match.group(1)
-                break
-
-    if not appid:
-        if os.environ.get("UMU_NO_RUNTIME", None) == "1":
-            log.warning(
-                "Runtime Platform disabled. This mode is UNSUPPORTED by umu and remains only for convenience. "
-                "Issues created while using this mode will be automatically closed."
-            )
-            return "host", "host", "host"
-        return None
-
-    if appid not in set(filter(None, appids)):
-        return None
-
-    return next(member for member in runtimes if appid in member)
+    return runtime.as_tuple()
 
 
 def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
@@ -822,7 +796,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         opts = args[1]  # Reference the executable options
 
     # Resolve the runtime version for PROTONPATH
-    runtime_version = resolve_runtime(__runtime_versions__)
+    runtime_version = resolve_runtime()
     if not runtime_version:
         err: str = (
             f"Failed to match '{os.environ.get('PROTONPATH')}' with a container runtime"
@@ -874,7 +848,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         # Setup the launcher and runtime files
         _, do_download = check_env(env)
 
-        if runtime_variant != "host":
+        if runtime_variant:
             UMU_LOCAL.joinpath(runtime_variant).mkdir(parents=True, exist_ok=True)
 
             future: Future = thread_pool.submit(
@@ -896,17 +870,22 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
             except Exception as e:
                 log.exception(e)
 
+        # Restore shim if missing
+        if not UMU_LOCAL.joinpath("umu-shim").is_file():
+            create_shim(UMU_LOCAL / "umu-shim")
+
+        protonpath: Path = Path(env["PROTONPATH"]).expanduser().resolve(strict=True)
+        layer = CompatLayer(protonpath, UMU_LOCAL.joinpath("umu-shim"))
+
         # Prepare the prefix
-        with unix_flock(f"{UMU_LOCAL}/{FileLock.Prefix.value}"):
-            setup_pfx(env["WINEPREFIX"])
+        if layer.is_proton:
+            cdata_path: Path =  Path(env["WINEPREFIX"]).expanduser().resolve(strict=False)
+            with unix_flock(f"{UMU_LOCAL}/{FileLock.Prefix.value}"):
+                setup_pfx(cdata_path)
 
         # Configure the environment
         set_env(env, args)
 
-        # Restore shim if missing
-        if not UMU_LOCAL.joinpath("umu-shim").is_file():
-            create_shim(UMU_LOCAL / "umu-shim")
-
         # Set all environment variables
         # NOTE: `env` after this block should be read only
         for key, val in env.items():
@@ -919,11 +898,6 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
     ):
         sys.exit(1)
 
-    layer = CompatLayer(
-        env["RUNTIMEPATH"] if env.get("UMU_NO_PROTON", False) else env["PROTONPATH"],
-        UMU_LOCAL.joinpath("umu-shim")
-    )
-
     # Build the command
     command: tuple[Path | str, ...] = build_command(env, layer, opts)
     log.debug("%s", command)
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index a99c252..c010d52 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -430,6 +430,7 @@ class UmuRuntime:
 
     name: str
     variant: str
+    appid: str
     path: Path | None = None
 
     def __post_init__(self) -> None:  # noqa: D105
@@ -440,14 +441,17 @@ class UmuRuntime:
 
     def __bool__(self) -> bool:
         """Return if the runtime's path has been populated."""
-        return self.path.is_dir() and self.path.joinpath("mtree.txt.gz").is_file()
+        return self.path is not None and self.path.is_dir() and self.path.joinpath("mtree.txt.gz").is_file()
+
+    def as_tuple(self) -> RuntimeVersion:
+        """Return runtime information as tuple."""
+        return self.name, self.variant, self.appid
 
 
 RUNTIME_VERSIONS = {
-    "host":    UmuRuntime("host",    ""        ),
-    "1070560": UmuRuntime("scout",   "steamrt1"),
-    "1391110": UmuRuntime("soldier", "steamrt2"),
-    "1628350": UmuRuntime("sniper",  "steamrt3"),
+    "host":    UmuRuntime("host",    ""        , ""   ),
+    "1391110": UmuRuntime("soldier", "steamrt2", "1391110"),
+    "1628350": UmuRuntime("sniper",  "steamrt3", "1628350"),
     # ""       : UmuRuntime("medic",   "steamrt4"),
 }
 
@@ -458,26 +462,25 @@ RUNTIME_NAMES = {RUNTIME_VERSIONS[key].name: key for key in RUNTIME_VERSIONS}
 class CompatLayer:
     """Class to describe a Steam compatibility layer."""
 
-    def __init__(self, path: str, shim: Path) -> None:  # noqa: D107
-        self.tool_path = path
+    def __init__(self, path: Path, shim: Path) -> None:  # noqa: D107
+        self.tool_path = path.as_posix()
         with Path(path).joinpath("toolmanifest.vdf").open(encoding="utf-8") as f:
             self.tool_manifest = vdf.load(f)["manifest"]
 
-        self.runtime: CompatLayer = (
-            CompatLayer(str(self.required_runtime.path), shim)
-            if self.required_tool_appid is not None
+        self.runtime: CompatLayer | None = (
+            CompatLayer(self.required_runtime.path, shim)
+            if self.required_tool_appid is not None and self.required_runtime.path is not None
             else None
         )
 
-        _path = Path(path)
-        if _path.joinpath("compatibilitytool.vdf").exists():
-            with _path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
+        if path.joinpath("compatibilitytool.vdf").exists():
+            with path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
                 # There can be multiple tools definitions in `compatibilitytools.vdf`
                 # Take the first one and hope it is the one with the correct display_name
                 compat_tools = tuple(vdf.load(f)["compatibilitytools"]["compat_tools"].values())
                 self.compatibility_tool = compat_tools[0]
         else:
-            self.compatibility_tool = {"display_name": _path.name}
+            self.compatibility_tool = {"display_name": path.name}
 
         self.shim = shim
 
@@ -496,6 +499,10 @@ class CompatLayer:
     def layer_name(self) -> str | None:  # noqa: D102
         return str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else None
 
+    @property
+    def is_proton(self) -> bool:  # noqa: D102
+        return self.layer_name == "proton"
+
     @property
     def display_name(self) -> str | None:  # noqa: D102
         return str(ret) if (ret := self.compatibility_tool.get("display_name")) else None
@@ -520,7 +527,7 @@ class CompatLayer:
 
         If the runtime uses another runtime, its entry point is prepended to the local command.
         """
-        log.info("Running '%s' using runtime on '%s'", self.display_name, self.required_runtime.name)
+        log.info("Running '%s' using runtime '%s'", self.display_name, self.required_runtime.name)
         cmd = self.runtime.command(verb) if self.runtime is not None else []
         target = self._command(verb)
         if self.layer_name in {"container-runtime"}:
diff --git a/umu/umu_test.py b/umu/umu_test.py
index bf654c6..e351923 100644
--- a/umu/umu_test.py
+++ b/umu/umu_test.py
@@ -2571,7 +2571,7 @@ class TestGameLauncher(unittest.TestCase):
             result_args = __main__.parse_args()
             # Config
             _, result_dl = umu_run.check_env(self.env)
-            if version[1] != "host":
+            if version[1]:
                 umu_run.download_proton(result_dl, self.env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
@@ -2671,7 +2671,7 @@ class TestGameLauncher(unittest.TestCase):
             result_args = __main__.parse_args()
             # Config
             _, result_dl = umu_run.check_env(self.env)
-            if version[1] != "host":
+            if version[1]:
                 umu_run.download_proton(result_dl, self.env, thread_pool)
             # Prefix
             umu_run.setup_pfx(self.env["WINEPREFIX"])
-- 
2.53.0


From 3b71146f9389f3b5bc6665e2d71bd9b05ba8546f Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 7 Oct 2025 16:31:19 +0300
Subject: [PATCH 12/43] umu_run: set STEAM_COMPAT_LAUNCHER_SERVICE based on the
 tool's compatmanager_layer_name

---
 umu/umu_proton.py  | 1 +
 umu/umu_run.py     | 2 ++
 umu/umu_runtime.py | 5 ++++-
 3 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index 0982ef5..892eca4 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -141,6 +141,7 @@ def _get_umu_runtime_tool(env: dict[str, str], name: str) -> dict[str, str] | No
             "commandline": "/entry-point",
             "require_tool_appid": rt_appid,
             "use_sessions": "1",
+            # special value, see CompatLayer.layer_name()
             "compatmanager_layer_name": "umu-passthrough",
         }
     }
diff --git a/umu/umu_run.py b/umu/umu_run.py
index 7a3bd58..6cc9e06 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -732,6 +732,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         "STEAM_COMPAT_CLIENT_INSTALL_PATH": "",
         "STEAM_COMPAT_DATA_PATH": "",
         "STEAM_COMPAT_SHADER_PATH": "",
+        "STEAM_COMPAT_LAUNCHER_SERVICE": "",
         "FONTCONFIG_PATH": "",
         "EXE": "",
         "SteamAppId": "",
@@ -884,6 +885,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
                 setup_pfx(cdata_path)
 
         # Configure the environment
+        env["STEAM_COMPAT_LAUNCHER_SERVICE"] = layer.layer_name
         set_env(env, args)
 
         # Set all environment variables
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index c010d52..28bc9c5 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -497,7 +497,10 @@ class CompatLayer:
 
     @property
     def layer_name(self) -> str | None:  # noqa: D102
-        return str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else None
+        layer_name = str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else None
+        if layer_name == "umu-passthrough":
+            layer_name = self.runtime.tool_manifest.get("compatmanager_layer_name")
+        return layer_name
 
     @property
     def is_proton(self) -> bool:  # noqa: D102
-- 
2.53.0


From 2ab3fc55ab37f224d9cbc5d2c71efe6a2c438512 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 15 Nov 2025 10:08:53 +0200
Subject: [PATCH 13/43] umu_run: handle and relay SIGINT/SIGTERM to the child
 processes

---
 umu/umu_run.py | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 6cc9e06..0439a2c 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -1,4 +1,5 @@
 import os
+import signal
 import sys
 import threading
 from _ctypes import CFuncPtr
@@ -15,6 +16,7 @@ from re import match
 from secrets import token_hex
 from socket import AF_INET, SOCK_DGRAM, socket
 from subprocess import Popen
+from types import FrameType
 from typing import Any
 
 from urllib3 import PoolManager, Retry
@@ -619,6 +621,13 @@ def run_in_steammode(proc: Popen) -> int:
     return proc.wait()
 
 
+def signal_handler(sig: int, frame: FrameType):  # noqa: ARG001
+    """Handle SIGINT/SIGTERM."""
+    pstree = get_pstree_from_pid(os.getpid())
+    for p in pstree:
+        os.kill(p, sig)
+
+
 def run_command(command: tuple[Path | str, ...]) -> int:
     """Run the executable using Proton within the Steam Runtime."""
     prctl: CFuncPtr
@@ -662,6 +671,9 @@ def run_command(command: tuple[Path | str, ...]) -> int:
     prctl_ret = prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0, 0)
     log.debug("prctl exited with status: %s", prctl_ret)
 
+    signal.signal(signal.SIGTERM, signal_handler)
+    signal.signal(signal.SIGINT, signal_handler)
+
     with Popen(command, start_new_session=True, cwd=cwd) as proc:
         ret = run_in_steammode(proc) if is_steammode else proc.wait()
         log.debug("Child %s exited with wait status: %s", proc.pid, ret)
-- 
2.53.0


From 538c378a95c9efded36b98a7f2fe7596be0bb597 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 15 Nov 2025 10:40:53 +0200
Subject: [PATCH 14/43] umu: update for steamrt4

---
 umu/umu_proton.py  | 7 ++++++-
 umu/umu_run.py     | 3 ++-
 umu/umu_runtime.py | 2 +-
 3 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index 892eca4..d15202f 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -56,6 +56,7 @@ class ProtonVersion(Enum):
     UMUScout = "umu-scout"
     UMUSoldier = "umu-soldier"
     UMUSniper = "umu-sniper"
+    UMUSteamRT4 = "umu-steamrt4"
 
 
 def get_umu_proton(env: dict[str, str], session_pools: SessionPools) -> dict[str, str]:
@@ -110,7 +111,11 @@ def _get_umu_runtime_tool(env: dict[str, str], name: str) -> dict[str, str] | No
     When 'PROTONPATH' is 'umu-soldier' or 'umu-sniper', create a shim compatibility
     tool that requires the respective runtime and launches the application in that runtime.
     """
-    if not (name and name in {ProtonVersion.UMUSoldier.value, ProtonVersion.UMUSniper.value}):
+    if not (name and name in {
+        ProtonVersion.UMUSoldier.value,
+        ProtonVersion.UMUSniper.value,
+        ProtonVersion.UMUSteamRT4.value
+    }):
         return None
 
     rt_appid = RUNTIME_VERSIONS[RUNTIME_NAMES[name.removeprefix("umu-")]].appid
diff --git a/umu/umu_run.py b/umu/umu_run.py
index 0439a2c..40aa5e5 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -138,7 +138,7 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
 
     # Proton Codename
     if os.environ.get("PROTONPATH") in {
-        "GE-Proton", "GE-Latest", "UMU-Latest", "umu-scout", "umu-soldier", "umu-sniper"
+        "GE-Proton", "GE-Latest", "UMU-Latest", "umu-scout", "umu-soldier", "umu-sniper", "umu-steamrt4"
     }:
         do_download = True
 
@@ -688,6 +688,7 @@ def resolve_runtime() -> RuntimeVersion | None:
         os.environ["PROTONPATH"] = "UMU-Latest"
 
     named_runtimes = {
+        RUNTIME_NAMES["steamrt4"]: {"umu-steamrt4"},
         RUNTIME_NAMES["sniper"]: {"GE-Proton", "GE-Latest", "UMU-Latest", "umu-sniper"},
         RUNTIME_NAMES["soldier"]: {"umu-scout", "umu-soldier"},
     }
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 28bc9c5..127952c 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -452,7 +452,7 @@ RUNTIME_VERSIONS = {
     "host":    UmuRuntime("host",    ""        , ""   ),
     "1391110": UmuRuntime("soldier", "steamrt2", "1391110"),
     "1628350": UmuRuntime("sniper",  "steamrt3", "1628350"),
-    # ""       : UmuRuntime("medic",   "steamrt4"),
+    "4183110": UmuRuntime("steamrt4","steamrt4", "4183110"),
 }
 
 
-- 
2.53.0


From cb54cf322680fff53363a3e56952ffff8b672d07 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sun, 16 Nov 2025 13:18:18 +0200
Subject: [PATCH 15/43] umu_runtime: expose `steam-runtime-launch-client`'s
 path in CompatLayer

---
 umu/umu_runtime.py | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 127952c..fb5646a 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -502,6 +502,15 @@ class CompatLayer:
             layer_name = self.runtime.tool_manifest.get("compatmanager_layer_name")
         return layer_name
 
+    @property
+    def launch_client(self) -> str | None:
+        """Expose pv's launch-client path depending on the tool's container runtime."""
+        if self.tool_manifest.get("compatmanager_layer_name") == "container-runtime":
+            return f"{self.tool_path}/pressure-vessel/bin/steam-runtime-launch-client"
+        if self.runtime:
+            return self.runtime.launch_client
+        return None
+
     @property
     def is_proton(self) -> bool:  # noqa: D102
         return self.layer_name == "proton"
-- 
2.53.0


From 0c1325be748f79ce703283ece0ea0af9fb97f150 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Fri, 6 Jun 2025 16:57:28 +0300
Subject: [PATCH 16/43] umu_run: use `steam-runtime-launch-client` to re-enter
 an active container

this uses `steam-runtime-launch-client` to enable the dbus interface exposed
container runtimes as described [here](1) and re-enter it to run executables.

Exposing the dbus interface itself depends on `compatmanager_layer_name`
attribute of the tool's `toolmanifest.vdf` and is activated when
`STEAM_COMPAT_LAUNCHER_SERVICE` is set to the attribute's value. The bus's
"friendly" name is controlled by `STEAM_COMPAT_APP_ID`.

To make the bus name predictable, this change assumes only one container
instance should run on a prefix at any time. Thus `STEAM_COMPAT_APP_ID` is
set to the value of `STEAM_COMPAT_DATA_PATH` with slashes `/` replaced with
underscores `_`. When the command is built, umu checks whether the bus
name already exists, and enters the existing container using
`steam-runtime-launch-client` instead of creating an new one, in which it
executes proton with `runinprefix`.

[1](https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/main/docs/slr-for-game-developers.md?ref_type=heads#inserting-debugging-commands-into-the-container)
---
 umu/umu_run.py     | 24 +++++++++++++++++++++---
 umu/umu_runtime.py |  6 +++---
 2 files changed, 24 insertions(+), 6 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 40aa5e5..556013d 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -15,7 +15,7 @@ from pwd import getpwuid
 from re import match
 from secrets import token_hex
 from socket import AF_INET, SOCK_DGRAM, socket
-from subprocess import Popen
+from subprocess import PIPE, Popen
 from types import FrameType
 from typing import Any
 
@@ -151,7 +151,7 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
     return env, do_download
 
 
-def download_proton(download: bool, env: dict[str, str], session_pools: tuple[ThreadPoolExecutor, PoolManager]) -> None:
+def download_proton(download: bool, env: dict[str, str], session_pools: tuple[ThreadPoolExecutor, PoolManager]) -> None:  # noqa: FBT001
     """Check if umu should download proton and check if PROTONPATH is set.
 
     I am not gonna lie about it, this only exists to satisfy the tests, because downloading
@@ -245,6 +245,7 @@ def set_env(
     # PATHS
     env["WINEPREFIX"] = str(pfx)
     env["STEAM_COMPAT_DATA_PATH"] = str(pfx)
+    env["STEAM_COMPAT_APP_ID"] = str(pfx).replace("/", "_")
     env["STEAM_COMPAT_SHADER_PATH"] = str(pfx.joinpath("shadercache"))
     env["PROTONPATH"] = str(protonpath)
     env["STEAM_COMPAT_TOOL_PATHS"] = ":".join(
@@ -344,7 +345,24 @@ def build_command(
     # if env.get("UMU_NO_PROTON") == "1":
     #     return *entry_point, env["EXE"], *opts
 
+    nsenter: tuple[str, ...] = ()
+    if launch_client := layer.launch_client:
+        with Popen([launch_client, "--list"], stdout=PIPE, stderr=PIPE) as proc:
+            out, err = proc.communicate()
+        bus_names = out.decode("utf-8").splitlines()
+        pfx_bus = "com.steampowered.App" + env["STEAM_COMPAT_APP_ID"]
+        if f"--bus-name={pfx_bus}" in bus_names:
+            nsenter = (launch_client, f"--bus-name={pfx_bus}", "--")
+            # Unset runtime to make the CompatLayer stack report only the command
+            # of the innermost layer instead of the whole layer chain.
+            layer.runtime = None
+            env["PROTON_VERB"] = "runinprefix"
+            log.info("Re-entering container through bus '%s'", pfx_bus)
+        else:
+            env["PROTON_VERB"] = "waitforexitandrun"
+
     return (
+        *nsenter,
         *layer.command(env["PROTON_VERB"]),
         env["EXE"],
         *opts,
@@ -621,7 +639,7 @@ def run_in_steammode(proc: Popen) -> int:
     return proc.wait()
 
 
-def signal_handler(sig: int, frame: FrameType):  # noqa: ARG001
+def signal_handler(sig: int, frame: FrameType | None):  # noqa: ARG001
     """Handle SIGINT/SIGTERM."""
     pstree = get_pstree_from_pid(os.getpid())
     for p in pstree:
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index fb5646a..b28ab40 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -496,9 +496,9 @@ class CompatLayer:
         return RUNTIME_VERSIONS[self.required_tool_appid]
 
     @property
-    def layer_name(self) -> str | None:  # noqa: D102
-        layer_name = str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else None
-        if layer_name == "umu-passthrough":
+    def layer_name(self) -> str:  # noqa: D102
+        layer_name = str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else ""
+        if layer_name == "umu-passthrough" and self.runtime is not None:
             layer_name = self.runtime.tool_manifest.get("compatmanager_layer_name")
         return layer_name
 
-- 
2.53.0


From d2c43ffb564e341d568af5ac6becc0b3ae6537d6 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 18 Nov 2025 22:01:49 +0200
Subject: [PATCH 17/43] umu_run: use a combination of the prefix and proton
 paths to make the predictable bus name

Only one proton should operate on a prefix at any given time so re-enter the container only
if the same proton is used for running other executables while the container is active.

In the future this can be automated further by investigating `PROTONPATH/TOOLPATH` in the container
if that's exposed, but for now this will stop anything else from running by the virtue of
`waitforexitandrun` (wineserver)
---
 umu/umu_run.py | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 556013d..b807934 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -1,3 +1,4 @@
+import hashlib
 import os
 import signal
 import sys
@@ -246,6 +247,9 @@ def set_env(
     env["WINEPREFIX"] = str(pfx)
     env["STEAM_COMPAT_DATA_PATH"] = str(pfx)
     env["STEAM_COMPAT_APP_ID"] = str(pfx).replace("/", "_")
+    prefix_md5 = hashlib.md5(str(pfx).encode("utf-8")).hexdigest()  # noqa: S324
+    proton_md5 = hashlib.md5(str(protonpath).encode("utf-8")).hexdigest()  # noqa: S324
+    env["STEAM_COMPAT_APP_ID"] = f"{prefix_md5}_{proton_md5}"
     env["STEAM_COMPAT_SHADER_PATH"] = str(pfx.joinpath("shadercache"))
     env["PROTONPATH"] = str(protonpath)
     env["STEAM_COMPAT_TOOL_PATHS"] = ":".join(
-- 
2.53.0


From 67676975a211ded89a9f0d826c7dc647b15d45ad Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Wed, 19 Nov 2025 12:13:20 +0200
Subject: [PATCH 18/43] umu_run: use hashed prefix path for STEAM_COMPAT_APP_ID

---
 umu/umu_run.py | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index b807934..02144bc 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -246,10 +246,10 @@ def set_env(
     # PATHS
     env["WINEPREFIX"] = str(pfx)
     env["STEAM_COMPAT_DATA_PATH"] = str(pfx)
-    env["STEAM_COMPAT_APP_ID"] = str(pfx).replace("/", "_")
     prefix_md5 = hashlib.md5(str(pfx).encode("utf-8")).hexdigest()  # noqa: S324
-    proton_md5 = hashlib.md5(str(protonpath).encode("utf-8")).hexdigest()  # noqa: S324
-    env["STEAM_COMPAT_APP_ID"] = f"{prefix_md5}_{proton_md5}"
+    # proton_md5 = hashlib.md5(str(protonpath).encode("utf-8")).hexdigest()  # noqa: RUF100,S324
+    # env["STEAM_COMPAT_APP_ID"] = f"{prefix_md5}_{proton_md5}"
+    env["STEAM_COMPAT_APP_ID"] = f"{prefix_md5}"
     env["STEAM_COMPAT_SHADER_PATH"] = str(pfx.joinpath("shadercache"))
     env["PROTONPATH"] = str(protonpath)
     env["STEAM_COMPAT_TOOL_PATHS"] = ":".join(
-- 
2.53.0


From 371db409839d23ba455fb771e09b70ca2ad1e048 Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Fri, 21 Nov 2025 17:04:11 -0500
Subject: [PATCH 19/43] bump release notes

---
 release_notes.md | 41 +++++++++++++++++++++++++++++++++--------
 1 file changed, 33 insertions(+), 8 deletions(-)

diff --git a/release_notes.md b/release_notes.md
index dd833f5..c617d15 100644
--- a/release_notes.md
+++ b/release_notes.md
@@ -1,14 +1,39 @@
-#  Release notes (`1.2.9`)
+#  Release notes (`1.3.0`)
 
 ## Changes
-- Revert "umu_run: complete the implemtation of reaper in umu"
-- Revert "umu_run: run steammode workaround on the main process"
-- Revert "umu_run: use hardcoded display values for now"
-- bump release notes
+- Merge pull request #570 from R1kaB3rN/bump-version-1.3.0
+- Bump version to 1.3.0
+- feat: add steamrt4 app id (#569)
+- feat: add steamrt4 container runtime (#480)
+- test: add tests when resolving required runtime (#568)
+- ci: add fedora 43 workflow (#566)
+- build(deps): bump actions/upload-artifact from 4 to 5 (#561)
+- build(deps): bump actions/download-artifact from 5 to 6 (#562)
+- refactor: update log statement on network error when downloading runtime
+- fix: handle all network errors on proton download
+- feat: add support for overriding default HTTP retries and timeouts (#560)
+- ci: fix syntax in file lock test (#555)
+- refactor: use XDG_DATA_HOME and delay temp cleanup at runtime install (#554)
+- fix: ensure link and shim creation on runtime update (#553)
+- fix: skip removing old runtime after updating
+- refactor: prefer atomic syscalls when installing runtime (#550)
+- ci: test against python 3.14 (#547)
+- build(deps): bump actions/setup-python from 5 to 6 (#542)
+- docs: update README.md. NixOS 25.05 is out (#541)
+- fix: search /sbin for ldconfig (#540)
+- build(deps): bump actions/checkout from 4 to 5 (#533)
+- build(deps): bump actions/download-artifact from 4 to 5 (#530)
+- chore: bump urllib3 to 2.5.0 (#528)
+- build: fix FileNotFound in Debian 12 build (#529)
+- build: drop filelock dependency in rpm (#527)
+- ci: use Fedora 42 image for *.fc42.rpm (#526)
+- refactor: improve logging on network error (#525)
+- build(deps): bump DeterminateSystems/flake-checker-action from 11 to 12 (#518)
+- fix: update output path when using zenity (#513)
 
 ## Metadata
 ```
-This version -------- 1.2.9
-Previous version ---- 1.2.8
-Total commits ------- 4
+This version -------- 1.3.0
+Previous version ---- 1.2.9
+Total commits ------- 29
 ```
-- 
2.53.0


From d7313fe73a2bdcc9ae93138693706f523fe71fde Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Sat, 22 Nov 2025 02:09:46 -0500
Subject: [PATCH 20/43] add rpm spec fixes/changes for f43 and urllib

---
 packaging/rpm/umu-launcher.spec | 43 +++++++++++++++++++++------------
 1 file changed, 28 insertions(+), 15 deletions(-)

diff --git a/packaging/rpm/umu-launcher.spec b/packaging/rpm/umu-launcher.spec
index d6f6805..23c3250 100644
--- a/packaging/rpm/umu-launcher.spec
+++ b/packaging/rpm/umu-launcher.spec
@@ -1,8 +1,8 @@
 # Tag is auto-inserted by workflow
-%global tag 1.2.5
+%global tag 1.3.0
 
 # Manual commit is auto-inserted by workflow
-%global commit a11540cbf2221a5671c4ced97c0bf7e61c98d21e
+%global commit 24cdc86a1565764655c9de12404b2c5d12dec6e7
 
 %global shortcommit %(c=%{commit}; echo ${c:0:7})
 
@@ -10,8 +10,10 @@
 
 %global rel_build 1.%{build_timestamp}.%{shortcommit}%{?dist}
 
+%if 0%{?fedora} <= 42
 # F41 doesn't ship urllib3 >= 2.0 needed
 %global urllib3 2.3.0
+%endif
 
 Name:           umu-launcher
 Version:        %{tag}
@@ -21,9 +23,13 @@ Summary:        A tool for launching non-steam games with proton
 License:        GPLv3
 URL:            https://github.com/Open-Wine-Components/umu-launcher
 Source0:        %{url}/archive/refs/tags/%{tag}.tar.gz#/%{name}-%{tag}.tar.gz
+
+%if 0%{?fedora} <= 42
 Source1:        https://github.com/urllib3/urllib3/releases/download/%{urllib3}/urllib3-%{urllib3}.tar.gz
+%endif
 
 BuildArch:  x86_64
+BuildRequires:  rpm-build
 BuildRequires:  meson >= 0.54.0
 BuildRequires:  ninja-build
 BuildRequires:  cmake
@@ -37,39 +43,41 @@ BuildRequires:  python3-installer
 BuildRequires:  python3-hatchling
 BuildRequires:  python
 BuildRequires:  python3
-BuildRequires:  python3-pip
-BuildRequires:  libzstd-devel
+BuildRequires:  cargo
 BuildRequires:  python3-hatch-vcs
 BuildRequires:  python3-wheel
-BuildRequires:  python3-xlib
+BuildRequires:  libzstd-devel
 BuildRequires:  python3-pyzstd
-BuildRequires:  cargo
+BuildRequires:  python3-xlib
+BuildRequires:  wget
 
-# Can't use these yet, F41 doesn't ship urllib3 >= 2.0 needed
-#BuildRequires:  python3-urllib3
+%if 0%{?fedora} > 42
+BuildRequires:  python3-urllib3
+%endif
 
 Requires:	python
 Requires:	python3
 Requires:	python3-xlib
 Requires:	python3-pyzstd
 
-# Can't use these yet, F41 doesn't ship urllib3 >= 2.0 needed
-#Requires:  python3-urllib3
+%if 0%{?fedora} > 42
+Requires:  python3-urllib3
+%endif
 
 Recommends:	python3-cbor2
 Recommends:	python3-xxhash
 Recommends:	libzstd
 
-# We need this for now to allow umu's builtin urllib3 version to be used.
-# Can be removed when python3-urllib3 version is bumped >= 2.0
+%if 0%{?fedora} <= 42
 AutoReqProv: no
-
+%endif
 
 %description
 %{name} A tool for launching non-steam games with proton
 
 %prep
 %autosetup -p 1
+%if 0%{?fedora} <= 42
 if ! find subprojects/urllib3/ -mindepth 1 -maxdepth 1 | read; then
     # Directory is empty, perform action
     mv %{SOURCE1} .
@@ -77,11 +85,16 @@ if ! find subprojects/urllib3/ -mindepth 1 -maxdepth 1 | read; then
     rm *.tar.gz
     mv urllib3-%{urllib3}/* subprojects/urllib3/
 fi
+%endif
 
 %build
-# Update this when fedora ships urllib3 >= 2.0
-#./configure.sh --prefix=/usr --use-system-pyzstd --use-system-urllib
+
+%if 0%{?fedora} <= 42
 ./configure.sh --prefix=/usr --use-system-pyzstd
+%else
+./configure.sh --prefix=/usr --use-system-pyzstd --use-system-urllib
+%endif
+
 make
 
 %install
-- 
2.53.0


From 8d3b65649cb5864c32d2000c766daca09d00e49c Mon Sep 17 00:00:00 2001
From: "dependabot[bot]" <49699333+dependabot[bot]@users.noreply.github.com>
Date: Mon, 24 Nov 2025 13:17:22 -0800
Subject: [PATCH 21/43] build(deps): bump actions/checkout from 5 to 6 (#573)

Bumps [actions/checkout](https://github.com/actions/checkout) from 5 to 6.
- [Release notes](https://github.com/actions/checkout/releases)
- [Changelog](https://github.com/actions/checkout/blob/main/CHANGELOG.md)
- [Commits](https://github.com/actions/checkout/compare/v5...v6)

---
updated-dependencies:
- dependency-name: actions/checkout
  dependency-version: '6'
  dependency-type: direct:production
  update-type: version-update:semver-major
...

Signed-off-by: dependabot[bot] <support@github.com>
Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
---
 .github/workflows/build-umu-debian-12.yml    | 2 +-
 .github/workflows/build-umu-debian-13.yml    | 2 +-
 .github/workflows/build-umu-fedora-41.yml    | 2 +-
 .github/workflows/build-umu-fedora-42.yml    | 2 +-
 .github/workflows/build-umu-fedora-43.yml    | 2 +-
 .github/workflows/build-umu-nix-flake.yml    | 2 +-
 .github/workflows/build-umu-ubuntu-noble.yml | 2 +-
 .github/workflows/build-umu-version.yml      | 2 +-
 .github/workflows/build-umu-zipapp.yml       | 2 +-
 .github/workflows/e2e.yml                    | 2 +-
 .github/workflows/make.yml                   | 2 +-
 .github/workflows/static.yml                 | 2 +-
 .github/workflows/umu-python.yml             | 2 +-
 .github/workflows/update-umu-nix-flake.yml   | 2 +-
 14 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/.github/workflows/build-umu-debian-12.yml b/.github/workflows/build-umu-debian-12.yml
index 2a9b45c..584d9d9 100644
--- a/.github/workflows/build-umu-debian-12.yml
+++ b/.github/workflows/build-umu-debian-12.yml
@@ -23,7 +23,7 @@ jobs:
     - name: Install build dependencies
       run: apt install -y dh-make dpkg-dev git
 
-    - uses: actions/checkout@v5
+    - uses: actions/checkout@v6
       with:
         fetch-depth: 0
 
diff --git a/.github/workflows/build-umu-debian-13.yml b/.github/workflows/build-umu-debian-13.yml
index bd292c2..b9b72d2 100644
--- a/.github/workflows/build-umu-debian-13.yml
+++ b/.github/workflows/build-umu-debian-13.yml
@@ -22,7 +22,7 @@ jobs:
       - name: Install build dependencies
         run: apt install -y dh-make dpkg-dev git
 
-      - uses: actions/checkout@v5
+      - uses: actions/checkout@v6
         with:
           fetch-depth: 0
 
diff --git a/.github/workflows/build-umu-fedora-41.yml b/.github/workflows/build-umu-fedora-41.yml
index fa3c94b..0d8635e 100644
--- a/.github/workflows/build-umu-fedora-41.yml
+++ b/.github/workflows/build-umu-fedora-41.yml
@@ -21,7 +21,7 @@ jobs:
         run: dnf install -y git
 
       - name: Checkout repository
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           fetch-depth: 0
 
diff --git a/.github/workflows/build-umu-fedora-42.yml b/.github/workflows/build-umu-fedora-42.yml
index 4c2b52b..d43ab2e 100644
--- a/.github/workflows/build-umu-fedora-42.yml
+++ b/.github/workflows/build-umu-fedora-42.yml
@@ -21,7 +21,7 @@ jobs:
         run: dnf install -y git
 
       - name: Checkout repository
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           fetch-depth: 0
 
diff --git a/.github/workflows/build-umu-fedora-43.yml b/.github/workflows/build-umu-fedora-43.yml
index a88927b..f383df7 100644
--- a/.github/workflows/build-umu-fedora-43.yml
+++ b/.github/workflows/build-umu-fedora-43.yml
@@ -21,7 +21,7 @@ jobs:
         run: dnf install -y git
 
       - name: Checkout repository
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           fetch-depth: 0
 
diff --git a/.github/workflows/build-umu-nix-flake.yml b/.github/workflows/build-umu-nix-flake.yml
index 1c72ab1..ded27d1 100644
--- a/.github/workflows/build-umu-nix-flake.yml
+++ b/.github/workflows/build-umu-nix-flake.yml
@@ -14,7 +14,7 @@ jobs:
     # TODO: setup binary cache
     steps:
       - name: Checkout repository
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Install nix
         uses: cachix/install-nix-action@v31
         with:
diff --git a/.github/workflows/build-umu-ubuntu-noble.yml b/.github/workflows/build-umu-ubuntu-noble.yml
index 0101960..4a875ba 100644
--- a/.github/workflows/build-umu-ubuntu-noble.yml
+++ b/.github/workflows/build-umu-ubuntu-noble.yml
@@ -23,7 +23,7 @@ jobs:
     - name: Install build dependencies
       run: apt install -y dh-make dpkg-dev git
 
-    - uses: actions/checkout@v5
+    - uses: actions/checkout@v6
       with:
         fetch-depth: 0
 
diff --git a/.github/workflows/build-umu-version.yml b/.github/workflows/build-umu-version.yml
index 634305c..2adf746 100644
--- a/.github/workflows/build-umu-version.yml
+++ b/.github/workflows/build-umu-version.yml
@@ -20,7 +20,7 @@ jobs:
       full_desc: ${{ steps.describe.outputs.full_desc }}
       branch: ${{ steps.describe.outputs.branch }}
     steps:
-      - uses: actions/checkout@v5
+      - uses: actions/checkout@v6
         with:
           fetch-depth: 0
       - name: Describe
diff --git a/.github/workflows/build-umu-zipapp.yml b/.github/workflows/build-umu-zipapp.yml
index 9ea0167..dc17a26 100644
--- a/.github/workflows/build-umu-zipapp.yml
+++ b/.github/workflows/build-umu-zipapp.yml
@@ -22,7 +22,7 @@ jobs:
     - name: Install build dependencies
       run: apt install -y python3-venv python3-all bash make scdoc python3-hatchling python3-installer python3-build cargo git
 
-    - uses: actions/checkout@v5
+    - uses: actions/checkout@v6
       with:
         fetch-depth: 0
 
diff --git a/.github/workflows/e2e.yml b/.github/workflows/e2e.yml
index e900bc4..5e7aa70 100644
--- a/.github/workflows/e2e.yml
+++ b/.github/workflows/e2e.yml
@@ -14,7 +14,7 @@ jobs:
     runs-on: ubuntu-latest
 
     steps:
-      - uses: actions/checkout@v5
+      - uses: actions/checkout@v6
         with:
           fetch-depth: 0
       - name: Install dependencies
diff --git a/.github/workflows/make.yml b/.github/workflows/make.yml
index ca98b9a..10ae6b2 100644
--- a/.github/workflows/make.yml
+++ b/.github/workflows/make.yml
@@ -14,7 +14,7 @@ jobs:
     runs-on: ubuntu-latest
 
     steps:
-    - uses: actions/checkout@v5
+    - uses: actions/checkout@v6
       with:
         fetch-depth: 0
     - name: Install dependencies
diff --git a/.github/workflows/static.yml b/.github/workflows/static.yml
index 1db73fb..ae43046 100644
--- a/.github/workflows/static.yml
+++ b/.github/workflows/static.yml
@@ -18,7 +18,7 @@ jobs:
     runs-on: ubuntu-latest
 
     steps:
-      - uses: actions/checkout@v5
+      - uses: actions/checkout@v6
       - name: Set up Python
         uses: actions/setup-python@v6
         with:
diff --git a/.github/workflows/umu-python.yml b/.github/workflows/umu-python.yml
index 99d6494..7c99d77 100644
--- a/.github/workflows/umu-python.yml
+++ b/.github/workflows/umu-python.yml
@@ -20,7 +20,7 @@ jobs:
     runs-on: ubuntu-latest
 
     steps:
-      - uses: actions/checkout@v5
+      - uses: actions/checkout@v6
       - name: Set up Python
         uses: actions/setup-python@v6
         with:
diff --git a/.github/workflows/update-umu-nix-flake.yml b/.github/workflows/update-umu-nix-flake.yml
index 8fa4e17..6fd854b 100644
--- a/.github/workflows/update-umu-nix-flake.yml
+++ b/.github/workflows/update-umu-nix-flake.yml
@@ -14,7 +14,7 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout repository
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Install nix
         uses: cachix/install-nix-action@v31
         with:
-- 
2.53.0


From 73a14d9b6a74557daae5b96dc026e75d22df5e2a Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Sun, 14 Dec 2025 19:07:41 -0500
Subject: [PATCH 22/43] fix missing f43 build dependency

---
 .github/workflows/build-umu-fedora-43.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.github/workflows/build-umu-fedora-43.yml b/.github/workflows/build-umu-fedora-43.yml
index f383df7..0c29a93 100644
--- a/.github/workflows/build-umu-fedora-43.yml
+++ b/.github/workflows/build-umu-fedora-43.yml
@@ -29,7 +29,7 @@ jobs:
         run: git config --global --add safe.directory "$GITHUB_WORKSPACE"
 
       - name: Install build dependencies
-        run: dnf install -y rpm-build meson ninja-build cmake g++ gcc-c++ scdoc git python3-devel python3-build python3-installer python3-hatchling python python3 cargo python3-hatch-vcs python3-wheel libzstd-devel python3-pyzstd python3-xlib wget
+        run: dnf install -y rpm-build meson ninja-build cmake g++ gcc-c++ scdoc git python3-devel python3-build python3-installer python3-hatchling python python3 cargo python3-hatch-vcs python3-wheel libzstd-devel python3-pyzstd python3-xlib python3-urllib3 wget
 
       - name: Extract Version and SHA
         run: |
-- 
2.53.0


From 082709a7ddb38514ac329bebbf5ad56ebc797e3e Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Sun, 14 Dec 2025 19:13:20 -0500
Subject: [PATCH 23/43] if store is defined, use one prefix for all games in
 that store (this is supplemented with per-exe winetricks overrides instead of
 global overrides

---
 umu/umu_run.py | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 02144bc..d1a64d9 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -116,7 +116,11 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
         raise ValueError(err)
 
     if "WINEPREFIX" not in os.environ:
-        pfx: Path = Path.home().joinpath("Games", "umu", env["GAMEID"])
+        if "STORE" in os.environ:
+            pfx: Path = Path.home().joinpath("Games", env["STORE"])
+        else:
+            pfx: Path = Path.home().joinpath("Games", "umu", env["GAMEID"])
+
     else:
         pfx: Path = Path(os.environ["WINEPREFIX"]).expanduser()
 
-- 
2.53.0


From bb5c870fe076e21fe60cb652b57365022fbfd77a Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Sun, 14 Dec 2025 19:15:39 -0500
Subject: [PATCH 24/43] fixup dumb spacing error

---
 umu/umu_run.py | 1 -
 1 file changed, 1 deletion(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index d1a64d9..28a7d9a 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -120,7 +120,6 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
             pfx: Path = Path.home().joinpath("Games", env["STORE"])
         else:
             pfx: Path = Path.home().joinpath("Games", "umu", env["GAMEID"])
-
     else:
         pfx: Path = Path(os.environ["WINEPREFIX"]).expanduser()
 
-- 
2.53.0


From 980e9af0ba3b74eb4baddd504718e9ba7f5fb984 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 13:23:23 +0200
Subject: [PATCH 25/43] umu_runtime: do not resolve runtime requirement when we
 just need information about the tool

---
 umu/umu_run.py     |  4 ++--
 umu/umu_runtime.py | 14 ++++++++------
 2 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 28a7d9a..cd74147 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -738,7 +738,7 @@ def resolve_runtime() -> RuntimeVersion | None:
 
     toolmanifest = path.joinpath("toolmanifest.vdf")
     if toolmanifest.is_file():
-        layer = CompatLayer(toolmanifest.parent, Path())
+        layer = CompatLayer(toolmanifest.parent, Path(), resolve=False)
         runtime = layer.required_runtime
     else:
         err: str = f"PROTONPATH '{os.environ['PROTONPATH']}' is not valid, toolmanifest.vdf not found"
@@ -914,7 +914,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
             create_shim(UMU_LOCAL / "umu-shim")
 
         protonpath: Path = Path(env["PROTONPATH"]).expanduser().resolve(strict=True)
-        layer = CompatLayer(protonpath, UMU_LOCAL.joinpath("umu-shim"))
+        layer = CompatLayer(protonpath, UMU_LOCAL.joinpath("umu-shim"), resolve=True)
 
         # Prepare the prefix
         if layer.is_proton:
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index b28ab40..262f094 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -462,16 +462,12 @@ RUNTIME_NAMES = {RUNTIME_VERSIONS[key].name: key for key in RUNTIME_VERSIONS}
 class CompatLayer:
     """Class to describe a Steam compatibility layer."""
 
-    def __init__(self, path: Path, shim: Path) -> None:  # noqa: D107
+    def __init__(self, path: Path, shim: Path, resolve: bool) -> None:  # noqa: D107, FBT001
         self.tool_path = path.as_posix()
         with Path(path).joinpath("toolmanifest.vdf").open(encoding="utf-8") as f:
             self.tool_manifest = vdf.load(f)["manifest"]
 
-        self.runtime: CompatLayer | None = (
-            CompatLayer(self.required_runtime.path, shim)
-            if self.required_tool_appid is not None and self.required_runtime.path is not None
-            else None
-        )
+        self.runtime: CompatLayer | None = self._resolve(shim, resolve) if resolve else None
 
         if path.joinpath("compatibilitytool.vdf").exists():
             with path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
@@ -484,6 +480,12 @@ class CompatLayer:
 
         self.shim = shim
 
+    def _resolve(self, shim: Path, resolve: bool) -> "CompatLayer | None":  # noqa: FBT001
+        """Construct and provide the concrete CompatLayer this layer depends on."""
+        if self.required_tool_appid is not None and self.required_runtime.path is not None:
+            return CompatLayer(self.required_runtime.path, shim, resolve)
+        return None
+
     @property
     def required_tool_appid(self) -> str | None:  # noqa: D102
         return str(ret) if (ret := self.tool_manifest.get("require_tool_appid")) else None
-- 
2.53.0


From ad7170132ad1c69a73ff5223774d4472526a47e7 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 15:05:57 +0200
Subject: [PATCH 26/43] Partially revert "doc: add documentation around
 UMU_NO_RUNTIME"

This reverts commit 683cefd5e1b80c0906ed49fb5f29df9f4f5c0949.
---
 README.md      | 3 +--
 docs/umu.1.scd | 7 -------
 2 files changed, 1 insertion(+), 9 deletions(-)

diff --git a/README.md b/README.md
index b533713..2b9549d 100644
--- a/README.md
+++ b/README.md
@@ -88,8 +88,7 @@ Borderlands 3 from EGS store.
 
 When reporting issues for games that fail to run, be sure to attach a log with your issue report. To acquire a log from umu, add `UMU_LOG=1` to your environment variables for verbose logging. Furthermore, you can use `PROTON_LOG=1` for proton to create a verbose log in your `$HOME` directory. The log will be named `steam-<appid>.log`, where `<appid>` will be `default` if you haven't set a `GAMEID` or a number, depending on what you have set for `GAMEID`.
 
-Do **NOT** report issues when using `UMU_NO_RUNTIME=1`, this option is provided for convenience for compatibility tools that do not set their runtime requirements, such as Proton < `5.13`, and they do not work with any of the supported runtimes.
-This mode does not make use of a container runtime, and issues while using it are irrelevant to umu-launcher in general. Thus such issues will be automatically closed.
+Do **NOT** report issues here when using compatibility tools that are **NOT** explictly supported, report them to their maintainers first. This includes non-Proton compatibility tools, as well as third-party Proton compatibility tools that are not provided through `umu-launcher`.
 
 ## Building
 
diff --git a/docs/umu.1.scd b/docs/umu.1.scd
index 5ae232d..8cd09ba 100644
--- a/docs/umu.1.scd
+++ b/docs/umu.1.scd
@@ -186,13 +186,6 @@ _UMU_HTTP_RETRIES_
 
 	Set _0_ to disable retries for HTTP requests. Set a positive integer to override the default.
 
-_UMU_NO_RUNTIME_
-	Optional. Allows for the configured compatibility tool to run outside of the Steam Linux Runtime.
-	This option is effective only if the compatibility tool doesn't require a runtime through its configuration.
-	On compatibility tools that require a runtime, this option is ignored.
-
-	Set _1_ to silence umu's error that it couldn't resolve a runtime to use, and run using the host's libraries.
-
 # SEE ALSO
 
 _umu_(5), _winetricks_(1)
-- 
2.53.0


From 3d88f950bda4381dde674adb88e0d5a940333325 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 15:04:12 +0200
Subject: [PATCH 27/43] Revert "project: add vdf requirement, submodule and
 vendor it"

This reverts commit 70cc061a6599bf91fb2143fe374c71a6c7e9401a.
---
 .gitmodules                 |  3 ---
 Makefile.in                 |  9 ---------
 configure.sh                |  6 ------
 packaging/nix/unwrapped.nix | 27 ++-------------------------
 pyproject.toml              |  2 +-
 requirements.in             |  1 -
 subprojects/vdf             |  1 -
 7 files changed, 3 insertions(+), 46 deletions(-)
 delete mode 160000 subprojects/vdf

diff --git a/.gitmodules b/.gitmodules
index 746dd8f..ed80a68 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -7,6 +7,3 @@
 [submodule "subprojects/python-xlib"]
 	path = subprojects/python-xlib
 	url = https://github.com/python-xlib/python-xlib.git
-[submodule "subprojects/vdf"]
-	path = subprojects/vdf
-	url = https://github.com/ValvePython/vdf.git
diff --git a/Makefile.in b/Makefile.in
index 65a4f63..1ad390f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -23,7 +23,6 @@ FLATPAK ?= xfalse
 # Ex. Arch and Fedora have pyzstd but ubuntu and debian don't
 USE_SYSTEM_PYZSTD ?= xfalse
 USE_SYSTEM_URLLIB ?= xfalse
-USE_SYSTEM_VDF ?= xfalse
 
 INSTALLER_ARGS := -m installer $(OBJDIR)/umu_launcher*.whl
 ifdef DESTDIR
@@ -86,16 +85,12 @@ umu-install: umu-dist-install umu-delta-install umu-docs-install
 endif
 
 
-
 $(OBJDIR)/.build-umu-vendored: | $(OBJDIR)
 	$(info :: Building vendored dependencies )
 	@if [ "$(USE_SYSTEM_PYZSTD)" != "xtrue" ]; then \
 		sed -i 's/setuptools>=64,<74/setuptools/' subprojects/pyzstd/pyproject.toml; \
 		cd subprojects/pyzstd && $(PYTHON_INTERPRETER) -m build -wn -C=--build-option=--dynamic-link-zstd --outdir=$(OBJDIR); \
 	fi
-	@if [ "$(USE_SYSTEM_VDF)" != "xtrue" ]; then \
-		cd subprojects/vdf && $(PYTHON_INTERPRETER) -m build -wn --outdir=$(OBJDIR); \
-	fi
 	@if [ "$(USE_SYSTEM_URLLIB)" != "xtrue" ]; then \
 		cd subprojects/urllib3 && \
 		sed -i 's/license-files = \["LICENSE.txt"\]//g' pyproject.toml && \
@@ -113,10 +108,6 @@ umu-vendored-install: umu-vendored
 		$(PYTHON_INTERPRETER) -m installer --destdir=$(DESTDIR)$(PYTHONDIR)/umu/_vendor subprojects/pyzstd/$(OBJDIR)/pyzstd*.whl; \
 		find $(DESTDIR)$(PYTHONDIR)/umu/_vendor -type d -name pyzstd | xargs -I {} mv {} $(DESTDIR)$(PYTHONDIR)/umu/_vendor; \
 	fi
-	@if [ "$(USE_SYSTEM_VDF)" != "xtrue" ]; then \
-		$(PYTHON_INTERPRETER) -m installer --destdir=$(DESTDIR)$(PYTHONDIR)/umu/_vendor subprojects/vdf/$(OBJDIR)/vdf*.whl; \
-		find $(DESTDIR)$(PYTHONDIR)/umu/_vendor -type d -name vdf | xargs -I {} mv {} $(DESTDIR)$(PYTHONDIR)/umu/_vendor; \
-	fi
 	@if [ "$(USE_SYSTEM_URLLIB)" != "xtrue" ]; then \
 		$(PYTHON_INTERPRETER) -m installer --destdir=$(DESTDIR)$(PYTHONDIR)/umu/_vendor subprojects/urllib3/$(OBJDIR)/urllib3*.whl; \
 		find $(DESTDIR)$(PYTHONDIR)/umu/_vendor -type d -name urllib3 | xargs -I {} mv {} $(DESTDIR)$(PYTHONDIR)/umu/_vendor; \
diff --git a/configure.sh b/configure.sh
index f5ecd93..27d3efd 100755
--- a/configure.sh
+++ b/configure.sh
@@ -75,9 +75,6 @@ function configure() {
     if [[ -n "$arg_use_system_urllib" ]]; then
       echo "USE_SYSTEM_URLLIB := xtrue"
     fi
-    if [[ -n "$arg_use_system_vdf" ]]; then
-      echo "USE_SYSTEM_VDF := xtrue"
-    fi
 
     # Prefix was specified, baking it into the Makefile
     if [[ -n $arg_prefix ]]; then
@@ -101,7 +98,6 @@ arg_user_install=""
 arg_help=""
 arg_use_system_pyzstd=""
 arg_use_system_urllib=""
-arg_use_system_vdf=""
 function parse_args() {
   local arg;
   local val;
@@ -151,8 +147,6 @@ function parse_args() {
       arg_use_system_pyzstd="1"
     elif [[ $arg = --use-system-urllib ]]; then
       arg_use_system_urllib="1"
-    elif [[ $arg = --use-system-vdf ]]; then
-      arg_use_system_vdf="1"
     else
       err "Unrecognized option $arg"
       return 1
diff --git a/packaging/nix/unwrapped.nix b/packaging/nix/unwrapped.nix
index 1d1ddfb..e216d96 100644
--- a/packaging/nix/unwrapped.nix
+++ b/packaging/nix/unwrapped.nix
@@ -2,7 +2,6 @@
   # Dependencies
   lib,
   rustPlatform,
-  python3Packages,
   umu-launcher-unwrapped,
   version,
   # Freeform overrides
@@ -20,7 +19,6 @@ assert lib.assertMsg (lib.versionAtLeast umu-launcher-unwrapped.version "1.2.0")
   overrideArgs = builtins.removeAttrs args [
     "lib"
     "rustPlatform"
-    "python3Packages"
     "umu-launcher-unwrapped"
     "version"
   ];
@@ -32,25 +30,13 @@ assert lib.assertMsg (lib.versionAtLeast umu-launcher-unwrapped.version "1.2.0")
     then umu-launcher-unwrapped
     else umu-launcher-unwrapped.override overrideArgs;
 in
-  package.overridePythonAttrs (old: {
+  package.overridePythonAttrs {
     inherit version;
     src = ../../.;
     cargoDeps = rustPlatform.importCargoLock {
       lockFile = ../../Cargo.lock;
     };
 
-    pythonPath =
-      (old.pythonPath or [])
-      ++ [
-        python3Packages.vdf
-      ];
-
-    configureFlags =
-      (old.configureFlags or [])
-      ++ [
-        "--use-system-vdf"
-      ];
-
     # Specify ourselves which tests are disabled
     disabledTests = [
       # Broken? Asserts that $STEAM_RUNTIME_LIBRARY_PATH is non-empty
@@ -61,14 +47,5 @@ in
       # Broken? Tests parse_args with no options (./umu_run.py)
       # Fails with AssertionError: SystemExit not raised
       "test_parse_args_noopts"
-
-      # FileNotFoundError: [Errno 2] No such file or directory: .local/share/umu/toolmanifest.vdf
-      "test_build_command"
-      "test_build_command_linux_exe"
-      "test_build_command_nopv"
-
-      # TypeError: cannot unpack non-iterable ThreadPoolExecutor object
-      "test_env_nowine_noproton"
-      "test_env_wine_noproton"
     ];
-  })
+  }
diff --git a/pyproject.toml b/pyproject.toml
index fc1d2ef..37acf27 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -35,7 +35,7 @@ classifiers = [
 urls = { repository = "https://github.com/Open-Wine-Components/umu-launcher" }
 # Note: urllib3 is a vendored dependency. When using our Makefile, it will be
 # installed automatically.
-dependencies = ["python-xlib>=0.33", "urllib3>=2.0.0", "vdf>=3.4"]
+dependencies = ["python-xlib>=0.33", "urllib3>=2.0.0"]
 
 [project.optional-dependencies]
 # Recommended
diff --git a/requirements.in b/requirements.in
index c9449f0..32fe129 100644
--- a/requirements.in
+++ b/requirements.in
@@ -1,6 +1,5 @@
 python-xlib>=0.33
 urllib3>=2.0.0,<3.0.0
-vdf>=3.4
 xxhash>=3.2.0
 pyzstd>=0.16.2
 cbor2>=5.4.6
diff --git a/subprojects/vdf b/subprojects/vdf
deleted file mode 160000
index d762926..0000000
--- a/subprojects/vdf
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit d76292623e326fb165fe3bdb684832cdf30959d4
-- 
2.53.0


From dd652ee42f5cba643d52f3fa8b3918b29d24f54c Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 14:50:59 +0200
Subject: [PATCH 28/43] umu: add vdf as a local python package

---
 umu/umu_proton.py   |   2 +-
 umu/umu_runtime.py  |   2 +-
 umu/vdf/__init__.py | 521 ++++++++++++++++++++++++++++++++++++++++++++
 umu/vdf/vdict.py    | 221 +++++++++++++++++++
 4 files changed, 744 insertions(+), 2 deletions(-)
 create mode 100644 umu/vdf/__init__.py
 create mode 100644 umu/vdf/vdict.py

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index d15202f..ff954e3 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -14,11 +14,11 @@ from shutil import move
 from tempfile import TemporaryDirectory, mkdtemp
 from typing import Any
 
-import vdf
 from urllib3.exceptions import HTTPError
 from urllib3.poolmanager import PoolManager
 from urllib3.response import BaseHTTPResponse
 
+from umu import vdf
 from umu.umu_bspatch import Content, ContentContainer, CustomPatcher
 from umu.umu_consts import (
     STEAM_COMPAT,
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 262f094..13fae9c 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -11,11 +11,11 @@ from shutil import move
 from subprocess import run
 from tempfile import TemporaryDirectory, mkdtemp
 
-import vdf
 from urllib3.exceptions import HTTPError
 from urllib3.poolmanager import PoolManager
 from urllib3.response import BaseHTTPResponse
 
+from umu import vdf
 from umu.umu_consts import UMU_CACHE, UMU_LOCAL, FileLock, HTTPMethod
 from umu.umu_log import log
 from umu.umu_util import (
diff --git a/umu/vdf/__init__.py b/umu/vdf/__init__.py
new file mode 100644
index 0000000..e6be94d
--- /dev/null
+++ b/umu/vdf/__init__.py
@@ -0,0 +1,521 @@
+"""
+Module for deserializing/serializing to and from VDF
+"""
+__version__ = "3.4"
+__author__ = "Rossen Georgiev"
+
+import re
+import sys
+import struct
+from binascii import crc32
+from io import BytesIO
+from io import StringIO as unicodeIO
+
+try:
+    from collections.abc import Mapping
+except:
+    from collections import Mapping
+
+from .vdict import VDFDict
+
+# Py2 & Py3 compatibility
+if sys.version_info[0] >= 3:
+    string_type = str
+    int_type = int
+    BOMS = '\ufffe\ufeff'
+
+    def strip_bom(line):
+        return line.lstrip(BOMS)
+else:
+    from StringIO import StringIO as strIO
+    string_type = basestring
+    int_type = long
+    BOMS = '\xef\xbb\xbf\xff\xfe\xfe\xff'
+    BOMS_UNICODE = '\\ufffe\\ufeff'.decode('unicode-escape')
+
+    def strip_bom(line):
+        return line.lstrip(BOMS if isinstance(line, str) else BOMS_UNICODE)
+
+# string escaping
+_unescape_char_map = {
+    r"\n": "\n",
+    r"\t": "\t",
+    r"\v": "\v",
+    r"\b": "\b",
+    r"\r": "\r",
+    r"\f": "\f",
+    r"\a": "\a",
+    r"\\": "\\",
+    r"\?": "?",
+    r"\"": "\"",
+    r"\'": "\'",
+}
+_escape_char_map = {v: k for k, v in _unescape_char_map.items()}
+
+def _re_escape_match(m):
+    return _escape_char_map[m.group()]
+
+def _re_unescape_match(m):
+    return _unescape_char_map[m.group()]
+
+def _escape(text):
+    return re.sub(r"[\n\t\v\b\r\f\a\\\?\"']", _re_escape_match, text)
+
+def _unescape(text):
+    return re.sub(r"(\\n|\\t|\\v|\\b|\\r|\\f|\\a|\\\\|\\\?|\\\"|\\')", _re_unescape_match, text)
+
+# parsing and dumping for KV1
+def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
+    """
+    Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a VDF)
+    to a Python object.
+
+    ``mapper`` specifies the Python object used after deserializetion. ``dict` is
+    used by default. Alternatively, ``collections.OrderedDict`` can be used if you
+    wish to preserve key order. Or any object that acts like a ``dict``.
+
+    ``merge_duplicate_keys`` when ``True`` will merge multiple KeyValue lists with the
+    same key into one instead of overwriting. You can se this to ``False`` if you are
+    using ``VDFDict`` and need to preserve the duplicates.
+    """
+    if not issubclass(mapper, Mapping):
+        raise TypeError("Expected mapper to be subclass of dict, got %s" % type(mapper))
+    if not hasattr(fp, 'readline'):
+        raise TypeError("Expected fp to be a file-like object supporting line iteration")
+
+    stack = [mapper()]
+    expect_bracket = False
+
+    re_keyvalue = re.compile(r'^("(?P<qkey>(?:\\.|[^\\"])*)"|(?P<key>#?[a-z0-9\-\_\\\?$%<>]+))'
+                             r'([ \t]*('
+                             r'"(?P<qval>(?:\\.|[^\\"])*)(?P<vq_end>")?'
+                             r'|(?P<val>(?:(?<!/)/(?!/)|[a-z0-9\-\_\\\?\*\.$<> ])+)'
+                             r'|(?P<sblock>{[ \t]*)(?P<eblock>})?'
+                             r'))?',
+                             flags=re.I)
+
+    for lineno, line in enumerate(fp, 1):
+        if lineno == 1:
+            line = strip_bom(line)
+
+        line = line.lstrip()
+
+        # skip empty and comment lines
+        if line == "" or line[0] == '/':
+            continue
+
+        # one level deeper
+        if line[0] == "{":
+            expect_bracket = False
+            continue
+
+        if expect_bracket:
+            raise SyntaxError("vdf.parse: expected openning bracket",
+                              (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 1, line))
+
+        # one level back
+        if line[0] == "}":
+            if len(stack) > 1:
+                stack.pop()
+                continue
+
+            raise SyntaxError("vdf.parse: one too many closing parenthasis",
+                              (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+
+        # parse keyvalue pairs
+        while True:
+            match = re_keyvalue.match(line)
+
+            if not match:
+                try:
+                    line += next(fp)
+                    continue
+                except StopIteration:
+                    raise SyntaxError("vdf.parse: unexpected EOF (open key quote?)",
+                                      (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+
+            key = match.group('key') if match.group('qkey') is None else match.group('qkey')
+            val = match.group('qval')
+            if val is None:
+                val = match.group('val')
+                if val is not None:
+                    val = val.rstrip()
+                    if val == "":
+                        val = None
+
+            if escaped:
+                key = _unescape(key)
+
+            # we have a key with value in parenthesis, so we make a new dict obj (level deeper)
+            if val is None:
+                if merge_duplicate_keys and key in stack[-1]:
+                    _m = stack[-1][key]
+                    # we've descended a level deeper, if value is str, we have to overwrite it to mapper
+                    if not isinstance(_m, mapper):
+                        _m = stack[-1][key] = mapper()
+                else:
+                    _m = mapper()
+                    stack[-1][key] = _m
+
+                if match.group('eblock') is None:
+                    # only expect a bracket if it's not already closed or on the same line
+                    stack.append(_m)
+                    if match.group('sblock') is None:
+                        expect_bracket = True
+
+            # we've matched a simple keyvalue pair, map it to the last dict obj in the stack
+            else:
+                # if the value is line consume one more line and try to match again,
+                # until we get the KeyValue pair
+                if match.group('vq_end') is None and match.group('qval') is not None:
+                    try:
+                        line += next(fp)
+                        continue
+                    except StopIteration:
+                        raise SyntaxError("vdf.parse: unexpected EOF (open quote for value?)",
+                                          (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+
+                stack[-1][key] = _unescape(val) if escaped else val
+
+            # exit the loop
+            break
+
+    if len(stack) != 1:
+        raise SyntaxError("vdf.parse: unclosed parenthasis or quotes (EOF)",
+                           (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+
+    return stack.pop()
+
+
+def loads(s, **kwargs):
+    """
+    Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON
+    document) to a Python object.
+    """
+    if not isinstance(s, string_type):
+        raise TypeError("Expected s to be a str, got %s" % type(s))
+
+    try:
+        fp = unicodeIO(s)
+    except TypeError:
+        fp = strIO(s)
+
+    return parse(fp, **kwargs)
+
+
+def load(fp, **kwargs):
+    """
+    Deserialize ``fp`` (a ``.readline()``-supporting file-like object containing
+    a JSON document) to a Python object.
+    """
+    return parse(fp, **kwargs)
+
+
+def dumps(obj, pretty=False, escaped=True):
+    """
+    Serialize ``obj`` to a VDF formatted ``str``.
+    """
+    if not isinstance(obj, Mapping):
+        raise TypeError("Expected data to be an instance of``dict``")
+    if not isinstance(pretty, bool):
+        raise TypeError("Expected pretty to be of type bool")
+    if not isinstance(escaped, bool):
+        raise TypeError("Expected escaped to be of type bool")
+
+    return ''.join(_dump_gen(obj, pretty, escaped))
+
+
+def dump(obj, fp, pretty=False, escaped=True):
+    """
+    Serialize ``obj`` as a VDF formatted stream to ``fp`` (a
+    ``.write()``-supporting file-like object).
+    """
+    if not isinstance(obj, Mapping):
+        raise TypeError("Expected data to be an instance of``dict``")
+    if not hasattr(fp, 'write'):
+        raise TypeError("Expected fp to have write() method")
+    if not isinstance(pretty, bool):
+        raise TypeError("Expected pretty to be of type bool")
+    if not isinstance(escaped, bool):
+        raise TypeError("Expected escaped to be of type bool")
+
+    for chunk in _dump_gen(obj, pretty, escaped):
+        fp.write(chunk)
+
+
+def _dump_gen(data, pretty=False, escaped=True, level=0):
+    indent = "\t"
+    line_indent = ""
+
+    if pretty:
+        line_indent = indent * level
+
+    for key, value in data.items():
+        if escaped and isinstance(key, string_type):
+            key = _escape(key)
+
+        if isinstance(value, Mapping):
+            yield '%s"%s"\n%s{\n' % (line_indent, key, line_indent)
+            for chunk in _dump_gen(value, pretty, escaped, level+1):
+                yield chunk
+            yield "%s}\n" % line_indent
+        else:
+            if escaped and isinstance(value, string_type):
+                value = _escape(value)
+
+            yield '%s"%s" "%s"\n' % (line_indent, key, value)
+
+
+# binary VDF
+class BASE_INT(int_type):
+    def __repr__(self):
+        return "%s(%d)" % (self.__class__.__name__, self)
+
+class UINT_64(BASE_INT):
+    pass
+
+class INT_64(BASE_INT):
+    pass
+
+class POINTER(BASE_INT):
+    pass
+
+class COLOR(BASE_INT):
+    pass
+
+BIN_NONE        = b'\x00'
+BIN_STRING      = b'\x01'
+BIN_INT32       = b'\x02'
+BIN_FLOAT32     = b'\x03'
+BIN_POINTER     = b'\x04'
+BIN_WIDESTRING  = b'\x05'
+BIN_COLOR       = b'\x06'
+BIN_UINT64      = b'\x07'
+BIN_END         = b'\x08'
+BIN_INT64       = b'\x0A'
+BIN_END_ALT     = b'\x0B'
+
+def binary_loads(b, mapper=dict, merge_duplicate_keys=True, alt_format=False, raise_on_remaining=True):
+    """
+    Deserialize ``b`` (``bytes`` containing a VDF in "binary form")
+    to a Python object.
+
+    ``mapper`` specifies the Python object used after deserializetion. ``dict` is
+    used by default. Alternatively, ``collections.OrderedDict`` can be used if you
+    wish to preserve key order. Or any object that acts like a ``dict``.
+
+    ``merge_duplicate_keys`` when ``True`` will merge multiple KeyValue lists with the
+    same key into one instead of overwriting. You can se this to ``False`` if you are
+    using ``VDFDict`` and need to preserve the duplicates.
+    """
+    if not isinstance(b, bytes):
+        raise TypeError("Expected s to be bytes, got %s" % type(b))
+
+    return binary_load(BytesIO(b), mapper, merge_duplicate_keys, alt_format, raise_on_remaining)
+
+def binary_load(fp, mapper=dict, merge_duplicate_keys=True, alt_format=False, raise_on_remaining=False):
+    """
+    Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
+    binary VDF) to a Python object.
+
+    ``mapper`` specifies the Python object used after deserializetion. ``dict` is
+    used by default. Alternatively, ``collections.OrderedDict`` can be used if you
+    wish to preserve key order. Or any object that acts like a ``dict``.
+
+    ``merge_duplicate_keys`` when ``True`` will merge multiple KeyValue lists with the
+    same key into one instead of overwriting. You can se this to ``False`` if you are
+    using ``VDFDict`` and need to preserve the duplicates.
+    """
+    if not hasattr(fp, 'read') or not hasattr(fp, 'tell') or not hasattr(fp, 'seek'):
+        raise TypeError("Expected fp to be a file-like object with tell()/seek() and read() returning bytes")
+    if not issubclass(mapper, Mapping):
+        raise TypeError("Expected mapper to be subclass of dict, got %s" % type(mapper))
+
+    # helpers
+    int32 = struct.Struct('<i')
+    uint64 = struct.Struct('<Q')
+    int64 = struct.Struct('<q')
+    float32 = struct.Struct('<f')
+
+    def read_string(fp, wide=False):
+        buf, end = b'', -1
+        offset = fp.tell()
+
+        # locate string end
+        while end == -1:
+            chunk = fp.read(64)
+
+            if chunk == b'':
+                raise SyntaxError("Unterminated cstring (offset: %d)" % offset)
+
+            buf += chunk
+            end = buf.find(b'\x00\x00' if wide else b'\x00')
+
+        if wide:
+            end += end % 2
+
+        # rewind fp
+        fp.seek(end - len(buf) + (2 if wide else 1), 1)
+
+        # decode string
+        result = buf[:end]
+
+        if wide:
+            result = result.decode('utf-16')
+        elif bytes is not str:
+            result = result.decode('utf-8', 'replace')
+        else:
+            try:
+                result.decode('ascii')
+            except:
+                result = result.decode('utf-8', 'replace')
+
+        return result
+
+    stack = [mapper()]
+    CURRENT_BIN_END = BIN_END if not alt_format else BIN_END_ALT
+
+    for t in iter(lambda: fp.read(1), b''):
+        if t == CURRENT_BIN_END:
+            if len(stack) > 1:
+                stack.pop()
+                continue
+            break
+
+        key = read_string(fp)
+
+        if t == BIN_NONE:
+            if merge_duplicate_keys and key in stack[-1]:
+                _m = stack[-1][key]
+            else:
+                _m = mapper()
+                stack[-1][key] = _m
+            stack.append(_m)
+        elif t == BIN_STRING:
+            stack[-1][key] = read_string(fp)
+        elif t == BIN_WIDESTRING:
+            stack[-1][key] = read_string(fp, wide=True)
+        elif t in (BIN_INT32, BIN_POINTER, BIN_COLOR):
+            val = int32.unpack(fp.read(int32.size))[0]
+
+            if t == BIN_POINTER:
+                val = POINTER(val)
+            elif t == BIN_COLOR:
+                val = COLOR(val)
+
+            stack[-1][key] = val
+        elif t == BIN_UINT64:
+            stack[-1][key] = UINT_64(uint64.unpack(fp.read(int64.size))[0])
+        elif t == BIN_INT64:
+            stack[-1][key] = INT_64(int64.unpack(fp.read(int64.size))[0])
+        elif t == BIN_FLOAT32:
+            stack[-1][key] = float32.unpack(fp.read(float32.size))[0]
+        else:
+            raise SyntaxError("Unknown data type at offset %d: %s" % (fp.tell() - 1, repr(t)))
+
+    if len(stack) != 1:
+        raise SyntaxError("Reached EOF, but Binary VDF is incomplete")
+    if raise_on_remaining and fp.read(1) != b'':
+        fp.seek(-1, 1)
+        raise SyntaxError("Binary VDF ended at offset %d, but there is more data remaining" % (fp.tell() - 1))
+
+    return stack.pop()
+
+def binary_dumps(obj, alt_format=False):
+    """
+    Serialize ``obj`` to a binary VDF formatted ``bytes``.
+    """
+    buf = BytesIO()
+    binary_dump(obj, buf, alt_format)
+    return buf.getvalue()
+
+def binary_dump(obj, fp, alt_format=False):
+    """
+    Serialize ``obj`` to a binary VDF formatted ``bytes`` and write it to ``fp`` filelike object
+    """
+    if not isinstance(obj, Mapping):
+        raise TypeError("Expected obj to be type of Mapping")
+    if not hasattr(fp, 'write'):
+        raise TypeError("Expected fp to have write() method")
+
+    for chunk in _binary_dump_gen(obj, alt_format=alt_format):
+        fp.write(chunk)
+
+def _binary_dump_gen(obj, level=0, alt_format=False):
+    if level == 0 and len(obj) == 0:
+        return
+
+    int32 = struct.Struct('<i')
+    uint64 = struct.Struct('<Q')
+    int64 = struct.Struct('<q')
+    float32 = struct.Struct('<f')
+
+    for key, value in obj.items():
+        if isinstance(key, string_type):
+            key = key.encode('utf-8')
+        else:
+            raise TypeError("dict keys must be of type str, got %s" % type(key))
+
+        if isinstance(value, Mapping):
+            yield BIN_NONE + key + BIN_NONE
+            for chunk in _binary_dump_gen(value, level+1, alt_format=alt_format):
+                yield chunk
+        elif isinstance(value, UINT_64):
+            yield BIN_UINT64 + key + BIN_NONE + uint64.pack(value)
+        elif isinstance(value, INT_64):
+            yield BIN_INT64 + key + BIN_NONE + int64.pack(value)
+        elif isinstance(value, string_type):
+            try:
+                value = value.encode('utf-8') + BIN_NONE
+                yield BIN_STRING
+            except:
+                value = value.encode('utf-16') + BIN_NONE*2
+                yield BIN_WIDESTRING
+            yield key + BIN_NONE + value
+        elif isinstance(value, float):
+            yield BIN_FLOAT32 + key + BIN_NONE + float32.pack(value)
+        elif isinstance(value, (COLOR, POINTER, int, int_type)):
+            if isinstance(value, COLOR):
+                yield BIN_COLOR
+            elif isinstance(value, POINTER):
+                yield BIN_POINTER
+            else:
+                yield BIN_INT32
+            yield key + BIN_NONE
+            yield int32.pack(value)
+        else:
+            raise TypeError("Unsupported type: %s" % type(value))
+
+    yield BIN_END if not alt_format else BIN_END_ALT
+
+
+def vbkv_loads(s, mapper=dict, merge_duplicate_keys=True):
+    """
+    Deserialize ``s`` (``bytes`` containing a VBKV to a Python object.
+
+    ``mapper`` specifies the Python object used after deserializetion. ``dict` is
+    used by default. Alternatively, ``collections.OrderedDict`` can be used if you
+    wish to preserve key order. Or any object that acts like a ``dict``.
+
+    ``merge_duplicate_keys`` when ``True`` will merge multiple KeyValue lists with the
+    same key into one instead of overwriting. You can se this to ``False`` if you are
+    using ``VDFDict`` and need to preserve the duplicates.
+    """
+    if s[:4] != b'VBKV':
+        raise ValueError("Invalid header")
+
+    checksum, = struct.unpack('<i', s[4:8])
+
+    if checksum != crc32(s[8:]):
+        raise ValueError("Invalid checksum")
+
+    return binary_loads(s[8:], mapper, merge_duplicate_keys, alt_format=True)
+
+def vbkv_dumps(obj):
+    """
+    Serialize ``obj`` to a VBKV formatted ``bytes``.
+    """
+    data =  b''.join(_binary_dump_gen(obj, alt_format=True))
+    checksum = crc32(data)
+
+    return b'VBKV' + struct.pack('<i', checksum) + data
diff --git a/umu/vdf/vdict.py b/umu/vdf/vdict.py
new file mode 100644
index 0000000..e67afca
--- /dev/null
+++ b/umu/vdf/vdict.py
@@ -0,0 +1,221 @@
+import sys
+from collections import Counter
+
+if sys.version_info[0] >= 3:
+    _iter_values = 'values'
+    _range = range
+    _string_type = str
+    import collections.abc as _c
+    class _kView(_c.KeysView):
+        def __iter__(self):
+            return self._mapping.iterkeys()
+    class _vView(_c.ValuesView):
+        def __iter__(self):
+            return self._mapping.itervalues()
+    class _iView(_c.ItemsView):
+        def __iter__(self):
+            return self._mapping.iteritems()
+else:
+    _iter_values = 'itervalues'
+    _range = xrange
+    _string_type = basestring
+    _kView = lambda x: list(x.iterkeys())
+    _vView = lambda x: list(x.itervalues())
+    _iView = lambda x: list(x.iteritems())
+
+
+class VDFDict(dict):
+    def __init__(self, data=None):
+        """
+        This is a dictionary that supports duplicate keys and preserves insert order
+
+        ``data`` can be a ``dict``, or a sequence of key-value tuples. (e.g. ``[('key', 'value'),..]``)
+        The only supported type for key is str.
+
+        Get/set duplicates is done by tuples ``(index, key)``, where index is the duplicate index
+        for the specified key. (e.g. ``(0, 'key')``, ``(1, 'key')``...)
+
+        When the ``key`` is ``str``, instead of tuple, set will create a duplicate and get will look up ``(0, key)``
+        """
+        self.__omap = []
+        self.__kcount = Counter()
+
+        if data is not None:
+            if not isinstance(data, (list, dict)):
+                raise ValueError("Expected data to be list of pairs or dict, got %s" % type(data))
+            self.update(data)
+
+    def __repr__(self):
+        out = "%s(" % self.__class__.__name__
+        out += "%s)" % repr(list(self.iteritems()))
+        return out
+
+    def __len__(self):
+        return len(self.__omap)
+
+    def _verify_key_tuple(self, key):
+        if len(key) != 2:
+            raise ValueError("Expected key tuple length to be 2, got %d" % len(key))
+        if not isinstance(key[0], int):
+            raise TypeError("Key index should be an int")
+        if not isinstance(key[1], _string_type):
+            raise TypeError("Key value should be a str")
+
+    def _normalize_key(self, key):
+        if isinstance(key, _string_type):
+            key = (0, key)
+        elif isinstance(key, tuple):
+            self._verify_key_tuple(key)
+        else:
+            raise TypeError("Expected key to be a str or tuple, got %s" % type(key))
+        return key
+
+    def __setitem__(self, key, value):
+        if isinstance(key, _string_type):
+            key = (self.__kcount[key], key)
+            self.__omap.append(key)
+        elif isinstance(key, tuple):
+            self._verify_key_tuple(key)
+            if key not in self:
+                raise KeyError("%s doesn't exist" % repr(key))
+        else:
+            raise TypeError("Expected either a str or tuple for key")
+        super(VDFDict, self).__setitem__(key, value)
+        self.__kcount[key[1]] += 1
+
+    def __getitem__(self, key):
+        return super(VDFDict, self).__getitem__(self._normalize_key(key))
+
+    def __delitem__(self, key):
+        key = self._normalize_key(key)
+        result = super(VDFDict, self).__delitem__(key)
+
+        start_idx = self.__omap.index(key)
+        del self.__omap[start_idx]
+
+        dup_idx, skey = key
+        self.__kcount[skey] -= 1
+        tail_count = self.__kcount[skey] - dup_idx
+
+        if tail_count > 0:
+            for idx in _range(start_idx, len(self.__omap)):
+                if self.__omap[idx][1] == skey:
+                    oldkey = self.__omap[idx]
+                    newkey = (dup_idx, skey)
+                    super(VDFDict, self).__setitem__(newkey, self[oldkey])
+                    super(VDFDict, self).__delitem__(oldkey)
+                    self.__omap[idx] = newkey
+
+                    dup_idx += 1
+                    tail_count -= 1
+                    if tail_count == 0:
+                        break
+
+        if self.__kcount[skey] == 0:
+            del self.__kcount[skey]
+
+        return result
+
+    def __iter__(self):
+        return iter(self.iterkeys())
+
+    def __contains__(self, key):
+        return super(VDFDict, self).__contains__(self._normalize_key(key))
+
+    def __eq__(self, other):
+        if isinstance(other, VDFDict):
+            return list(self.items()) == list(other.items())
+        else:
+            return False
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def clear(self):
+        super(VDFDict, self).clear()
+        self.__kcount.clear()
+        self.__omap = list()
+
+    def get(self, key, *args):
+        return super(VDFDict, self).get(self._normalize_key(key), *args)
+
+    def setdefault(self, key, default=None):
+        if key not in self:
+            self.__setitem__(key, default)
+        return self.__getitem__(key)
+
+    def pop(self, key):
+        key = self._normalize_key(key)
+        value = self.__getitem__(key)
+        self.__delitem__(key)
+        return value
+
+    def popitem(self):
+        if not self.__omap:
+            raise KeyError("VDFDict is empty")
+        key = self.__omap[-1]
+        return key[1], self.pop(key)
+
+    def update(self, data=None, **kwargs):
+        if isinstance(data, dict):
+            data = data.items()
+        elif not isinstance(data, list):
+            raise TypeError("Expected data to be a list or dict, got %s" % type(data))
+
+        for key, value in data:
+            self.__setitem__(key, value)
+
+    def iterkeys(self):
+        return (key[1] for key in self.__omap)
+
+    def keys(self):
+        return _kView(self)
+
+    def itervalues(self):
+        return (self[key] for key in self.__omap)
+
+    def values(self):
+        return _vView(self)
+
+    def iteritems(self):
+        return ((key[1], self[key]) for key in self.__omap)
+
+    def items(self):
+        return _iView(self)
+
+    def get_all_for(self, key):
+        """ Returns all values of the given key """
+        if not isinstance(key, _string_type):
+            raise TypeError("Key needs to be a string.")
+        return [self[(idx, key)] for idx in _range(self.__kcount[key])]
+
+    def remove_all_for(self, key):
+        """ Removes all items with the given key """
+        if not isinstance(key, _string_type):
+            raise TypeError("Key need to be a string.")
+
+        for idx in _range(self.__kcount[key]):
+            super(VDFDict, self).__delitem__((idx, key))
+
+        self.__omap = list(filter(lambda x: x[1] != key, self.__omap))
+
+        del self.__kcount[key]
+
+    def has_duplicates(self):
+        """
+        Returns ``True`` if the dict contains keys with duplicates.
+        Recurses through any all keys with value that is ``VDFDict``.
+        """
+        for n in getattr(self.__kcount, _iter_values)():
+            if n != 1:
+                return True
+
+        def dict_recurse(obj):
+            for v in getattr(obj, _iter_values)():
+                if isinstance(v, VDFDict) and v.has_duplicates():
+                    return True
+                elif isinstance(v, dict):
+                    return dict_recurse(v)
+            return False
+
+        return dict_recurse(self)
-- 
2.53.0


From e7f4dfc87fa094436de26fec87736cc5b9de4076 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 14:55:06 +0200
Subject: [PATCH 29/43] chore: apply safe fixes and format imported vdf package

---
 umu/vdf/__init__.py | 273 ++++++++++++++++++++++++++------------------
 umu/vdf/vdict.py    |  26 +++--
 2 files changed, 175 insertions(+), 124 deletions(-)

diff --git a/umu/vdf/__init__.py b/umu/vdf/__init__.py
index e6be94d..1120021 100644
--- a/umu/vdf/__init__.py
+++ b/umu/vdf/__init__.py
@@ -1,12 +1,11 @@
-"""
-Module for deserializing/serializing to and from VDF
-"""
+"""Module for deserializing/serializing to and from VDF"""
+
 __version__ = "3.4"
 __author__ = "Rossen Georgiev"
 
 import re
-import sys
 import struct
+import sys
 from binascii import crc32
 from io import BytesIO
 from io import StringIO as unicodeIO
@@ -14,7 +13,7 @@ from io import StringIO as unicodeIO
 try:
     from collections.abc import Mapping
 except:
-    from collections import Mapping
+    from collections.abc import Mapping
 
 from .vdict import VDFDict
 
@@ -22,20 +21,22 @@ from .vdict import VDFDict
 if sys.version_info[0] >= 3:
     string_type = str
     int_type = int
-    BOMS = '\ufffe\ufeff'
+    BOMS = "\ufffe\ufeff"
 
     def strip_bom(line):
         return line.lstrip(BOMS)
 else:
     from StringIO import StringIO as strIO
+
     string_type = basestring
     int_type = long
-    BOMS = '\xef\xbb\xbf\xff\xfe\xfe\xff'
-    BOMS_UNICODE = '\\ufffe\\ufeff'.decode('unicode-escape')
+    BOMS = "\xef\xbb\xbf\xff\xfe\xfe\xff"
+    BOMS_UNICODE = "\\ufffe\\ufeff".decode("unicode-escape")
 
     def strip_bom(line):
         return line.lstrip(BOMS if isinstance(line, str) else BOMS_UNICODE)
 
+
 # string escaping
 _unescape_char_map = {
     r"\n": "\n",
@@ -47,27 +48,33 @@ _unescape_char_map = {
     r"\a": "\a",
     r"\\": "\\",
     r"\?": "?",
-    r"\"": "\"",
-    r"\'": "\'",
+    r"\"": '"',
+    r"\'": "'",
 }
 _escape_char_map = {v: k for k, v in _unescape_char_map.items()}
 
+
 def _re_escape_match(m):
     return _escape_char_map[m.group()]
 
+
 def _re_unescape_match(m):
     return _unescape_char_map[m.group()]
 
+
 def _escape(text):
     return re.sub(r"[\n\t\v\b\r\f\a\\\?\"']", _re_escape_match, text)
 
+
 def _unescape(text):
-    return re.sub(r"(\\n|\\t|\\v|\\b|\\r|\\f|\\a|\\\\|\\\?|\\\"|\\')", _re_unescape_match, text)
+    return re.sub(
+        r"(\\n|\\t|\\v|\\b|\\r|\\f|\\a|\\\\|\\\?|\\\"|\\')", _re_unescape_match, text
+    )
+
 
 # parsing and dumping for KV1
 def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
-    """
-    Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a VDF)
+    """Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a VDF)
     to a Python object.
 
     ``mapper`` specifies the Python object used after deserializetion. ``dict` is
@@ -80,19 +87,23 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
     """
     if not issubclass(mapper, Mapping):
         raise TypeError("Expected mapper to be subclass of dict, got %s" % type(mapper))
-    if not hasattr(fp, 'readline'):
-        raise TypeError("Expected fp to be a file-like object supporting line iteration")
+    if not hasattr(fp, "readline"):
+        raise TypeError(
+            "Expected fp to be a file-like object supporting line iteration"
+        )
 
     stack = [mapper()]
     expect_bracket = False
 
-    re_keyvalue = re.compile(r'^("(?P<qkey>(?:\\.|[^\\"])*)"|(?P<key>#?[a-z0-9\-\_\\\?$%<>]+))'
-                             r'([ \t]*('
-                             r'"(?P<qval>(?:\\.|[^\\"])*)(?P<vq_end>")?'
-                             r'|(?P<val>(?:(?<!/)/(?!/)|[a-z0-9\-\_\\\?\*\.$<> ])+)'
-                             r'|(?P<sblock>{[ \t]*)(?P<eblock>})?'
-                             r'))?',
-                             flags=re.I)
+    re_keyvalue = re.compile(
+        r'^("(?P<qkey>(?:\\.|[^\\"])*)"|(?P<key>#?[a-z0-9\-\_\\\?$%<>]+))'
+        r"([ \t]*("
+        r'"(?P<qval>(?:\\.|[^\\"])*)(?P<vq_end>")?'
+        r"|(?P<val>(?:(?<!/)/(?!/)|[a-z0-9\-\_\\\?\*\.$<> ])+)"
+        r"|(?P<sblock>{[ \t]*)(?P<eblock>})?"
+        r"))?",
+        flags=re.IGNORECASE,
+    )
 
     for lineno, line in enumerate(fp, 1):
         if lineno == 1:
@@ -101,7 +112,7 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
         line = line.lstrip()
 
         # skip empty and comment lines
-        if line == "" or line[0] == '/':
+        if line == "" or line[0] == "/":
             continue
 
         # one level deeper
@@ -110,8 +121,10 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
             continue
 
         if expect_bracket:
-            raise SyntaxError("vdf.parse: expected openning bracket",
-                              (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 1, line))
+            raise SyntaxError(
+                "vdf.parse: expected openning bracket",
+                (getattr(fp, "name", "<%s>" % fp.__class__.__name__), lineno, 1, line),
+            )
 
         # one level back
         if line[0] == "}":
@@ -119,8 +132,10 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
                 stack.pop()
                 continue
 
-            raise SyntaxError("vdf.parse: one too many closing parenthasis",
-                              (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+            raise SyntaxError(
+                "vdf.parse: one too many closing parenthasis",
+                (getattr(fp, "name", "<%s>" % fp.__class__.__name__), lineno, 0, line),
+            )
 
         # parse keyvalue pairs
         while True:
@@ -131,13 +146,24 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
                     line += next(fp)
                     continue
                 except StopIteration:
-                    raise SyntaxError("vdf.parse: unexpected EOF (open key quote?)",
-                                      (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
-
-            key = match.group('key') if match.group('qkey') is None else match.group('qkey')
-            val = match.group('qval')
+                    raise SyntaxError(
+                        "vdf.parse: unexpected EOF (open key quote?)",
+                        (
+                            getattr(fp, "name", "<%s>" % fp.__class__.__name__),
+                            lineno,
+                            0,
+                            line,
+                        ),
+                    )
+
+            key = (
+                match.group("key")
+                if match.group("qkey") is None
+                else match.group("qkey")
+            )
+            val = match.group("qval")
             if val is None:
-                val = match.group('val')
+                val = match.group("val")
                 if val is not None:
                     val = val.rstrip()
                     if val == "":
@@ -157,23 +183,30 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
                     _m = mapper()
                     stack[-1][key] = _m
 
-                if match.group('eblock') is None:
+                if match.group("eblock") is None:
                     # only expect a bracket if it's not already closed or on the same line
                     stack.append(_m)
-                    if match.group('sblock') is None:
+                    if match.group("sblock") is None:
                         expect_bracket = True
 
             # we've matched a simple keyvalue pair, map it to the last dict obj in the stack
             else:
                 # if the value is line consume one more line and try to match again,
                 # until we get the KeyValue pair
-                if match.group('vq_end') is None and match.group('qval') is not None:
+                if match.group("vq_end") is None and match.group("qval") is not None:
                     try:
                         line += next(fp)
                         continue
                     except StopIteration:
-                        raise SyntaxError("vdf.parse: unexpected EOF (open quote for value?)",
-                                          (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+                        raise SyntaxError(
+                            "vdf.parse: unexpected EOF (open quote for value?)",
+                            (
+                                getattr(fp, "name", "<%s>" % fp.__class__.__name__),
+                                lineno,
+                                0,
+                                line,
+                            ),
+                        )
 
                 stack[-1][key] = _unescape(val) if escaped else val
 
@@ -181,15 +214,16 @@ def parse(fp, mapper=dict, merge_duplicate_keys=True, escaped=True):
             break
 
     if len(stack) != 1:
-        raise SyntaxError("vdf.parse: unclosed parenthasis or quotes (EOF)",
-                           (getattr(fp, 'name', '<%s>' % fp.__class__.__name__), lineno, 0, line))
+        raise SyntaxError(
+            "vdf.parse: unclosed parenthasis or quotes (EOF)",
+            (getattr(fp, "name", "<%s>" % fp.__class__.__name__), lineno, 0, line),
+        )
 
     return stack.pop()
 
 
 def loads(s, **kwargs):
-    """
-    Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON
+    """Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON
     document) to a Python object.
     """
     if not isinstance(s, string_type):
@@ -204,17 +238,14 @@ def loads(s, **kwargs):
 
 
 def load(fp, **kwargs):
-    """
-    Deserialize ``fp`` (a ``.readline()``-supporting file-like object containing
+    """Deserialize ``fp`` (a ``.readline()``-supporting file-like object containing
     a JSON document) to a Python object.
     """
     return parse(fp, **kwargs)
 
 
 def dumps(obj, pretty=False, escaped=True):
-    """
-    Serialize ``obj`` to a VDF formatted ``str``.
-    """
+    """Serialize ``obj`` to a VDF formatted ``str``."""
     if not isinstance(obj, Mapping):
         raise TypeError("Expected data to be an instance of``dict``")
     if not isinstance(pretty, bool):
@@ -222,17 +253,16 @@ def dumps(obj, pretty=False, escaped=True):
     if not isinstance(escaped, bool):
         raise TypeError("Expected escaped to be of type bool")
 
-    return ''.join(_dump_gen(obj, pretty, escaped))
+    return "".join(_dump_gen(obj, pretty, escaped))
 
 
 def dump(obj, fp, pretty=False, escaped=True):
-    """
-    Serialize ``obj`` as a VDF formatted stream to ``fp`` (a
+    """Serialize ``obj`` as a VDF formatted stream to ``fp`` (a
     ``.write()``-supporting file-like object).
     """
     if not isinstance(obj, Mapping):
         raise TypeError("Expected data to be an instance of``dict``")
-    if not hasattr(fp, 'write'):
+    if not hasattr(fp, "write"):
         raise TypeError("Expected fp to have write() method")
     if not isinstance(pretty, bool):
         raise TypeError("Expected pretty to be of type bool")
@@ -256,7 +286,7 @@ def _dump_gen(data, pretty=False, escaped=True, level=0):
 
         if isinstance(value, Mapping):
             yield '%s"%s"\n%s{\n' % (line_indent, key, line_indent)
-            for chunk in _dump_gen(value, pretty, escaped, level+1):
+            for chunk in _dump_gen(value, pretty, escaped, level + 1):
                 yield chunk
             yield "%s}\n" % line_indent
         else:
@@ -271,33 +301,40 @@ class BASE_INT(int_type):
     def __repr__(self):
         return "%s(%d)" % (self.__class__.__name__, self)
 
+
 class UINT_64(BASE_INT):
     pass
 
+
 class INT_64(BASE_INT):
     pass
 
+
 class POINTER(BASE_INT):
     pass
 
+
 class COLOR(BASE_INT):
     pass
 
-BIN_NONE        = b'\x00'
-BIN_STRING      = b'\x01'
-BIN_INT32       = b'\x02'
-BIN_FLOAT32     = b'\x03'
-BIN_POINTER     = b'\x04'
-BIN_WIDESTRING  = b'\x05'
-BIN_COLOR       = b'\x06'
-BIN_UINT64      = b'\x07'
-BIN_END         = b'\x08'
-BIN_INT64       = b'\x0A'
-BIN_END_ALT     = b'\x0B'
-
-def binary_loads(b, mapper=dict, merge_duplicate_keys=True, alt_format=False, raise_on_remaining=True):
-    """
-    Deserialize ``b`` (``bytes`` containing a VDF in "binary form")
+
+BIN_NONE = b"\x00"
+BIN_STRING = b"\x01"
+BIN_INT32 = b"\x02"
+BIN_FLOAT32 = b"\x03"
+BIN_POINTER = b"\x04"
+BIN_WIDESTRING = b"\x05"
+BIN_COLOR = b"\x06"
+BIN_UINT64 = b"\x07"
+BIN_END = b"\x08"
+BIN_INT64 = b"\x0a"
+BIN_END_ALT = b"\x0b"
+
+
+def binary_loads(
+    b, mapper=dict, merge_duplicate_keys=True, alt_format=False, raise_on_remaining=True
+):
+    """Deserialize ``b`` (``bytes`` containing a VDF in "binary form")
     to a Python object.
 
     ``mapper`` specifies the Python object used after deserializetion. ``dict` is
@@ -311,11 +348,19 @@ def binary_loads(b, mapper=dict, merge_duplicate_keys=True, alt_format=False, ra
     if not isinstance(b, bytes):
         raise TypeError("Expected s to be bytes, got %s" % type(b))
 
-    return binary_load(BytesIO(b), mapper, merge_duplicate_keys, alt_format, raise_on_remaining)
+    return binary_load(
+        BytesIO(b), mapper, merge_duplicate_keys, alt_format, raise_on_remaining
+    )
 
-def binary_load(fp, mapper=dict, merge_duplicate_keys=True, alt_format=False, raise_on_remaining=False):
-    """
-    Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
+
+def binary_load(
+    fp,
+    mapper=dict,
+    merge_duplicate_keys=True,
+    alt_format=False,
+    raise_on_remaining=False,
+):
+    """Deserialize ``fp`` (a ``.read()``-supporting file-like object containing
     binary VDF) to a Python object.
 
     ``mapper`` specifies the Python object used after deserializetion. ``dict` is
@@ -326,30 +371,32 @@ def binary_load(fp, mapper=dict, merge_duplicate_keys=True, alt_format=False, ra
     same key into one instead of overwriting. You can se this to ``False`` if you are
     using ``VDFDict`` and need to preserve the duplicates.
     """
-    if not hasattr(fp, 'read') or not hasattr(fp, 'tell') or not hasattr(fp, 'seek'):
-        raise TypeError("Expected fp to be a file-like object with tell()/seek() and read() returning bytes")
+    if not hasattr(fp, "read") or not hasattr(fp, "tell") or not hasattr(fp, "seek"):
+        raise TypeError(
+            "Expected fp to be a file-like object with tell()/seek() and read() returning bytes"
+        )
     if not issubclass(mapper, Mapping):
         raise TypeError("Expected mapper to be subclass of dict, got %s" % type(mapper))
 
     # helpers
-    int32 = struct.Struct('<i')
-    uint64 = struct.Struct('<Q')
-    int64 = struct.Struct('<q')
-    float32 = struct.Struct('<f')
+    int32 = struct.Struct("<i")
+    uint64 = struct.Struct("<Q")
+    int64 = struct.Struct("<q")
+    float32 = struct.Struct("<f")
 
     def read_string(fp, wide=False):
-        buf, end = b'', -1
+        buf, end = b"", -1
         offset = fp.tell()
 
         # locate string end
         while end == -1:
             chunk = fp.read(64)
 
-            if chunk == b'':
+            if chunk == b"":
                 raise SyntaxError("Unterminated cstring (offset: %d)" % offset)
 
             buf += chunk
-            end = buf.find(b'\x00\x00' if wide else b'\x00')
+            end = buf.find(b"\x00\x00" if wide else b"\x00")
 
         if wide:
             end += end % 2
@@ -361,21 +408,21 @@ def binary_load(fp, mapper=dict, merge_duplicate_keys=True, alt_format=False, ra
         result = buf[:end]
 
         if wide:
-            result = result.decode('utf-16')
+            result = result.decode("utf-16")
         elif bytes is not str:
-            result = result.decode('utf-8', 'replace')
+            result = result.decode("utf-8", "replace")
         else:
             try:
-                result.decode('ascii')
+                result.decode("ascii")
             except:
-                result = result.decode('utf-8', 'replace')
+                result = result.decode("utf-8", "replace")
 
         return result
 
     stack = [mapper()]
     CURRENT_BIN_END = BIN_END if not alt_format else BIN_END_ALT
 
-    for t in iter(lambda: fp.read(1), b''):
+    for t in iter(lambda: fp.read(1), b""):
         if t == CURRENT_BIN_END:
             if len(stack) > 1:
                 stack.pop()
@@ -411,54 +458,58 @@ def binary_load(fp, mapper=dict, merge_duplicate_keys=True, alt_format=False, ra
         elif t == BIN_FLOAT32:
             stack[-1][key] = float32.unpack(fp.read(float32.size))[0]
         else:
-            raise SyntaxError("Unknown data type at offset %d: %s" % (fp.tell() - 1, repr(t)))
+            raise SyntaxError(
+                "Unknown data type at offset %d: %s" % (fp.tell() - 1, repr(t))
+            )
 
     if len(stack) != 1:
         raise SyntaxError("Reached EOF, but Binary VDF is incomplete")
-    if raise_on_remaining and fp.read(1) != b'':
+    if raise_on_remaining and fp.read(1) != b"":
         fp.seek(-1, 1)
-        raise SyntaxError("Binary VDF ended at offset %d, but there is more data remaining" % (fp.tell() - 1))
+        raise SyntaxError(
+            "Binary VDF ended at offset %d, but there is more data remaining"
+            % (fp.tell() - 1)
+        )
 
     return stack.pop()
 
+
 def binary_dumps(obj, alt_format=False):
-    """
-    Serialize ``obj`` to a binary VDF formatted ``bytes``.
-    """
+    """Serialize ``obj`` to a binary VDF formatted ``bytes``."""
     buf = BytesIO()
     binary_dump(obj, buf, alt_format)
     return buf.getvalue()
 
+
 def binary_dump(obj, fp, alt_format=False):
-    """
-    Serialize ``obj`` to a binary VDF formatted ``bytes`` and write it to ``fp`` filelike object
-    """
+    """Serialize ``obj`` to a binary VDF formatted ``bytes`` and write it to ``fp`` filelike object"""
     if not isinstance(obj, Mapping):
         raise TypeError("Expected obj to be type of Mapping")
-    if not hasattr(fp, 'write'):
+    if not hasattr(fp, "write"):
         raise TypeError("Expected fp to have write() method")
 
     for chunk in _binary_dump_gen(obj, alt_format=alt_format):
         fp.write(chunk)
 
+
 def _binary_dump_gen(obj, level=0, alt_format=False):
     if level == 0 and len(obj) == 0:
         return
 
-    int32 = struct.Struct('<i')
-    uint64 = struct.Struct('<Q')
-    int64 = struct.Struct('<q')
-    float32 = struct.Struct('<f')
+    int32 = struct.Struct("<i")
+    uint64 = struct.Struct("<Q")
+    int64 = struct.Struct("<q")
+    float32 = struct.Struct("<f")
 
     for key, value in obj.items():
         if isinstance(key, string_type):
-            key = key.encode('utf-8')
+            key = key.encode("utf-8")
         else:
             raise TypeError("dict keys must be of type str, got %s" % type(key))
 
         if isinstance(value, Mapping):
             yield BIN_NONE + key + BIN_NONE
-            for chunk in _binary_dump_gen(value, level+1, alt_format=alt_format):
+            for chunk in _binary_dump_gen(value, level + 1, alt_format=alt_format):
                 yield chunk
         elif isinstance(value, UINT_64):
             yield BIN_UINT64 + key + BIN_NONE + uint64.pack(value)
@@ -466,10 +517,10 @@ def _binary_dump_gen(obj, level=0, alt_format=False):
             yield BIN_INT64 + key + BIN_NONE + int64.pack(value)
         elif isinstance(value, string_type):
             try:
-                value = value.encode('utf-8') + BIN_NONE
+                value = value.encode("utf-8") + BIN_NONE
                 yield BIN_STRING
             except:
-                value = value.encode('utf-16') + BIN_NONE*2
+                value = value.encode("utf-16") + BIN_NONE * 2
                 yield BIN_WIDESTRING
             yield key + BIN_NONE + value
         elif isinstance(value, float):
@@ -490,8 +541,7 @@ def _binary_dump_gen(obj, level=0, alt_format=False):
 
 
 def vbkv_loads(s, mapper=dict, merge_duplicate_keys=True):
-    """
-    Deserialize ``s`` (``bytes`` containing a VBKV to a Python object.
+    """Deserialize ``s`` (``bytes`` containing a VBKV to a Python object.
 
     ``mapper`` specifies the Python object used after deserializetion. ``dict` is
     used by default. Alternatively, ``collections.OrderedDict`` can be used if you
@@ -501,21 +551,20 @@ def vbkv_loads(s, mapper=dict, merge_duplicate_keys=True):
     same key into one instead of overwriting. You can se this to ``False`` if you are
     using ``VDFDict`` and need to preserve the duplicates.
     """
-    if s[:4] != b'VBKV':
+    if s[:4] != b"VBKV":
         raise ValueError("Invalid header")
 
-    checksum, = struct.unpack('<i', s[4:8])
+    (checksum,) = struct.unpack("<i", s[4:8])
 
     if checksum != crc32(s[8:]):
         raise ValueError("Invalid checksum")
 
     return binary_loads(s[8:], mapper, merge_duplicate_keys, alt_format=True)
 
+
 def vbkv_dumps(obj):
-    """
-    Serialize ``obj`` to a VBKV formatted ``bytes``.
-    """
-    data =  b''.join(_binary_dump_gen(obj, alt_format=True))
+    """Serialize ``obj`` to a VBKV formatted ``bytes``."""
+    data = b"".join(_binary_dump_gen(obj, alt_format=True))
     checksum = crc32(data)
 
-    return b'VBKV' + struct.pack('<i', checksum) + data
+    return b"VBKV" + struct.pack("<i", checksum) + data
diff --git a/umu/vdf/vdict.py b/umu/vdf/vdict.py
index e67afca..3d30b78 100644
--- a/umu/vdf/vdict.py
+++ b/umu/vdf/vdict.py
@@ -2,21 +2,24 @@ import sys
 from collections import Counter
 
 if sys.version_info[0] >= 3:
-    _iter_values = 'values'
+    _iter_values = "values"
     _range = range
     _string_type = str
     import collections.abc as _c
+
     class _kView(_c.KeysView):
         def __iter__(self):
             return self._mapping.iterkeys()
+
     class _vView(_c.ValuesView):
         def __iter__(self):
             return self._mapping.itervalues()
+
     class _iView(_c.ItemsView):
         def __iter__(self):
             return self._mapping.iteritems()
 else:
-    _iter_values = 'itervalues'
+    _iter_values = "itervalues"
     _range = xrange
     _string_type = basestring
     _kView = lambda x: list(x.iterkeys())
@@ -26,8 +29,7 @@ else:
 
 class VDFDict(dict):
     def __init__(self, data=None):
-        """
-        This is a dictionary that supports duplicate keys and preserves insert order
+        """This is a dictionary that supports duplicate keys and preserves insert order
 
         ``data`` can be a ``dict``, or a sequence of key-value tuples. (e.g. ``[('key', 'value'),..]``)
         The only supported type for key is str.
@@ -42,7 +44,9 @@ class VDFDict(dict):
 
         if data is not None:
             if not isinstance(data, (list, dict)):
-                raise ValueError("Expected data to be list of pairs or dict, got %s" % type(data))
+                raise ValueError(
+                    "Expected data to be list of pairs or dict, got %s" % type(data)
+                )
             self.update(data)
 
     def __repr__(self):
@@ -125,8 +129,7 @@ class VDFDict(dict):
     def __eq__(self, other):
         if isinstance(other, VDFDict):
             return list(self.items()) == list(other.items())
-        else:
-            return False
+        return False
 
     def __ne__(self, other):
         return not self.__eq__(other)
@@ -184,13 +187,13 @@ class VDFDict(dict):
         return _iView(self)
 
     def get_all_for(self, key):
-        """ Returns all values of the given key """
+        """Returns all values of the given key"""
         if not isinstance(key, _string_type):
             raise TypeError("Key needs to be a string.")
         return [self[(idx, key)] for idx in _range(self.__kcount[key])]
 
     def remove_all_for(self, key):
-        """ Removes all items with the given key """
+        """Removes all items with the given key"""
         if not isinstance(key, _string_type):
             raise TypeError("Key need to be a string.")
 
@@ -202,8 +205,7 @@ class VDFDict(dict):
         del self.__kcount[key]
 
     def has_duplicates(self):
-        """
-        Returns ``True`` if the dict contains keys with duplicates.
+        """Returns ``True`` if the dict contains keys with duplicates.
         Recurses through any all keys with value that is ``VDFDict``.
         """
         for n in getattr(self.__kcount, _iter_values)():
@@ -214,7 +216,7 @@ class VDFDict(dict):
             for v in getattr(obj, _iter_values)():
                 if isinstance(v, VDFDict) and v.has_duplicates():
                     return True
-                elif isinstance(v, dict):
+                if isinstance(v, dict):
                     return dict_recurse(v)
             return False
 
-- 
2.53.0


From bd05678f1c81dc5532490b2605896868578e8dd0 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 22:26:30 +0200
Subject: [PATCH 30/43] umu_runtime: separate launcher service from layer name

---
 umu/umu_run.py     |  4 +---
 umu/umu_runtime.py | 15 ++++++++++-----
 2 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index cd74147..4f17c30 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -365,8 +365,6 @@ def build_command(
             layer.runtime = None
             env["PROTON_VERB"] = "runinprefix"
             log.info("Re-entering container through bus '%s'", pfx_bus)
-        else:
-            env["PROTON_VERB"] = "waitforexitandrun"
 
     return (
         *nsenter,
@@ -923,7 +921,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
                 setup_pfx(cdata_path)
 
         # Configure the environment
-        env["STEAM_COMPAT_LAUNCHER_SERVICE"] = layer.layer_name
+        env["STEAM_COMPAT_LAUNCHER_SERVICE"] = layer.launcher_service
         set_env(env, args)
 
         # Set all environment variables
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 13fae9c..63f6895 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -499,15 +499,20 @@ class CompatLayer:
 
     @property
     def layer_name(self) -> str:  # noqa: D102
-        layer_name = str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else ""
-        if layer_name == "umu-passthrough" and self.runtime is not None:
-            layer_name = self.runtime.tool_manifest.get("compatmanager_layer_name")
-        return layer_name
+        return str(ret) if (ret := self.tool_manifest.get("compatmanager_layer_name")) else ""
+
+    @property
+    def launcher_service(self) -> str:
+        """Report the correct layer name for STEAM_COMPAT_LAUNCER_SERVICE."""
+        service = self.layer_name
+        if service == "umu-passthrough" and self.runtime is not None:
+            service = self.runtime.launcher_service
+        return service
 
     @property
     def launch_client(self) -> str | None:
         """Expose pv's launch-client path depending on the tool's container runtime."""
-        if self.tool_manifest.get("compatmanager_layer_name") == "container-runtime":
+        if self.layer_name == "container-runtime":
             return f"{self.tool_path}/pressure-vessel/bin/steam-runtime-launch-client"
         if self.runtime:
             return self.runtime.launch_client
-- 
2.53.0


From 8eda70d199fe7ecc15789bb9c1996d07137c8d57 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 25 Nov 2025 23:54:40 +0200
Subject: [PATCH 31/43] umu_runtime: refactor CompatLayer's interface to not
 need to unset the runtime

Instead of unsetting the runtime of the CompatLayer, make
`CompatLayer.command` report the tool specific (unwrapped) command when
requested.
---
 umu/umu_run.py     |  8 +++-----
 umu/umu_runtime.py | 39 +++++++++++++++++++++++++++------------
 2 files changed, 30 insertions(+), 17 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 4f17c30..2268e94 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -340,7 +340,7 @@ def build_command(
         # The position of arguments matter for winetricks
         # Usage: ./winetricks [options] [command|verb|path-to-verb] ...
         return (
-            *layer.command(env["PROTON_VERB"]),
+            *layer.command(env["PROTON_VERB"], unwrapped=False),
             env["EXE"],
             "-q",
             *opts,
@@ -360,15 +360,13 @@ def build_command(
         pfx_bus = "com.steampowered.App" + env["STEAM_COMPAT_APP_ID"]
         if f"--bus-name={pfx_bus}" in bus_names:
             nsenter = (launch_client, f"--bus-name={pfx_bus}", "--")
-            # Unset runtime to make the CompatLayer stack report only the command
-            # of the innermost layer instead of the whole layer chain.
-            layer.runtime = None
             env["PROTON_VERB"] = "runinprefix"
             log.info("Re-entering container through bus '%s'", pfx_bus)
 
+    is_nsenter: bool = bool(nsenter)
     return (
         *nsenter,
-        *layer.command(env["PROTON_VERB"]),
+        *layer.command(env["PROTON_VERB"], unwrapped=is_nsenter),
         env["EXE"],
         *opts,
     )
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 63f6895..d508dbc 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -462,12 +462,18 @@ RUNTIME_NAMES = {RUNTIME_VERSIONS[key].name: key for key in RUNTIME_VERSIONS}
 class CompatLayer:
     """Class to describe a Steam compatibility layer."""
 
-    def __init__(self, path: Path, shim: Path, resolve: bool) -> None:  # noqa: D107, FBT001
+    def __init__(self, path: Path, shim: Path, *, resolve: bool) -> None:
+        """Create a CompatLayer for a Steam compatibiltiy tool.
+
+        path: the path to the folder containing 'toolmanifest.vdf'
+        shim: the path to umu's shim
+        resolve: whether to resolve the full chain of compatibility tools required to execute this tools correctly.
+        """
         self.tool_path = path.as_posix()
         with Path(path).joinpath("toolmanifest.vdf").open(encoding="utf-8") as f:
             self.tool_manifest = vdf.load(f)["manifest"]
 
-        self.runtime: CompatLayer | None = self._resolve(shim, resolve) if resolve else None
+        self.runtime: CompatLayer | None = self._resolve(shim, resolve=resolve) if resolve else None
 
         if path.joinpath("compatibilitytool.vdf").exists():
             with path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
@@ -480,14 +486,15 @@ class CompatLayer:
 
         self.shim = shim
 
-    def _resolve(self, shim: Path, resolve: bool) -> "CompatLayer | None":  # noqa: FBT001
+    def _resolve(self, shim: Path, *, resolve: bool) -> "CompatLayer | None":
         """Construct and provide the concrete CompatLayer this layer depends on."""
         if self.required_tool_appid is not None and self.required_runtime.path is not None:
-            return CompatLayer(self.required_runtime.path, shim, resolve)
+            return CompatLayer(self.required_runtime.path, shim, resolve=resolve)
         return None
 
     @property
-    def required_tool_appid(self) -> str | None:  # noqa: D102
+    def required_tool_appid(self) -> str | None:
+        """Report the appid of the tool this CompatLayer requires."""
         return str(ret) if (ret := self.tool_manifest.get("require_tool_appid")) else None
 
     @property
@@ -519,11 +526,13 @@ class CompatLayer:
         return None
 
     @property
-    def is_proton(self) -> bool:  # noqa: D102
+    def is_proton(self) -> bool:
+        """Report if this CompatLayer is a Proton."""
         return self.layer_name == "proton"
 
     @property
-    def display_name(self) -> str | None:  # noqa: D102
+    def display_name(self) -> str | None:
+        """Report the name of this CompatLayer as set in its manifest."""
         return str(ret) if (ret := self.compatibility_tool.get("display_name")) else None
 
     @property
@@ -531,7 +540,7 @@ class CompatLayer:
         """Report if the compatibility tool has a configured runtime."""
         return self.runtime is not None
 
-    def _command(self, verb: str) -> list[str]:
+    def _unwrapped_cmd(self, verb: str) -> list[str]:
         """Return the tool specific entry point."""
         tool_path = os.path.normpath(self.tool_path)
         cmd = "".join([shlex.quote(tool_path), self.tool_manifest["commandline"]])
@@ -541,14 +550,14 @@ class CompatLayer:
         cmd = cmd.replace("%verb%", verb)
         return shlex.split(cmd)
 
-    def command(self, verb: str) -> list[str]:
+    def _wrapped_cmd(self, verb: str) -> list[str]:
         """Return the fully qualified command for the runtime.
 
         If the runtime uses another runtime, its entry point is prepended to the local command.
         """
         log.info("Running '%s' using runtime '%s'", self.display_name, self.required_runtime.name)
-        cmd = self.runtime.command(verb) if self.runtime is not None else []
-        target = self._command(verb)
+        cmd = self.runtime.command(verb, unwrapped=False) if self.runtime is not None else []
+        target = self._unwrapped_cmd(verb)
         if self.layer_name in {"container-runtime"}:
             cmd.extend([*target, self.shim.as_posix()])
         elif self.runtime is None:
@@ -557,6 +566,12 @@ class CompatLayer:
             cmd.extend(target)
         return cmd
 
+    def command(self, verb:str, *, unwrapped: bool) -> list[str]:
+        """Return the tool's fully qualified (wrapped) or tool specific (unwrapped) entry point."""
+        if unwrapped:
+            return self._unwrapped_cmd(verb)
+        return self._wrapped_cmd(verb)
+
     def as_str(self, verb: str):  # noqa: D102
-        return " ".join(map(shlex.quote, self.command(verb)))
+        return " ".join(map(shlex.quote, self.command(verb, unwrapped=False)))
 
-- 
2.53.0


From d9dd4866cd980d3faf5db894f9472aaf1d7d16ca Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Wed, 26 Nov 2025 00:04:09 +0200
Subject: [PATCH 32/43] chore: remove some commented out code

---
 umu/umu_run.py | 20 --------------------
 1 file changed, 20 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 2268e94..b98cc39 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -321,20 +321,6 @@ def build_command(
     if opts is None:
         opts = []
 
-    # if env.get("UMU_NO_PROTON") != "1" and not proton.is_file():
-    #     err: str = "The following file was not found in PROTONPATH: proton"
-    #     raise FileNotFoundError(err)
-    #
-    # # Exit if the entry point is missing
-    # # The _v2-entry-point script and container framework tools are included in
-    # # the same image, so this can happen if the image failed to download
-    # if entry_point and not entry_point[0].is_file():
-    #     err: str = (
-    #         f"_v2-entry-point (umu) cannot be found in '{local}'\n"
-    #         "Runtime Platform missing or download incomplete"
-    #     )
-    #     raise FileNotFoundError(err)
-
     # Winetricks
     if layer.is_proton and env.get("EXE", "").endswith("winetricks") and opts:
         # The position of arguments matter for winetricks
@@ -346,12 +332,6 @@ def build_command(
             *opts,
         )
 
-    # # Will run the game within the Steam Runtime w/o Proton
-    # # Ideally, for reliability, executables should be compiled within
-    # # the Steam Runtime
-    # if env.get("UMU_NO_PROTON") == "1":
-    #     return *entry_point, env["EXE"], *opts
-
     nsenter: tuple[str, ...] = ()
     if launch_client := layer.launch_client:
         with Popen([launch_client, "--list"], stdout=PIPE, stderr=PIPE) as proc:
-- 
2.53.0


From 09f199209b7e34971c77ac7b34e45fa3cdaafd4c Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Wed, 26 Nov 2025 22:36:33 +0200
Subject: [PATCH 33/43] umu_runtime: resolve the runtime just-in-time

---
 umu/umu_run.py     |  8 ++++----
 umu/umu_runtime.py | 22 ++++++++++++++--------
 2 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index b98cc39..3da0c89 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -316,7 +316,7 @@ def build_command(
     env: dict[str, str],
     layer: CompatLayer,
     opts: list[str] | None = None,
-) -> tuple[Path | str, ...]:
+) -> tuple[str, ...]:
     """Build the command to be executed."""
     if opts is None:
         opts = []
@@ -714,7 +714,7 @@ def resolve_runtime() -> RuntimeVersion | None:
 
     toolmanifest = path.joinpath("toolmanifest.vdf")
     if toolmanifest.is_file():
-        layer = CompatLayer(toolmanifest.parent, Path(), resolve=False)
+        layer = CompatLayer(toolmanifest.parent, Path())
         runtime = layer.required_runtime
     else:
         err: str = f"PROTONPATH '{os.environ['PROTONPATH']}' is not valid, toolmanifest.vdf not found"
@@ -890,7 +890,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
             create_shim(UMU_LOCAL / "umu-shim")
 
         protonpath: Path = Path(env["PROTONPATH"]).expanduser().resolve(strict=True)
-        layer = CompatLayer(protonpath, UMU_LOCAL.joinpath("umu-shim"), resolve=True)
+        layer = CompatLayer(protonpath, UMU_LOCAL.joinpath("umu-shim"))
 
         # Prepare the prefix
         if layer.is_proton:
@@ -915,7 +915,7 @@ def umu_run(args: Namespace | tuple[str, list[str]]) -> int:
         sys.exit(1)
 
     # Build the command
-    command: tuple[Path | str, ...] = build_command(env, layer, opts)
+    command: tuple[str, ...] = build_command(env, layer, opts)
     log.debug("%s", command)
 
     # Run the command
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index d508dbc..534a107 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -462,7 +462,7 @@ RUNTIME_NAMES = {RUNTIME_VERSIONS[key].name: key for key in RUNTIME_VERSIONS}
 class CompatLayer:
     """Class to describe a Steam compatibility layer."""
 
-    def __init__(self, path: Path, shim: Path, *, resolve: bool) -> None:
+    def __init__(self, path: Path, shim: Path) -> None:
         """Create a CompatLayer for a Steam compatibiltiy tool.
 
         path: the path to the folder containing 'toolmanifest.vdf'
@@ -473,8 +473,6 @@ class CompatLayer:
         with Path(path).joinpath("toolmanifest.vdf").open(encoding="utf-8") as f:
             self.tool_manifest = vdf.load(f)["manifest"]
 
-        self.runtime: CompatLayer | None = self._resolve(shim, resolve=resolve) if resolve else None
-
         if path.joinpath("compatibilitytool.vdf").exists():
             with path.joinpath("compatibilitytool.vdf").open(encoding="utf-8") as f:
                 # There can be multiple tools definitions in `compatibilitytools.vdf`
@@ -484,14 +482,22 @@ class CompatLayer:
         else:
             self.compatibility_tool = {"display_name": path.name}
 
-        self.shim = shim
+        self._runtime: CompatLayer | None = None
+        self._shim = shim
 
-    def _resolve(self, shim: Path, *, resolve: bool) -> "CompatLayer | None":
+    def _resolve(self, shim: Path) -> "CompatLayer | None":
         """Construct and provide the concrete CompatLayer this layer depends on."""
         if self.required_tool_appid is not None and self.required_runtime.path is not None:
-            return CompatLayer(self.required_runtime.path, shim, resolve=resolve)
+            return CompatLayer(self.required_runtime.path, shim)
         return None
 
+    @property
+    def runtime(self) -> "CompatLayer | None":
+        """Test."""
+        if not self._runtime:
+            self._runtime = self._resolve(self._shim)
+        return self._runtime
+
     @property
     def required_tool_appid(self) -> str | None:
         """Report the appid of the tool this CompatLayer requires."""
@@ -559,9 +565,9 @@ class CompatLayer:
         cmd = self.runtime.command(verb, unwrapped=False) if self.runtime is not None else []
         target = self._unwrapped_cmd(verb)
         if self.layer_name in {"container-runtime"}:
-            cmd.extend([*target, self.shim.as_posix()])
+            cmd.extend([*target, self._shim.as_posix()])
         elif self.runtime is None:
-            cmd.extend([self.shim.as_posix(), *target])
+            cmd.extend([self._shim.as_posix(), *target])
         else:
             cmd.extend(target)
         return cmd
-- 
2.53.0


From a8ac1a864d95089cdacd99fd72a6a289137068aa Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 29 Nov 2025 00:21:44 +0200
Subject: [PATCH 34/43] umu_run: resolve paths again to satisfy the tests.

---
 umu/umu_run.py | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 3da0c89..9dd5991 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -64,7 +64,13 @@ RuntimeVersion = tuple[str, str, str]
 
 
 def setup_pfx(path: Path) -> None:
-    """Prepare a Proton compatible WINE prefix."""
+    """Prepare a Proton compatible WINE prefix.
+
+    `path` needs to be fully resolved before setup_pfx
+    """
+    if not path.is_absolute():
+        path = path.expanduser().resolve(strict=False)
+
     if not path.is_dir():
         path.mkdir(parents=True, exist_ok=True)
 
@@ -120,11 +126,12 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
             pfx: Path = Path.home().joinpath("Games", env["STORE"])
         else:
             pfx: Path = Path.home().joinpath("Games", "umu", env["GAMEID"])
+        pfx = pfx.resolve(strict=False)
     else:
-        pfx: Path = Path(os.environ["WINEPREFIX"]).expanduser()
+        pfx: Path = Path(os.environ["WINEPREFIX"]).expanduser().resolve(strict=False)
 
     if not pfx.is_absolute():
-        err: str = "WINEPREFIX is set but not an absolute path."
+        err: str = f"WINEPREFIX is set but not an absolute path: {pfx}."
         raise RuntimeError(err)
 
     os.environ["WINEPREFIX"] = str(pfx)
-- 
2.53.0


From e605764af4f069733f76e12fd1902a23894fd1f5 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 29 Nov 2025 14:03:59 +0200
Subject: [PATCH 35/43] umu_run: add temporary backwards compatibility with
 RUNTIMEPATH when resolving the required runtime

---
 umu/umu_run.py | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 9dd5991..d35c5ef 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -691,6 +691,16 @@ def run_command(command: tuple[Path | str, ...]) -> int:
 
 def resolve_runtime() -> RuntimeVersion | None:
     """Resolve the required runtime of a compatibility tool."""
+    # Backwards compatibility stuff, map RUNTIMEPATH tokens to
+    # umu's passthrough compatibility layers for runtimes.
+    runtimepath_compat = {
+        "steamrt2": "umu-soldier",
+        "steamrt3": "umu-sniper",
+        "steamrt4": "umu-steamrt4",
+    }
+    if os.environ.get("RUNTIMEPATH") and (os.environ.get("UMU_NO_PROTON") or not os.environ.get("PROTONPATH")):
+        os.environ["PROTONPATH"] = runtimepath_compat[os.environ.get("RUNTIMEPATH", "")]
+
     # default to UMU-Latest if PROTONPATH is not set
     if not os.environ.get("PROTONPATH"):
         os.environ["PROTONPATH"] = "UMU-Latest"
-- 
2.53.0


From 3882c272395742b10439dca449c872684350d9b7 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Wed, 26 Nov 2025 22:36:50 +0200
Subject: [PATCH 36/43] umu: update tests

---
 umu/umu_test.py         | 411 ++++++++++++++++++++++++----------------
 umu/umu_test_plugins.py |  92 +++++++--
 2 files changed, 319 insertions(+), 184 deletions(-)

diff --git a/umu/umu_test.py b/umu/umu_test.py
index e351923..a51b1b2 100644
--- a/umu/umu_test.py
+++ b/umu/umu_test.py
@@ -30,7 +30,7 @@ from Xlib.xobject.drawable import Window
 
 sys.path.append(str(Path(__file__).parent.parent))
 
-from umu import __main__, umu_proton, umu_run, umu_runtime, umu_util
+from umu import __main__, umu_proton, umu_run, umu_runtime, umu_util, vdf
 
 
 class TestGameLauncher(unittest.TestCase):
@@ -91,7 +91,7 @@ class TestGameLauncher(unittest.TestCase):
         # umu compat dir
         self.test_umu_compat = Path("./tmp.tu692WxQHH")
         # umu-proton dir
-        self.test_proton_dir = Path("UMU-Proton-5HYdpddgvs")
+        self.test_proton_dir = Path("./UMU-Proton-5HYdpddgvs")
         # umu-proton release
         self.test_archive = Path(self.test_cache).joinpath(
             f"{self.test_proton_dir}.tar.gz"
@@ -142,14 +142,55 @@ class TestGameLauncher(unittest.TestCase):
         Path(self.test_user_share, "run").touch()
         Path(self.test_user_share, "run-in-sniper").touch()
         Path(self.test_user_share, "umu").touch()
+        mock_steamrt_toolmanifest = {
+            "manifest": {
+                "commandline": "/_v2-entry-point --verb=%verb% --",
+                "filter_exclusive_priority": "3",
+                "version": "2",
+                "use_tool_subprocess_reaper": "1",
+                "compatmanager_layer_name": "container-runtime",
+            }
+        }
+        Path(self.test_user_share, "toolmanifest.vdf").write_text(vdf.dumps(mock_steamrt_toolmanifest))
 
         # Mock pressure vessel
         Path(self.test_user_share, "pressure-vessel", "bin").mkdir(parents=True)
         Path(self.test_user_share, "pressure-vessel", "foo").touch()
         Path(self.test_user_share, "pressure-vessel", "bin", "pv-verify").touch()
+        Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client").write_text(
+            "#!/bin/sh\nexec \"$@\"\n"
+        )
+        Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client").chmod(0o700)
 
         # Mock the proton file in the dir
         self.test_proton_dir.joinpath("proton").touch(exist_ok=True)
+        mock_proton_compatibilitytool = {
+            "compatibilitytools": {
+                "compat_tools": {
+                    self.test_proton_dir.name: {
+                        "install_path": ".",
+                        "display_name": self.test_proton_dir.name,
+                        "from_oslist": "windows",
+                        "to_oslist": "linux",
+                    }
+                }
+            }
+        }
+        self.test_proton_dir.joinpath("compatibilitytool.vdf").write_text(
+            vdf.dumps(mock_proton_compatibilitytool)
+        )
+        mock_proton_toolmanifest = {
+            "manifest": {
+                "version":"2",
+                "commandline": "/proton %verb%",
+                "require_tool_appid": "1628350",
+                "use_sessions": "1",
+                "compatmanager_layer_name": "proton",
+            }
+        }
+        self.test_proton_dir.joinpath("toolmanifest.vdf").write_text(
+            vdf.dumps(mock_proton_toolmanifest)
+        )
 
         # Mock the release downloaded in the cache:
         # tmp.5HYdpddgvs/umu-Proton-5HYdpddgvs.tar.gz
@@ -212,31 +253,25 @@ class TestGameLauncher(unittest.TestCase):
         in the compatibility tool's manifest.
         """
         result = None
-        mock_container_runtimes = (
-            ("sniper", "steamrt3", "1628350"),
-            ("soldier", "steamrt2", "1391110"),
-        )
         # A text file implementing the compatibility tool interface is expected
         # See https://gitlab.steamos.cloud/steamrt/steam-runtime-tools/-/blob/v0.20251103.0/docs/steam-compat-tool-interface.md?ref_type=tags
-        mock_manifest = (
-            '"manifest"\n'
-            "{\n"
-            '  "version" "2"\n'
-            '  "commandline" "/proton %verb%"\n'
-            '  "require_tool_appid" "769"\n'
-            '  "use_sessions" "1"\n'
-            '  "compatmanager_layer_name" "proton"\n'
-            "}"
-        )
+        mock_manifest = {
+            "manifest": {
+                "version": "2",
+                "commnadline": "/proton %verb%",
+                "require_tool_appid": "769",
+                "use_sessions": "1",
+                "compatmanager_layer_name": "proton",
+            }
+        }
 
         with TemporaryDirectory() as mock_proton:
             Path(mock_proton, "toolmanifest.vdf").write_text(
-                mock_manifest, encoding="utf-8"
-            )
-            result = umu_run.get_umu_version_from_manifest(
-                Path(mock_proton, "toolmanifest.vdf"), mock_container_runtimes
+                vdf.dumps(mock_manifest), encoding="utf-8"
             )
-            self.assertIsNone(result, f"Expected None, received '{result}'")
+            with self.assertRaises(KeyError):
+                result = umu_runtime.CompatLayer(Path(mock_proton), Path()).required_runtime
+                self.assertIsNone(result, f"Expected None, received '{result}'")
 
     def test_get_umu_version_from_manifest_noappid(self):
         """Test get_umu_version_from_manifest.
@@ -246,6 +281,7 @@ class TestGameLauncher(unittest.TestCase):
         exist.
         """
         mock_container_runtimes = (
+            ("host", "", ""),
             ("sniper", "steamrt3", "1628350"),
             ("soldier", "steamrt2", "1391110"),
         )
@@ -263,10 +299,8 @@ class TestGameLauncher(unittest.TestCase):
             Path(mock_proton, "toolmanifest.vdf").write_text(
                 mock_manifest, encoding="utf-8"
             )
-            result = umu_run.get_umu_version_from_manifest(
-                Path(mock_proton, "toolmanifest.vdf"), mock_container_runtimes
-            )
-            self.assertIsNone(result, f"Expected None, received '{result}'")
+            result = umu_runtime.CompatLayer(Path(mock_proton), Path()).required_runtime
+            self.assertEqual(result.as_tuple(), mock_container_runtimes[0], f"Expected None, received '{result}'")
 
     def test_get_umu_version_from_manifest(self):
         """Test get_umu_version_from_manifest.
@@ -293,11 +327,9 @@ class TestGameLauncher(unittest.TestCase):
             Path(mock_proton, "toolmanifest.vdf").write_text(
                 mock_manifest, encoding="utf-8"
             )
-            result = umu_run.get_umu_version_from_manifest(
-                Path(mock_proton, "toolmanifest.vdf"), mock_container_runtimes
-            )
+            result = umu_runtime.CompatLayer(Path(mock_proton), Path()).required_runtime
             self.assertEqual(
-                result,
+                result.as_tuple(),
                 mock_container_runtimes[0],
                 f"Expected '{mock_container_runtimes[0]}, received {result}'",
             )
@@ -308,10 +340,6 @@ class TestGameLauncher(unittest.TestCase):
         Expects None when a known, required runtime is not found in the
         compatibility tool's manifest.
         """
-        mock_container_runtimes = (
-            ("sniper", "steamrt3", "1628350"),
-            ("soldier", "steamrt2", "1391110"),
-        )
         mock_manifest = (
             '"manifest"\n'
             "{\n"
@@ -336,8 +364,9 @@ class TestGameLauncher(unittest.TestCase):
                 f"Expected None, received '{os.environ.get('UMU_NO_PROTON')}",
             )
             os.environ["PROTONPATH"] = mock_proton
-            result = umu_run.resolve_umu_version(mock_container_runtimes)
-            self.assertIsNone(result, f"Expected None, received '{result}'")
+            with self.assertRaises(KeyError):
+                result = umu_run.resolve_runtime()
+                self.assertIsNone(result, f"Expected None, received '{result}'")
 
     def test_resolve_umu_version_noproton(self):
         """Test resolve_umu_version when UMU_NO_PROTON is set.
@@ -361,14 +390,15 @@ class TestGameLauncher(unittest.TestCase):
             f"Expected None, received '{os.environ.get('PROTONPATH')}",
         )
         os.environ["UMU_NO_PROTON"] = "1"
-        result = umu_run.resolve_umu_version(mock_container_runtimes)
+        result = umu_run.resolve_runtime()
         self.assertEqual(
             result,
             mock_expected,
             f"Expected '{mock_expected}', received '{result}'",
         )
-        self.assertTrue(
-            result is mock_container_runtimes[0],
+        self.assertEqual(
+            result,
+            mock_container_runtimes[0],
             f"Expected the original instance '{result}'",
         )
 
@@ -396,14 +426,15 @@ class TestGameLauncher(unittest.TestCase):
             f"Expected None, received '{os.environ.get('UMU_NO_PROTON')}",
         )
         os.environ["PROTONPATH"] = "GE-Proton"
-        result = umu_run.resolve_umu_version(mock_container_runtimes)
+        result = umu_run.resolve_runtime()
         self.assertEqual(
             result,
             mock_expected,
             f"Expected '{mock_expected}', received '{result}'",
         )
-        self.assertTrue(
-            result is mock_container_runtimes[0],
+        self.assertEqual(
+            result,
+            mock_container_runtimes[0],
             f"Expected the original instance '{result}'",
         )
 
@@ -433,14 +464,15 @@ class TestGameLauncher(unittest.TestCase):
             "UMU_NO_PROTON" not in os.environ,
             f"Expected None, received '{os.environ.get('UMU_NO_PROTON')}",
         )
-        result = umu_run.resolve_umu_version(mock_container_runtimes)
+        result = umu_run.resolve_runtime()
         self.assertEqual(
             result,
             mock_container_runtimes[0],
             f"Expected '{mock_expected}', received None",
         )
-        self.assertTrue(
-            result is mock_container_runtimes[0],
+        self.assertEqual(
+            result,
+            mock_container_runtimes[0],
             f"Expected the original instance '{result}'",
         )
 
@@ -467,18 +499,20 @@ class TestGameLauncher(unittest.TestCase):
             f"Expected None, received '{os.environ.get('UMU_NO_PROTON')}",
         )
         os.environ["RUNTIMEPATH"] = "steamrt2"
-        result = umu_run.resolve_umu_version(mock_container_runtimes)
+        result = umu_run.resolve_runtime()
         self.assertEqual(
             result,
             mock_expected,
             f"Expected '{mock_expected}', received None",
         )
-        self.assertTrue(
-            result is mock_container_runtimes[1],
+        self.assertEqual(
+            result,
+            mock_container_runtimes[1],
             f"Expected the original instance '{result}'",
         )
-        self.assertTrue(
-            os.environ["RUNTIMEPATH"] in result,
+        self.assertEqual(
+            os.environ["RUNTIMEPATH"],
+            mock_container_runtimes[1][1],
             f"Expected '{os.environ['RUNTIMEPATH']}' in '{result}'",
         )
 
@@ -522,15 +556,15 @@ class TestGameLauncher(unittest.TestCase):
                 f"Expected None, received '{os.environ.get('UMU_NO_PROTON')}",
             )
             os.environ["PROTONPATH"] = mock_proton
-            result = umu_run.resolve_umu_version(mock_container_runtimes)
+            result = umu_runtime.CompatLayer(Path(os.environ["PROTONPATH"]), Path()).required_runtime
             self.assertEqual(
-                result,
+                result.as_tuple(),
                 mock_expected,
                 f"Expected '{mock_expected}', received None",
             )
             # Ensure the called function did not mutate the input
-            self.assertTrue(
-                result is mock_container_runtimes[0],
+            self.assertEqual(
+                result.as_tuple(), mock_container_runtimes[0],
                 f"Expected the original instance '{result}'",
             )
 
@@ -2227,7 +2261,7 @@ class TestGameLauncher(unittest.TestCase):
             # Config
             result_env, result_dl = umu_run.check_env(self.env)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, args)
 
@@ -2292,7 +2326,7 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, args)
 
@@ -2390,7 +2424,7 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, args)
 
@@ -2455,6 +2489,10 @@ class TestGameLauncher(unittest.TestCase):
         # Mock the proton file
         Path(self.test_file, "proton").touch()
 
+        # Mock the shim file
+        shim_path = Path(self.test_local_share_parent, "umu-shim")
+        shim_path.touch()
+
         with (
             patch("sys.argv", ["", self.test_exe]),
             ThreadPoolExecutor() as thread_pool,
@@ -2468,10 +2506,18 @@ class TestGameLauncher(unittest.TestCase):
             # Args
             result_args = __main__.parse_args()
             # Config
+            _ = umu_run.resolve_runtime()
+            # resolve_runtime's backwards compatibility is setting os.environ,
+            # copy it back to self.env
+            self.env["PROTONPATH"] = os.environ["PROTONPATH"]
+            with (
+                patch("umu.umu_proton.UMU_COMPAT", Path(self.test_file).resolve()),
+            ):
+                self.env = umu_proton._get_umu_runtime_tool(self.env, self.env["PROTONPATH"])
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result_args)
             # Game drive
@@ -2506,27 +2552,42 @@ class TestGameLauncher(unittest.TestCase):
                 Path(self.test_user_share, "umu"),
                 Path(self.test_local_share, "umu"),
             )
+            copy(
+                Path(self.test_user_share, "toolmanifest.vdf"),
+                Path(self.test_local_share, "toolmanifest.vdf"),
+            )
+            Path(self.test_local_share, "pressure-vessel").mkdir(exist_ok=True)
+            Path(self.test_local_share, "pressure-vessel", "bin").mkdir(exist_ok=True)
+            copy(
+                Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+                Path(self.test_local_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+            )
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_default[1])
+        mock_runtime = umu_runtime.UmuRuntime("sniper",  "steamrt3", "1628350", self.test_local_share)
+        with patch("umu.umu_runtime.CompatLayer.required_runtime", mock_runtime):
+            test_command = umu_run.build_command(
+                self.env, umu_runtime.CompatLayer(Path(self.env["PROTONPATH"]), shim_path)
+            )
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
         self.assertEqual(
             len(test_command),
-            5,
+            6,
             f"Expected 5 element, received {len(test_command)}",
         )
 
-        entry_point, opt, verb, sep, exe = [*test_command]
+        entry_point, verb, sep, shim, umutool, exe = [*test_command]
         self.assertEqual(
             entry_point,
-            self.test_local_share / "umu",
+            str(self.test_local_share / "umu"),
             "Expected an entry point",
         )
-        self.assertEqual(opt, "--verb", "Expected --verb")
-        self.assertEqual(verb, "waitforexitandrun", "Expected PROTON_VERB")
+        self.assertEqual(verb, f"--verb={self.test_verb}", "Expected PROTON_VERB")
         self.assertEqual(sep, "--", "Expected --")
+        self.assertEqual(shim, str(shim_path), "Expected path to umu")
+        self.assertEqual(umutool, str(Path(self.test_file, "umu-sniper", "entry-point").resolve()))
         self.assertEqual(exe, self.env["EXE"], "Expected the EXE")
 
     def test_build_command_nopv_appid(self):
@@ -2556,16 +2617,20 @@ class TestGameLauncher(unittest.TestCase):
             '''
         )
 
+        # Mock the shim file
+        shim_path = Path(self.test_local_share_parent, "umu-shim")
+        shim_path.touch()
+
         with (
             patch("sys.argv", ["", self.test_exe]),
             ThreadPoolExecutor() as thread_pool,
         ):
             os.environ["WINEPREFIX"] = self.test_file
-            os.environ["PROTONPATH"] = self.test_file
+            os.environ["PROTONPATH"] = str(self.test_proton_dir.resolve())
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_RUNTIME"] = "1"
-            version = umu_run.resolve_runtime(self.test_runtime_versions)
+            version = umu_run.resolve_runtime()
             os.environ["RUNTIMEPATH"] = version[1]
             # Args
             result_args = __main__.parse_args()
@@ -2574,7 +2639,7 @@ class TestGameLauncher(unittest.TestCase):
             if version[1]:
                 umu_run.download_proton(result_dl, self.env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result_args)
             # Game drive
@@ -2607,27 +2672,41 @@ class TestGameLauncher(unittest.TestCase):
                 Path(self.test_user_share, "umu"),
                 Path(self.test_local_share, "umu"),
             )
+            copy(
+                Path(self.test_user_share, "toolmanifest.vdf"),
+                Path(self.test_local_share, "toolmanifest.vdf"),
+            )
+            Path(self.test_local_share, "pressure-vessel").mkdir(exist_ok=True)
+            Path(self.test_local_share, "pressure-vessel", "bin").mkdir(exist_ok=True)
+            copy(
+                Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+                Path(self.test_local_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+            )
 
         os.environ |= self.env
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, version[1])
+        mock_runtime = umu_runtime.UmuRuntime("sniper",  "steamrt3", "1628350", self.test_local_share)
+        with patch("umu.umu_runtime.CompatLayer.required_runtime", mock_runtime):
+            test_command = umu_run.build_command(
+                self.env, umu_runtime.CompatLayer(Path(self.env["PROTONPATH"]), shim_path)
+            )
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
         self.assertEqual(
             len(test_command),
-            8,
-            f"Expected 3 elements, received {len(test_command)}",
+            7,
+            f"Expected 7 elements, received {len(test_command)}",
         )
-        _, _, verb, _, _, proton, _, exe = [*test_command]
-        self.assertIsInstance(proton, os.PathLike, "Expected proton to be PathLike")
+        _, verb, _, _, proton, _, exe = [*test_command]
+        self.assertIsInstance(proton, str, "Expected proton to be str")
         self.assertEqual(
             proton,
-            Path(self.env["PROTONPATH"], "proton"),
+            str(Path(self.env["PROTONPATH"], "proton")),
             "Expected PROTONPATH",
         )
-        self.assertEqual(verb, "waitforexitandrun", "Expected PROTON_VERB")
+        self.assertEqual(verb, "--verb=waitforexitandrun", "Expected PROTON_VERB")
         self.assertEqual(exe, self.env["EXE"], "Expected EXE")
 
     def test_build_command_nopv_noappid(self):
@@ -2645,27 +2724,29 @@ class TestGameLauncher(unittest.TestCase):
         Path(self.test_file, "proton").touch()
         # Mock a non-runtime toolmanifest.vdf
         Path(self.test_file, "toolmanifest.vdf").write_text(
-            '''
-            "manifest"
-            {
-              "version" "2"
-              "commandline" "/proton %verb%"
-              "use_sessions" "1"
-              "compatmanager_layer_name" "proton"
-            }
-            '''
+            vdf.dumps({
+                "manifest": {
+                    "version": "2",
+                    "commandline": "/proton %verb%",
+                    "use_sessions": "1",
+                    "compatmanager_layer_name": "proton",
+                }})
         )
 
+        # Mock the shim file
+        shim_path = Path(self.test_local_share_parent, "umu-shim")
+        shim_path.touch()
+
         with (
             patch("sys.argv", ["", self.test_exe]),
             ThreadPoolExecutor() as thread_pool,
         ):
             os.environ["WINEPREFIX"] = self.test_file
-            os.environ["PROTONPATH"] = self.test_file
+            os.environ["PROTONPATH"] = str(Path(self.test_file).resolve())
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["UMU_NO_RUNTIME"] = "1"
-            version = umu_run.resolve_runtime(self.test_runtime_versions)
+            version = umu_run.resolve_runtime()
             os.environ["RUNTIMEPATH"] = version[1]
             # Args
             result_args = __main__.parse_args()
@@ -2674,7 +2755,7 @@ class TestGameLauncher(unittest.TestCase):
             if version[1]:
                 umu_run.download_proton(result_dl, self.env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result_args)
             # Game drive
@@ -2711,20 +2792,22 @@ class TestGameLauncher(unittest.TestCase):
         os.environ |= self.env
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, version[1])
+        test_command = umu_run.build_command(
+            self.env, umu_runtime.CompatLayer(Path(self.env["PROTONPATH"]), shim_path)
+        )
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
         self.assertEqual(
             len(test_command),
             4,
-            f"Expected 3 elements, received {len(test_command)}",
+            f"Expected 4 elements, received {len(test_command)}",
         )
         _, proton, verb, exe, *_ = [*test_command]
-        self.assertIsInstance(proton, os.PathLike, "Expected proton to be PathLike")
+        self.assertIsInstance(proton, str, "Expected proton to be str")
         self.assertEqual(
             proton,
-            Path(self.env["PROTONPATH"], "proton"),
+            str(Path(self.env["PROTONPATH"], "proton")),
             "Expected PROTONPATH",
         )
         self.assertEqual(verb, "waitforexitandrun", "Expected PROTON_VERB")
@@ -2754,7 +2837,7 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result_args)
             # Mock setting UMU_NO_RUNTIME. This will not be set in the function
@@ -2767,7 +2850,7 @@ class TestGameLauncher(unittest.TestCase):
 
         # Since we didn't create the proton file, an exception should be raised
         with self.assertRaises(FileNotFoundError):
-            umu_run.build_command(self.env, self.test_local_share, self.test_runtime_default[1])
+            umu_run.build_command(self.env, umu_runtime.CompatLayer(Path(self.test_local_share), Path()))
 
     def test_build_command(self):
         """Test build command.
@@ -2792,8 +2875,8 @@ class TestGameLauncher(unittest.TestCase):
             patch("sys.argv", ["", self.test_exe]),
             ThreadPoolExecutor() as thread_pool,
         ):
-            os.environ["WINEPREFIX"] = self.test_file
-            os.environ["PROTONPATH"] = self.test_file
+            os.environ["WINEPREFIX"] = str(Path(self.test_file).resolve())
+            os.environ["PROTONPATH"] = str(self.test_proton_dir.resolve())
             os.environ["GAMEID"] = self.test_file
             os.environ["STORE"] = self.test_file
             os.environ["RUNTIMEPATH"] = self.test_runtime_default[1]
@@ -2803,7 +2886,7 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result_args)
             # Game drive
@@ -2839,32 +2922,45 @@ class TestGameLauncher(unittest.TestCase):
                 Path(self.test_user_share, "umu"),
                 Path(self.test_local_share, "umu"),
             )
+            copy(
+                Path(self.test_user_share, "toolmanifest.vdf"),
+                Path(self.test_local_share, "toolmanifest.vdf"),
+            )
+            Path(self.test_local_share, "pressure-vessel").mkdir(exist_ok=True)
+            Path(self.test_local_share, "pressure-vessel", "bin").mkdir(exist_ok=True)
+            copy(
+                Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+                Path(self.test_local_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+            )
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_default[1])
+        mock_runtime = umu_runtime.UmuRuntime("sniper",  "steamrt3", "1628350", self.test_local_share)
+        with patch("umu.umu_runtime.CompatLayer.required_runtime", mock_runtime):
+            test_command = umu_run.build_command(
+                self.env, umu_runtime.CompatLayer(Path(self.env["PROTONPATH"]), shim_path)
+            )
         self.assertIsInstance(
             test_command, tuple, "Expected a tuple from build_command"
         )
         self.assertEqual(
             len(test_command),
-            8,
-            f"Expected 8 elements, received {len(test_command)}",
+            7,
+            f"Expected 7 elements, received {len(test_command)}",
         )
-        entry_point, opt1, verb, opt2, shim, proton, verb2, exe = [*test_command]
+        entry_point, verb1, sep, shim, proton, verb2, exe = test_command
         # The entry point dest could change. Just check if there's a value
         self.assertTrue(entry_point, "Expected an entry point")
         self.assertIsInstance(
-            entry_point, os.PathLike, "Expected entry point to be PathLike"
-        )
-        self.assertEqual(opt1, "--verb", "Expected --verb")
-        self.assertEqual(verb, self.test_verb, "Expected a verb")
-        self.assertEqual(opt2, "--", "Expected --")
-        self.assertIsInstance(shim, os.PathLike, "Expected shim to be PathLike")
-        self.assertEqual(shim, shim_path, "Expected the shim file")
-        self.assertIsInstance(proton, os.PathLike, "Expected proton to be PathLike")
+            entry_point, str, "Expected entry point to be string"
+        )
+        self.assertEqual(verb1, f"--verb={self.test_verb}", "Expected a verb")
+        self.assertEqual(sep, "--", "Expected --")
+        self.assertIsInstance(shim, str, "Expected shim to be string")
+        self.assertEqual(shim, str(shim_path), "Expected the shim file")
+        self.assertIsInstance(proton, str, "Expected proton to be string")
         self.assertEqual(
             proton,
-            Path(self.env["PROTONPATH"], "proton"),
+            str(Path(self.env["PROTONPATH"], "proton")),
             "Expected the proton file",
         )
         self.assertEqual(verb2, self.test_verb, "Expected a verb")
@@ -2896,7 +2992,7 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
 
             # Env
             # Confirm that non-normalized paths were passed before setting
@@ -2907,10 +3003,10 @@ class TestGameLauncher(unittest.TestCase):
                 Path(self.test_exe).resolve(),
                 "Expected path to exe to be non-normalized",
             )
-            self.assertNotEqual(
+            self.assertEqual(
                 Path(os.environ["WINEPREFIX"]),
                 Path(os.environ["WINEPREFIX"]).resolve(),
-                "Expected path to exe to be non-normalized",
+                "Expected path to prefix to be normalized",
             )
             self.assertNotEqual(
                 Path(os.environ["PROTONPATH"]),
@@ -2978,7 +3074,7 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             result = umu_run.set_env(self.env, result[0:])
             self.assertTrue(result is self.env, "Expected the same reference")
@@ -3024,18 +3120,13 @@ class TestGameLauncher(unittest.TestCase):
             # Should be stripped -- everything after the hyphen
             self.assertEqual(
                 self.env["STEAM_COMPAT_APP_ID"],
-                umu_id[umu_id.find("-") + 1 :],
-                "Expected STEAM_COMPAT_APP_ID to be the stripped UMU_ID",
-            )
-            self.assertEqual(
-                self.env["SteamAppId"],
-                self.env["STEAM_COMPAT_APP_ID"],
-                "Expected SteamAppId to be STEAM_COMPAT_APP_ID",
+                hashlib.md5(self.env["WINEPREFIX"].encode("utf-8")).hexdigest(),  # noqa: S324
+                "Expected STEAM_COMPAT_APP_ID to be the md5 hashed WINEPREFIX",
             )
             self.assertEqual(
                 self.env["SteamGameId"],
                 self.env["SteamAppId"],
-                "Expected SteamGameId to be STEAM_COMPAT_APP_ID",
+                "Expected SteamGameId to be SteamAppId",
             )
 
             # PATHS
@@ -3087,17 +3178,17 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             self.assertNotEqual(
                 Path(self.test_exe),
                 Path(self.test_exe).resolve(),
                 "Expected path to exe to be non-normalized",
             )
-            self.assertNotEqual(
+            self.assertEqual(
                 Path(os.environ["WINEPREFIX"]),
                 Path(os.environ["WINEPREFIX"]).resolve(),
-                "Expected path to exe to be non-normalized",
+                "Expected path to prefix to be normalized",
             )
             self.assertNotEqual(
                 Path(os.environ["PROTONPATH"]),
@@ -3141,18 +3232,13 @@ class TestGameLauncher(unittest.TestCase):
             )
             self.assertEqual(
                 self.env["STEAM_COMPAT_APP_ID"],
-                "0",
+                hashlib.md5(self.env["WINEPREFIX"].encode("utf-8")).hexdigest(),  # noqa: S324
                 "Expected STEAM_COMPAT_APP_ID to be 0",
             )
-            self.assertEqual(
-                self.env["SteamAppId"],
-                self.env["STEAM_COMPAT_APP_ID"],
-                "Expected SteamAppId to be STEAM_COMPAT_APP_ID",
-            )
             self.assertEqual(
                 self.env["SteamGameId"],
                 self.env["SteamAppId"],
-                "Expected SteamGameId to be STEAM_COMPAT_APP_ID",
+                "Expected SteamGameId to be SteamAppId",
             )
 
             # PATHS
@@ -3204,17 +3290,17 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             self.assertNotEqual(
                 Path(self.test_exe),
                 Path(self.test_exe).resolve(),
                 "Expected path to exe to be non-normalized",
             )
-            self.assertNotEqual(
+            self.assertEqual(
                 Path(os.environ["WINEPREFIX"]),
                 Path(os.environ["WINEPREFIX"]).resolve(),
-                "Expected path to exe to be non-normalized",
+                "Expected path prefix to be normalized",
             )
             self.assertNotEqual(
                 Path(os.environ["PROTONPATH"]),
@@ -3263,18 +3349,13 @@ class TestGameLauncher(unittest.TestCase):
             )
             self.assertEqual(
                 self.env["STEAM_COMPAT_APP_ID"],
-                "0",
+                hashlib.md5(self.env["WINEPREFIX"].encode("utf-8")).hexdigest(),  # noqa: S324
                 "Expected STEAM_COMPAT_APP_ID to be 0",
             )
-            self.assertEqual(
-                self.env["SteamAppId"],
-                self.env["STEAM_COMPAT_APP_ID"],
-                "Expected SteamAppId to be STEAM_COMPAT_APP_ID",
-            )
             self.assertEqual(
                 self.env["SteamGameId"],
                 self.env["SteamAppId"],
-                "Expected SteamGameId to be STEAM_COMPAT_APP_ID",
+                "Expected SteamGameId to be SteamAppId",
             )
 
             # PATHS
@@ -3315,6 +3396,8 @@ class TestGameLauncher(unittest.TestCase):
 
         # Mock a Proton directory that contains winetricks
         test_dir = Path("./tmp.aCAs3Q7rvz")
+        if test_dir.exists():
+            rmtree(test_dir)
         test_dir.joinpath("protonfixes").mkdir(parents=True)
         test_dir.joinpath("protonfixes", "winetricks").touch()
 
@@ -3335,17 +3418,17 @@ class TestGameLauncher(unittest.TestCase):
             result_env, result_dl = umu_run.check_env(self.env)
             umu_run.download_proton(result_dl, result_env, thread_pool)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             self.assertNotEqual(
                 Path(test_exe),
                 Path(test_exe).resolve(),
                 "Expected path to exe to be non-normalized",
             )
-            self.assertNotEqual(
+            self.assertEqual(
                 Path(os.environ["WINEPREFIX"]),
                 Path(os.environ["WINEPREFIX"]).resolve(),
-                "Expected path to exe to be non-normalized",
+                "Expected path to prefix to be normalized",
             )
             self.assertNotEqual(
                 Path(os.environ["PROTONPATH"]),
@@ -3393,18 +3476,13 @@ class TestGameLauncher(unittest.TestCase):
             )
             self.assertEqual(
                 self.env["STEAM_COMPAT_APP_ID"],
-                "0",
-                "Expected STEAM_COMPAT_APP_ID to be 0",
-            )
-            self.assertEqual(
-                self.env["SteamAppId"],
-                self.env["STEAM_COMPAT_APP_ID"],
-                "Expected SteamAppId to be STEAM_COMPAT_APP_ID",
+                hashlib.md5(self.env["WINEPREFIX"].encode("utf-8")).hexdigest(),  # noqa: S324
+                "Expected STEAM_COMPAT_APP_ID to be the md5 hash WINEPREFIX",
             )
             self.assertEqual(
                 self.env["SteamGameId"],
                 self.env["SteamAppId"],
-                "Expected SteamGameId to be STEAM_COMPAT_APP_ID",
+                "Expected SteamGameId to be SteamAppId",
             )
 
             # PATHS
@@ -3435,7 +3513,7 @@ class TestGameLauncher(unittest.TestCase):
             )
 
         if test_dir.exists():
-            rmtree(test_dir.as_posix())
+            rmtree(test_dir)
 
     def test_setup_pfx_mv(self):
         """Test setup_pfx when moving the WINEPREFIX after creating it.
@@ -3451,7 +3529,7 @@ class TestGameLauncher(unittest.TestCase):
             "~",
             Path(self.test_file).cwd().joinpath(self.test_file).as_posix(),
         )
-        result = umu_run.setup_pfx(unexpanded_path)
+        result = umu_run.setup_pfx(Path(unexpanded_path))
 
         # Replaces the expanded path to unexpanded
         # Example: ~/some/path/to/this/file -> /home/foo/path/to/this/file
@@ -3502,7 +3580,7 @@ class TestGameLauncher(unittest.TestCase):
             "steamuser"
         ).expanduser().symlink_to(Path(self.test_file).absolute())
 
-        result = umu_run.setup_pfx(unexpanded_path)
+        result = umu_run.setup_pfx(Path(unexpanded_path))
 
         self.assertIsNone(
             result,
@@ -3530,7 +3608,7 @@ class TestGameLauncher(unittest.TestCase):
             self.user
         ).expanduser().mkdir(parents=True, exist_ok=True)
 
-        result = umu_run.setup_pfx(unexpanded_path)
+        result = umu_run.setup_pfx(Path(unexpanded_path))
 
         self.assertIsNone(
             result,
@@ -3570,7 +3648,7 @@ class TestGameLauncher(unittest.TestCase):
             parents=True, exist_ok=True
         )
 
-        result = umu_run.setup_pfx(unexpanded_path)
+        result = umu_run.setup_pfx(Path(unexpanded_path))
 
         self.assertIsNone(
             result,
@@ -3617,7 +3695,7 @@ class TestGameLauncher(unittest.TestCase):
             "~",
             Path(self.test_file).cwd().joinpath(self.test_file).as_posix(),
         )
-        result = umu_run.setup_pfx(unexpanded_path)
+        result = umu_run.setup_pfx(Path(unexpanded_path))
 
         # Replaces the expanded path to unexpanded
         # Example: ~/some/path/to/this/file -> /home/foo/path/to/this/file
@@ -3655,7 +3733,7 @@ class TestGameLauncher(unittest.TestCase):
             "~",
             Path(self.test_file).as_posix(),
         )
-        result = umu_run.setup_pfx(unexpanded_path)
+        result = umu_run.setup_pfx(Path(unexpanded_path))
 
         # Replaces the expanded path to unexpanded
         # Example: ~/some/path/to/this/file -> /home/foo/path/to/this/file
@@ -3675,10 +3753,11 @@ class TestGameLauncher(unittest.TestCase):
 
     def test_setup_pfx_noproton(self):
         """Test setup_pfx when configured to not use Proton."""
+        self.skipTest("setup_pfx() is not called for non-proton tools")
         result = None
         os.environ["UMU_NO_PROTON"] = "1"
 
-        result = umu_run.setup_pfx(self.test_file)
+        result = umu_run.setup_pfx(Path(self.test_file))
         self.assertTrue(result is None, f"Expected None, received {result}")
         self.assertFalse(
             Path(self.test_file, "pfx").exists(),
@@ -3704,7 +3783,7 @@ class TestGameLauncher(unittest.TestCase):
             Path(self.test_file).resolve(),
             "Expected path to be non-normalized",
         )
-        result = umu_run.setup_pfx(self.test_file)
+        result = umu_run.setup_pfx(Path(self.test_file))
         self.assertIsNone(
             result,
             "Expected None when creating symbolic link to WINE prefix and "
@@ -3752,6 +3831,7 @@ class TestGameLauncher(unittest.TestCase):
 
         A SystemExit should be raised in this usage: ./umu_run.py
         """
+        self.skipTest("Exits cleanly")
         with self.assertRaises(SystemExit):
             __main__.parse_args()
 
@@ -3934,10 +4014,11 @@ class TestGameLauncher(unittest.TestCase):
             umu_run.download_proton(result_dl, result_env, thread_pool)
 
         # After this, the WINEPREFIX and new dirs should be created
-        self.assertTrue(
-            Path(self.env["WINEPREFIX"]).exists(),
-            "Expected WINEPREFIX to exist after check_env",
-        )
+        # Update; the prefix is created in setup_pfx
+        # self.assertTrue(
+        #     Path(self.env["WINEPREFIX"]).exists(),
+        #     "Expected WINEPREFIX to exist after check_env",
+        # )
         self.assertEqual(
             self.env["WINEPREFIX"],
             os.environ["WINEPREFIX"],
@@ -3972,7 +4053,7 @@ class TestGameLauncher(unittest.TestCase):
         self.assertTrue(result_env is self.env, "Expected the same reference")
         self.assertEqual(
             self.env["WINEPREFIX"],
-            unexpanded_path,
+            Path(unexpanded_path).expanduser().resolve(strict=True).as_posix(),
             "Expected WINEPREFIX to be set",
         )
         self.assertEqual(
@@ -3998,7 +4079,7 @@ class TestGameLauncher(unittest.TestCase):
         self.assertTrue(result_env is self.env, "Expected the same reference")
         self.assertEqual(
             self.env["WINEPREFIX"],
-            self.test_file,
+            Path(self.test_file).expanduser().resolve(strict=True).as_posix(),
             "Expected WINEPREFIX to be set",
         )
         self.assertEqual(
diff --git a/umu/umu_test_plugins.py b/umu/umu_test_plugins.py
index d3463b6..a31a180 100644
--- a/umu/umu_test_plugins.py
+++ b/umu/umu_test_plugins.py
@@ -13,7 +13,7 @@ from tomllib import TOMLDecodeError
 
 sys.path.append(str(Path(__file__).parent.parent))
 
-from umu import __main__, umu_plugins, umu_run, umu_runtime
+from umu import __main__, umu_plugins, umu_run, umu_runtime, vdf
 
 
 class TestGameLauncherPlugins(unittest.TestCase):
@@ -92,10 +92,26 @@ class TestGameLauncherPlugins(unittest.TestCase):
         Path(self.test_user_share, "run").touch()
         Path(self.test_user_share, "run-in-sniper").touch()
         Path(self.test_user_share, "umu").touch()
+        mock_steamrt_toolmanifest = {
+            "manifest": {
+                "commandline": "/_v2-entry-point --verb=%verb% --",
+                "filter_exclusive_priority": "3",
+                "version": "2",
+                "use_tool_subprocess_reaper": "1",
+                "compatmanager_layer_name": "container-runtime",
+            }
+        }
+        Path(self.test_user_share, "toolmanifest.vdf").write_text(vdf.dumps(mock_steamrt_toolmanifest))
 
         # Mock pressure vessel
         Path(self.test_user_share, "pressure-vessel").mkdir()
         Path(self.test_user_share, "pressure-vessel", "foo").touch()
+        Path(self.test_user_share, "pressure-vessel", "bin").mkdir()
+        Path(self.test_user_share, "pressure-vessel", "bin", "pv-verify").touch()
+        Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client").write_text(
+            "#!/bin/sh\nexec \"$@\"\n"
+        )
+        Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client").chmod(0o700)
 
         # Mock umu-launcher
         Path(self.test_user_share, "umu-launcher").mkdir()
@@ -170,7 +186,6 @@ class TestGameLauncherPlugins(unittest.TestCase):
         """
         toml_path = self.test_file + "/" + test_toml
         result = None
-        test_command = []
         Path(toml_path).touch()
 
         # Mock the proton file
@@ -190,7 +205,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
             # Config
             umu_plugins.set_env_toml(self.env, result)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result)
             # Game drive
@@ -225,8 +240,8 @@ class TestGameLauncherPlugins(unittest.TestCase):
             os.environ[key] = val
 
         # Build
-        with self.assertRaisesRegex(FileNotFoundError, "_v2-entry-point"):
-            umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1], test_command)
+        with self.assertRaisesRegex(FileNotFoundError, "toolmanifest.vdf"):
+            umu_run.build_command(self.env, umu_runtime.CompatLayer(Path(self.test_local_share_parent), Path()))
 
     def test_build_command_proton(self):
         """Test build_command.
@@ -248,7 +263,6 @@ class TestGameLauncherPlugins(unittest.TestCase):
         """
         toml_path = self.test_file + "/" + test_toml
         result = None
-        test_command = []
         Path(toml_path).touch()
 
         with Path(toml_path).open(mode="w", encoding="utf-8") as file:
@@ -265,7 +279,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
             # Config
             umu_plugins.set_env_toml(self.env, result)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result)
             # Game drive
@@ -303,8 +317,8 @@ class TestGameLauncherPlugins(unittest.TestCase):
             os.environ[key] = val
 
         # Build
-        with self.assertRaisesRegex(FileNotFoundError, "proton"):
-            umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1], test_command)
+        with self.assertRaisesRegex(FileNotFoundError, "toolmanifest.vdf"):
+            umu_run.build_command(self.env, umu_runtime.CompatLayer(Path(self.test_local_share_parent), Path()))
 
     def test_build_command_toml(self):
         """Test build_command.
@@ -327,6 +341,33 @@ class TestGameLauncherPlugins(unittest.TestCase):
 
         Path(self.test_file + "/proton").touch()
         Path(toml_path).touch()
+        mock_compatibilitytool = {
+            "compatibilitytools": {
+                "compat_tools": {
+                    self.test_proton_dir.name: {
+                        "install_path": ".",
+                        "display_name": self.test_proton_dir.name,
+                        "from_oslist": "windows",
+                        "to_oslist": "linux",
+                    }
+                }
+            }
+        }
+        Path(self.test_file + "/compatibilitytool.vdf").write_text(
+            vdf.dumps(mock_compatibilitytool)
+        )
+        mock_toolmanifest = {
+            "manifest": {
+                "version":"2",
+                "commandline": "/proton %verb%",
+                "require_tool_appid": "1628350",
+                "use_sessions": "1",
+                "compatmanager_layer_name": "proton",
+            }
+        }
+        Path(self.test_file + "/toolmanifest.vdf").write_text(
+            vdf.dumps(mock_toolmanifest)
+        )
 
         # Mock the shim file
         shim_path = Path(self.test_local_share_parent, "umu-shim")
@@ -346,7 +387,7 @@ class TestGameLauncherPlugins(unittest.TestCase):
             # Config
             umu_plugins.set_env_toml(self.env, result)
             # Prefix
-            umu_run.setup_pfx(self.env["WINEPREFIX"])
+            umu_run.setup_pfx(Path(self.env["WINEPREFIX"]))
             # Env
             umu_run.set_env(self.env, result)
             # Game drive
@@ -379,29 +420,42 @@ class TestGameLauncherPlugins(unittest.TestCase):
                 Path(self.test_user_share, "umu"),
                 Path(self.test_local_share, "umu"),
             )
+            copy(
+                Path(self.test_user_share, "toolmanifest.vdf"),
+                Path(self.test_local_share, "toolmanifest.vdf"),
+            )
+            Path(self.test_local_share, "pressure-vessel").mkdir(exist_ok=True)
+            Path(self.test_local_share, "pressure-vessel", "bin").mkdir(exist_ok=True)
+            copy(
+                Path(self.test_user_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+                Path(self.test_local_share, "pressure-vessel", "bin", "steam-runtime-launch-client"),
+            )
 
         for key, val in self.env.items():
             os.environ[key] = val
 
         # Build
-        test_command = umu_run.build_command(self.env, self.test_local_share_parent, self.test_runtime_version[1])
+        mock_runtime = umu_runtime.UmuRuntime("sniper",  "steamrt3", "1628350", self.test_local_share)
+        with patch("umu.umu_runtime.CompatLayer.required_runtime", mock_runtime):
+            test_command = umu_run.build_command(
+                self.env, umu_runtime.CompatLayer(Path(self.env["PROTONPATH"]), shim_path)
+            )
 
         # Verify contents of the command
-        entry_point, opt1, verb, opt2, shim, proton, verb2, exe = [*test_command]
+        entry_point, verb, opt2, shim, proton, verb2, exe = [*test_command]
         # The entry point dest could change. Just check if there's a value
         self.assertTrue(entry_point, "Expected an entry point")
         self.assertIsInstance(
-            entry_point, os.PathLike, "Expected entry point to be PathLike"
+            entry_point, str, "Expected entry point to be str"
         )
-        self.assertEqual(opt1, "--verb", "Expected --verb")
-        self.assertEqual(verb, self.test_verb, "Expected a verb")
+        self.assertEqual(verb, "--verb=waitforexitandrun", "Expected a verb")
         self.assertEqual(opt2, "--", "Expected --")
-        self.assertIsInstance(shim, os.PathLike, "Expected shim to be PathLike")
-        self.assertEqual(shim, shim_path, "Expected the shim file")
-        self.assertIsInstance(proton, os.PathLike, "Expected proton to be PathLike")
+        self.assertIsInstance(shim, str, "Expected shim to be str")
+        self.assertEqual(shim, str(shim_path), "Expected the shim file")
+        self.assertIsInstance(proton, str, "Expected proton to be str")
         self.assertEqual(
             proton,
-            Path(self.env["PROTONPATH"], "proton"),
+            str(Path(self.env["PROTONPATH"], "proton")),
             "Expected the proton file",
         )
         self.assertEqual(verb2, self.test_verb, "Expected a verb")
-- 
2.53.0


From 9892e2e7658810829227aa541bb736f9764c22e8 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Mon, 24 Nov 2025 17:17:29 +0200
Subject: [PATCH 37/43] umu: add arm64 sniper runtime

---
 umu/umu_proton.py  |  2 ++
 umu/umu_run.py     |  7 ++++++-
 umu/umu_runtime.py | 10 ++++++----
 3 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index ff954e3..4f63d0d 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -56,6 +56,7 @@ class ProtonVersion(Enum):
     UMUScout = "umu-scout"
     UMUSoldier = "umu-soldier"
     UMUSniper = "umu-sniper"
+    UMUSniper_arm64 = "umu-sniper-arm64"
     UMUSteamRT4 = "umu-steamrt4"
 
 
@@ -114,6 +115,7 @@ def _get_umu_runtime_tool(env: dict[str, str], name: str) -> dict[str, str] | No
     if not (name and name in {
         ProtonVersion.UMUSoldier.value,
         ProtonVersion.UMUSniper.value,
+        ProtonVersion.UMUSniper_arm64.value,
         ProtonVersion.UMUSteamRT4.value
     }):
         return None
diff --git a/umu/umu_run.py b/umu/umu_run.py
index d35c5ef..eb359b0 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -149,7 +149,11 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
 
     # Proton Codename
     if os.environ.get("PROTONPATH") in {
-        "GE-Proton", "GE-Latest", "UMU-Latest", "umu-scout", "umu-soldier", "umu-sniper", "umu-steamrt4"
+        "GE-Proton", "GE-Latest", "UMU-Latest",
+        "umu-scout",
+        "umu-soldier",
+        "umu-sniper", "umu-sniper-arm64",
+        "umu-steamrt4"
     }:
         do_download = True
 
@@ -708,6 +712,7 @@ def resolve_runtime() -> RuntimeVersion | None:
     named_runtimes = {
         RUNTIME_NAMES["steamrt4"]: {"umu-steamrt4"},
         RUNTIME_NAMES["sniper"]: {"GE-Proton", "GE-Latest", "UMU-Latest", "umu-sniper"},
+        RUNTIME_NAMES["sniper-arm64"]: {"umu-sniper-arm64"},
         RUNTIME_NAMES["soldier"]: {"umu-scout", "umu-soldier"},
     }
 
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 534a107..d2b7d6e 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -449,10 +449,12 @@ class UmuRuntime:
 
 
 RUNTIME_VERSIONS = {
-    "host":    UmuRuntime("host",    ""        , ""   ),
-    "1391110": UmuRuntime("soldier", "steamrt2", "1391110"),
-    "1628350": UmuRuntime("sniper",  "steamrt3", "1628350"),
-    "4183110": UmuRuntime("steamrt4","steamrt4", "4183110"),
+    "host": UmuRuntime("host", "", ""),
+    "1391110": UmuRuntime("soldier",      "steamrt2", "1391110"),
+    "1628350": UmuRuntime("sniper",       "steamrt3", "1628350"),
+    "3810310": UmuRuntime("sniper-arm64", "steamrt3", "3810310"),
+    "4183110": UmuRuntime("steamrt4",     "steamrt4", "4183110"),
+    # "4183110": UmuRuntime("steamrt4-arm64", "steamrt4", "4183110"),
 }
 
 
-- 
2.53.0


From 8910736dbca764298a51774d28031b5b397f1678 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Mon, 29 Dec 2025 14:09:08 +0200
Subject: [PATCH 38/43] umu: add steamrt4 arm64

---
 umu/umu_proton.py  |  4 +++-
 umu/umu_run.py     |  3 ++-
 umu/umu_runtime.py | 22 +++++++++++++++++-----
 3 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index 4f63d0d..898a869 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -58,6 +58,7 @@ class ProtonVersion(Enum):
     UMUSniper = "umu-sniper"
     UMUSniper_arm64 = "umu-sniper-arm64"
     UMUSteamRT4 = "umu-steamrt4"
+    UMUSteamRT4_arm64 = "umu-steamrt4-arm64"
 
 
 def get_umu_proton(env: dict[str, str], session_pools: SessionPools) -> dict[str, str]:
@@ -116,7 +117,8 @@ def _get_umu_runtime_tool(env: dict[str, str], name: str) -> dict[str, str] | No
         ProtonVersion.UMUSoldier.value,
         ProtonVersion.UMUSniper.value,
         ProtonVersion.UMUSniper_arm64.value,
-        ProtonVersion.UMUSteamRT4.value
+        ProtonVersion.UMUSteamRT4.value,
+        ProtonVersion.UMUSteamRT4_arm64.value,
     }):
         return None
 
diff --git a/umu/umu_run.py b/umu/umu_run.py
index eb359b0..8a6086f 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -153,7 +153,7 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
         "umu-scout",
         "umu-soldier",
         "umu-sniper", "umu-sniper-arm64",
-        "umu-steamrt4"
+        "umu-steamrt4", "umu-steamrt4-arm64",
     }:
         do_download = True
 
@@ -711,6 +711,7 @@ def resolve_runtime() -> RuntimeVersion | None:
 
     named_runtimes = {
         RUNTIME_NAMES["steamrt4"]: {"umu-steamrt4"},
+        RUNTIME_NAMES["steamrt4-arm64"]: {"umu-steamrt4-arm64"},
         RUNTIME_NAMES["sniper"]: {"GE-Proton", "GE-Latest", "UMU-Latest", "umu-sniper"},
         RUNTIME_NAMES["sniper-arm64"]: {"umu-sniper-arm64"},
         RUNTIME_NAMES["soldier"]: {"umu-scout", "umu-soldier"},
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index d2b7d6e..1c3fac9 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -1,4 +1,5 @@
 import os
+import platform
 import shlex
 from collections.abc import Callable
 from concurrent.futures import ThreadPoolExecutor
@@ -450,13 +451,24 @@ class UmuRuntime:
 
 RUNTIME_VERSIONS = {
     "host": UmuRuntime("host", "", ""),
-    "1391110": UmuRuntime("soldier",      "steamrt2", "1391110"),
-    "1628350": UmuRuntime("sniper",       "steamrt3", "1628350"),
-    "3810310": UmuRuntime("sniper-arm64", "steamrt3", "3810310"),
-    "4183110": UmuRuntime("steamrt4",     "steamrt4", "4183110"),
-    # "4183110": UmuRuntime("steamrt4-arm64", "steamrt4", "4183110"),
 }
 
+RUNTIME_VERSIONS.update({
+    "1391110": UmuRuntime("soldier",        "steamrt2", "1391110"),
+    "1628350": UmuRuntime("sniper",         "steamrt3", "1628350"),
+    "3810310": UmuRuntime("sniper-arm64",   "steamrt3", "3810310"),
+    "4183110": UmuRuntime("steamrt4",       "steamrt4", "4183110"),
+    "4185400": UmuRuntime("steamrt4-arm64", "steamrt4", "4185400"),
+})
+
+if platform.machine() == "x86_64":  # noqa: SIM114
+    pass
+elif platform.machine() == "aarch64":
+    pass
+else:
+    err: str = f"Unsupported platform {platform.machine()}"
+    raise RuntimeError(err)
+
 
 RUNTIME_NAMES = {RUNTIME_VERSIONS[key].name: key for key in RUNTIME_VERSIONS}
 
-- 
2.53.0


From 6234b1f978016dfda8af6f71305fb65e9b16ec05 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Sat, 31 Jan 2026 13:32:13 +0200
Subject: [PATCH 39/43] umu_runtime: fix steamrt4-arm64 download

---
 umu/umu_runtime.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 1c3fac9..3f76587 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -80,7 +80,7 @@ def _install_umu(
     token: str = f"?versions={token_urlsafe(16)}"
     host: str = "repo.steampowered.com"
 
-    if codename.removeprefix("steamrt").isdigit():
+    if codename.removeprefix("steamrt").removesuffix("-arm64").isdigit():
         archive = f"SteamLinuxRuntime_{codename.removeprefix('steamrt')}.tar.xz"
     else:
         archive = f"SteamLinuxRuntime_{codename}.tar.xz"
-- 
2.53.0


From cb5d6cac81a9521a51d3e7325cf71a169c3eba69 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Mon, 2 Feb 2026 11:24:00 +0200
Subject: [PATCH 40/43] umu_runtime: fix steamrt4-arm64 validation

---
 umu/umu_runtime.py | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index 3f76587..d8c32d2 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -284,6 +284,7 @@ def _update_umu(
 
     # Find the runtime directory (e.g., sniper_platform_0.20240530.90143)
     # Assume the directory begins with the variant
+    codename = codename.removesuffix("-arm64")
     try:
         max(file for file in local.glob(f"{codename}*") if file.is_dir())
     except ValueError:
@@ -349,6 +350,7 @@ def check_runtime(src: Path, runtime_ver: RuntimeVersion) -> int:
     ret: int = 1
 
     # Find the runtime directory
+    codename = codename.removesuffix("-arm64")
     try:
         runtime = max(file for file in src.glob(f"{codename}*") if file.is_dir())
     except ValueError:
-- 
2.53.0


From 21197ce03d44091d8641ba16012f83089cf45202 Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 10 Feb 2026 20:17:56 +0200
Subject: [PATCH 41/43] umu_run: filter known bad values for STORE

---
 umu/umu_run.py | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/umu/umu_run.py b/umu/umu_run.py
index 8a6086f..1591f5e 100755
--- a/umu/umu_run.py
+++ b/umu/umu_run.py
@@ -121,8 +121,14 @@ def check_env(env: dict[str, str]) -> tuple[dict[str, str] | dict[str, Any], boo
         err: str = "Environment variable is empty: WINEPREFIX"
         raise ValueError(err)
 
+    env["STORE"] = os.environ.get("STORE", "")
     if "WINEPREFIX" not in os.environ:
-        if "STORE" in os.environ:
+        # Do not use the per-store prefix path in case STORE is either an empty string or "none"
+        # The "none" special case is here to work-around Lutris's defaults
+        # https://github.com/lutris/lutris/blob/2c3b3e0d543ec736df7dd2c313bd471ce8d77c33/lutris/game.py#L672-L678
+        # which caused the default prefix to use an unexpected path in some cases
+        # https://github.com/CachyOS/CachyOS-PKGBUILDS/issues/1124
+        if "STORE" in os.environ and env["STORE"] not in {"", "none"}:
             pfx: Path = Path.home().joinpath("Games", env["STORE"])
         else:
             pfx: Path = Path.home().joinpath("Games", "umu", env["GAMEID"])
-- 
2.53.0


From bd332b91ee77e93f356c1aaca3f718b545a156fb Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 10 Feb 2026 21:24:29 +0200
Subject: [PATCH 42/43] umu_runtime: use different variants for arm64 runtimes

this changes how the runtime is stored under `~/.local/share/umu`,
instead of using the same folder for both architectures, the runtimes
are not stored like this
```
umu-sniper: .local/share/umu/steamrt3
umu-sniper-arm64: .local/share/umu/steamrt3-arm64
umu-steamrt4: .local/share/umu/steamrt4
umu-steamrt4-arm64: .local/share/umu/steamrt4-arm64
```
---
 umu/umu_runtime.py | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index d8c32d2..ec460b6 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -76,7 +76,7 @@ def _install_umu(
     ret: int = 0  # Exit code from zenity
     thread_pool, http_pool = session_pools
     codename, variant, _ = runtime_ver
-    base_url: str = f"https://repo.steampowered.com/{variant}/images/latest-public-beta"
+    base_url: str = f"https://repo.steampowered.com/{variant.removesuffix('-arm64')}/images/latest-public-beta/"
     token: str = f"?versions={token_urlsafe(16)}"
     host: str = "repo.steampowered.com"
 
@@ -110,7 +110,7 @@ def _install_umu(
     if not os.environ.get("UMU_ZENITY") or ret:
         digest: str = ""
         buildid: str = ""
-        endpoint: str = f"/{variant}/images/latest-public-beta"
+        endpoint: str = f"/{variant.removesuffix('-arm64')}/images/latest-public-beta"
         hashsum = sha256()
         headers: dict[str, str] | None = None
         cached_parts: Path
@@ -272,7 +272,7 @@ def _update_umu(
     resp: BaseHTTPResponse
     _, http_pool = session_pools
     codename, variant, _ = runtime_ver
-    endpoint: str = f"/{variant}/images/latest-public-beta"
+    endpoint: str = f"/{variant.removesuffix('-arm64')}/images/latest-public-beta"
     # Create a token and append it to the URL to avoid the Cloudflare cache
     # Avoids infinite updates to the runtime each launch
     # See https://github.com/Open-Wine-Components/umu-launcher/issues/188
@@ -456,11 +456,11 @@ RUNTIME_VERSIONS = {
 }
 
 RUNTIME_VERSIONS.update({
-    "1391110": UmuRuntime("soldier",        "steamrt2", "1391110"),
-    "1628350": UmuRuntime("sniper",         "steamrt3", "1628350"),
-    "3810310": UmuRuntime("sniper-arm64",   "steamrt3", "3810310"),
-    "4183110": UmuRuntime("steamrt4",       "steamrt4", "4183110"),
-    "4185400": UmuRuntime("steamrt4-arm64", "steamrt4", "4185400"),
+    "1391110": UmuRuntime("soldier",        "steamrt2",       "1391110"),
+    "1628350": UmuRuntime("sniper",         "steamrt3",       "1628350"),
+    "3810310": UmuRuntime("sniper-arm64",   "steamrt3-arm64", "3810310"),
+    "4183110": UmuRuntime("steamrt4",       "steamrt4",       "4183110"),
+    "4185400": UmuRuntime("steamrt4-arm64", "steamrt4-arm64", "4185400"),
 })
 
 if platform.machine() == "x86_64":  # noqa: SIM114
-- 
2.53.0


From 3a38eff86fb300dd44a1a9418f71de360347527f Mon Sep 17 00:00:00 2001
From: Stelios Tsampas <loathingkernel@gmail.com>
Date: Tue, 10 Feb 2026 21:34:40 +0200
Subject: [PATCH 43/43] chore: silence ruff

---
 umu/umu_proton.py  | 2 +-
 umu/umu_runtime.py | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/umu/umu_proton.py b/umu/umu_proton.py
index 898a869..e26d32a 100644
--- a/umu/umu_proton.py
+++ b/umu/umu_proton.py
@@ -240,7 +240,7 @@ def _fetch_releases(
     }:
         repo = "/repos/GloriousEggroll/proton-ge-custom/releases/latest"
 
-    if os.environ.get("PROTONPATH") in {ProtonVersion.UMUScout.value}:
+    if os.environ.get("PROTONPATH") == ProtonVersion.UMUScout.value:
         repo = "/repos/loathingKernel/umu-scout/releases/latest"
 
     resp = http_pool.request(HTTPMethod.GET.value, f"{url}{repo}", headers=headers)
diff --git a/umu/umu_runtime.py b/umu/umu_runtime.py
index ec460b6..c4fb1d7 100644
--- a/umu/umu_runtime.py
+++ b/umu/umu_runtime.py
@@ -567,7 +567,7 @@ class CompatLayer:
         tool_path = os.path.normpath(self.tool_path)
         cmd = "".join([shlex.quote(tool_path), self.tool_manifest["commandline"]])
         # Temporary override entry point for backwards compatibility
-        if self.layer_name in {"container-runtime"}:
+        if self.layer_name == "container-runtime":
             cmd = cmd.replace("_v2-entry-point", "umu")
         cmd = cmd.replace("%verb%", verb)
         return shlex.split(cmd)
@@ -580,7 +580,7 @@ class CompatLayer:
         log.info("Running '%s' using runtime '%s'", self.display_name, self.required_runtime.name)
         cmd = self.runtime.command(verb, unwrapped=False) if self.runtime is not None else []
         target = self._unwrapped_cmd(verb)
-        if self.layer_name in {"container-runtime"}:
+        if self.layer_name == "container-runtime":
             cmd.extend([*target, self._shim.as_posix()])
         elif self.runtime is None:
             cmd.extend([self._shim.as_posix(), *target])
-- 
2.53.0

