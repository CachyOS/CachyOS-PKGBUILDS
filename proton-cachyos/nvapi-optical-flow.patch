From d42bae60d3ed6d8edbc07bb5d09d3158c38eb572 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Sat, 12 Oct 2024 16:55:48 -0700
Subject: [PATCH] inc: Import nvofapi headers

Signed-off-by: Liam Middlebrook <lmiddlebrook@nvidia.com>
---
 inc/nvofapi/nvOpticalFlowCommon.h | 583 ++++++++++++++++++++++++++++++
 inc/nvofapi/nvOpticalFlowCuda.h   | 236 ++++++++++++
 inc/nvofapi/nvOpticalFlowD3D11.h  | 193 ++++++++++
 inc/nvofapi/nvOpticalFlowD3D12.h  | 308 ++++++++++++++++
 inc/nvofapi/nvOpticalFlowVulkan.h | 312 ++++++++++++++++
 5 files changed, 1632 insertions(+)
 create mode 100644 inc/nvofapi/nvOpticalFlowCommon.h
 create mode 100644 inc/nvofapi/nvOpticalFlowCuda.h
 create mode 100644 inc/nvofapi/nvOpticalFlowD3D11.h
 create mode 100644 inc/nvofapi/nvOpticalFlowD3D12.h
 create mode 100644 inc/nvofapi/nvOpticalFlowVulkan.h

diff --git a/inc/nvofapi/nvOpticalFlowCommon.h b/inc/nvofapi/nvOpticalFlowCommon.h
new file mode 100644
index 00000000..1023cae8
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowCommon.h
@@ -0,0 +1,583 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowCommon.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowCommon.h provides enums, structure definitions and function prototypes which are common across different devices.
+*   nvOpticalFlowCommon.h uses #pragma directives to pack structure members with one byte alignment.
+*/
+
+#ifndef _NV_OPTICALFLOW_COMMON_H_
+#define _NV_OPTICALFLOW_COMMON_H_
+#if defined(_MSC_VER_) && (_MSC_VER_ < 1600)
+#ifndef _STDINT
+typedef __int32             int32_t;
+typedef unsigned __int32    uint32_t;
+typedef __int64             int64_t;
+typedef unsigned __int64    uint64_t;
+typedef signed char         int8_t;
+typedef unsigned char       uint8_t;
+typedef short               int16_t;
+typedef unsigned short      uint16_t;
+#endif
+#else
+#include <stdint.h>
+#endif
+
+#ifdef _WIN32
+#define NVOFAPI __stdcall
+#else
+#define NVOFAPI
+#endif
+#define NV_OF_API_MAJOR_VERSION 5
+#define NV_OF_API_MINOR_VERSION 0
+#define NV_OF_API_VERSION  (uint16_t)((NV_OF_API_MAJOR_VERSION << 4) | NV_OF_API_MINOR_VERSION)
+#define MIN_ERROR_STRING_SIZE 80
+
+#if defined(__cplusplus)
+extern "C" 
+{
+#endif /* __cplusplus */
+
+typedef struct NvOFHandle_st            *NvOFHandle;
+typedef struct NvOFGPUBufferHandle_st   *NvOFGPUBufferHandle;
+typedef struct NVOFPrivDataHandle_st    *NvOFPrivDataHandle;
+
+/**
+  *  Supported error codes
+*/
+typedef enum _NV_OF_STATUS
+{
+    /**
+    * This indicates that API call returned with no errors.
+    */
+    NV_OF_SUCCESS,
+
+    /**
+    * This indicates that HW Optical flow functionality is not supported
+    */
+    NV_OF_ERR_OF_NOT_AVAILABLE,
+
+    /**
+    * This indicates that device passed by the client is not supported.
+    */
+    NV_OF_ERR_UNSUPPORTED_DEVICE,
+
+    /**
+    * This indicates that device passed to the API call is no longer available and
+    * needs to be reinitialized.
+    */
+    NV_OF_ERR_DEVICE_DOES_NOT_EXIST,
+
+    /**
+    * This indicates that one or more of the pointers passed to the API call
+    * is invalid.
+    */
+    NV_OF_ERR_INVALID_PTR,
+
+    /**
+    * This indicates that one or more of the parameter passed to the API call
+    * is invalid.
+    */
+    NV_OF_ERR_INVALID_PARAM,
+
+    /**
+    * This indicates that an API call was made in wrong sequence/order.
+    */
+    NV_OF_ERR_INVALID_CALL,
+
+    /**
+    * This indicates that an invalid struct version was used by the client.
+    */
+    NV_OF_ERR_INVALID_VERSION,
+
+    /**
+    * This indicates that the API call failed because it was unable to allocate
+    * enough memory to perform the requested operation.
+    */
+    NV_OF_ERR_OUT_OF_MEMORY,
+
+    /**
+    * This indicates that the OF session has not been initialized with
+    * ::NvOFInit() or that initialization has failed.
+    */
+    NV_OF_ERR_NOT_INITIALIZED,
+
+    /**
+    * This indicates that an unsupported parameter was passed by the client.
+    */
+    NV_OF_ERR_UNSUPPORTED_FEATURE,
+
+    /**
+    * This indicates that an unknown internal error has occurred.
+    */
+   NV_OF_ERR_GENERIC,
+} NV_OF_STATUS;
+
+/**
+*  Supported bool values
+*/
+typedef enum _NV_OF_BOOL
+{
+    NV_OF_FALSE = 0,                              /* < Represents false bool value */
+    NV_OF_TRUE  = !NV_OF_FALSE                    /* < Represents true bool value */
+} NV_OF_BOOL;
+
+/**
+* Supported optical flow and stereo disparity capability values.
+*/
+typedef enum _NV_OF_CAPS
+{
+    NV_OF_CAPS_SUPPORTED_OUTPUT_GRID_SIZES,      /**< Indicates supported values of ::NV_OF_OUTPUT_VECTOR_GRID_SIZE, 
+                                                    ::NV_OF_INIT_PARAMS::outGridSize should be set with a supported output gridsize. */
+    NV_OF_CAPS_SUPPORTED_HINT_GRID_SIZES,        /**< Indicates supported values of ::NV_OF_HINT_VECTOR_GRID_SIZE, 
+                                                    ::NV_OF_INIT_PARAMS::hintGridSize should be set with a supported hint gridsize. */
+    NV_OF_CAPS_SUPPORT_HINT_WITH_OF_MODE,        /**< Indicates external hint support for ::NV_OF_MODE_OPTICALFLOW mode. 
+                                                    0: External hint not supported for ::NV_OF_MODE_OPTICALFLOW mode.
+                                                    1: External hint is supported for ::NV_OF_MODE_OPTICALFLOW mode. */ 
+    NV_OF_CAPS_SUPPORT_HINT_WITH_ST_MODE,        /**< Indicates external hint support for ::NV_OF_MODE_STEREODISPARITY mode. 
+                                                    0: External hint not supported for ::NV_OF_MODE_STEREODISPARITY mode.
+                                                    1: External hint is supported for ::NV_OF_MODE_STEREODISPARITY mode. */ 
+    NV_OF_CAPS_WIDTH_MIN,                        /**< Minimum input width supported. */
+    NV_OF_CAPS_HEIGHT_MIN,                       /**< Minimum input height supported. */
+    NV_OF_CAPS_WIDTH_MAX,                        /**< Maximum input width supported. */
+    NV_OF_CAPS_HEIGHT_MAX,                       /**< Maximum input height supported. */
+    NV_OF_CAPS_SUPPORT_ROI,                      /**< Indicates ROI support.
+                                                    0: ROIs cannot be specified.
+                                                    1: One or more ROIs can be specified. */
+    NV_OF_CAPS_SUPPORT_ROI_MAX_NUM,              /**< Indicates maximum number of ROIs supported. */
+    NV_OF_CAPS_SUPPORT_MAX
+} NV_OF_CAPS;
+
+/**
+* Supported optical flow/stereo disparity performance levels.
+* Stereo disparity will be deprecated from next SDK release. Instead, use x component of Optical Flow.
+*/
+typedef enum _NV_OF_PERF_LEVEL
+{
+    NV_OF_PERF_LEVEL_UNDEFINED,
+    NV_OF_PERF_LEVEL_SLOW = 5,                   /**< Slow perf level results in lowest performance and best quality */
+    NV_OF_PERF_LEVEL_MEDIUM = 10,                /**< Medium perf level results in low performance and medium quality */
+    NV_OF_PERF_LEVEL_FAST = 20,                  /**< Fast perf level results in high performance and low quality */
+    NV_OF_PERF_LEVEL_MAX
+} NV_OF_PERF_LEVEL;
+
+/**
+* Supported grid size for output buffer ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer.
+* Client should set ::NV_OF_INIT_PARAMS::outGridSize with ::NV_OF_OUTPUT_VECTOR_GRID_SIZE values.
+*/
+typedef enum _NV_OF_OUTPUT_VECTOR_GRID_SIZE
+{
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_UNDEFINED,
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_1 = 1,          /**< Output buffer grid size is 1x1  */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_2 = 2,          /**< Output buffer grid size is 2x2  */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_4 = 4,          /**< Output buffer grid size is 4x4  */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_MAX
+} NV_OF_OUTPUT_VECTOR_GRID_SIZE;
+
+/**
+* Expected grid size for optional paramater ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints buffer.
+* Client should set ::NV_OF_INIT_PARAMS::hintGridSize with ::NV_OF_HINT_VECTOR_GRID_SIZE values.
+*/
+typedef enum _NV_OF_HINT_VECTOR_GRID_SIZE
+{
+    NV_OF_HINT_VECTOR_GRID_SIZE_UNDEFINED,
+    NV_OF_HINT_VECTOR_GRID_SIZE_1 = 1,            /**< Hint buffer grid size is 1x1.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_2 = 2,            /**< Hint buffer grid size is 2x2.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_4 = 4,            /**< Hint buffer grid size is 4x4.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_8 = 8,            /**< Hint buffer grid size is 8x8.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_MAX
+} NV_OF_HINT_VECTOR_GRID_SIZE;
+
+/**
+* ::NV_OF_MODE enum define values for Optical flow and Stereo disparity modes.
+* Client need to set ::NV_OF_INIT_PARAMS::mode with ::NV_OF_MODE values.
+* For the ::NV_OF_MODE_OPTICALFLOW mode, the buffer format for ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints,
+* ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer and ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer is ::NV_OF_FLOW_VECTOR.
+* For the ::NV_OF_MODE_STEREODISPARITY mode, the buffer format for ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints,
+* ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer and ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer is ::NV_OF_STEREO_DISPARITY.
+*/
+typedef enum _NV_OF_MODE
+{
+    NV_OF_MODE_UNDEFINED,
+    NV_OF_MODE_OPTICALFLOW,                       /**< Calculate optical flow between two frames. */
+    NV_OF_MODE_STEREODISPARITY,                   /**< Calculate disparity between Stereo view pair. Will be deprecated from next SDK release.
+                                                       Instead, use x component of output from NV_OF_MODE_OPTICALFLOW mode */
+    NV_OF_MODE_MAX
+} NV_OF_MODE;
+
+/**
+*  Supported buffer type for ::NvOFGPUBufferHandle allocation.
+*  Client need to set NV_OF_CREATE_BUFFER::bufferUsage with ::NV_OF_BUFFER_USAGE enum values.
+*/
+typedef enum _NV_OF_BUFFER_USAGE
+{
+    NV_OF_BUFFER_USAGE_UNDEFINED,
+    NV_OF_BUFFER_USAGE_INPUT,                    /**< Input buffer type is used to allocate ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame,
+                                                      ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame. */
+    NV_OF_BUFFER_USAGE_OUTPUT,                   /**< Output buffer type is used to allocate ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer. */
+    NV_OF_BUFFER_USAGE_HINT,                     /**< Hint buffer type is used to allocate ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints.*/
+    NV_OF_BUFFER_USAGE_COST,                     /**< Cost buffer type is used to allocate ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputCostBuffer.*/
+    NV_OF_BUFFER_USAGE_GLOBAL_FLOW,              /**< Global flow buffer type is used to allocate ::NV_OF_EXECUTE_OUTPUT_PARAMS::globalFlowBuffer. */
+    NV_OF_BUFFER_USAGE_MAX
+} NV_OF_BUFFER_USAGE;
+
+/**
+* Supported buffer formats
+*/
+typedef enum _NV_OF_BUFFER_FORMAT
+{
+    NV_OF_BUFFER_FORMAT_UNDEFINED,
+    NV_OF_BUFFER_FORMAT_GRAYSCALE8,               /**< Input buffer format with 8 bit planar format */
+    NV_OF_BUFFER_FORMAT_NV12,                     /**< Input buffer format with 8 bit planar, UV interleaved */
+    NV_OF_BUFFER_FORMAT_ABGR8,                    /**< Input buffer format with 8 bit packed A8B8G8R8 */
+    NV_OF_BUFFER_FORMAT_SHORT,                    /**< Output or hint buffer format for stereo disparity */
+    NV_OF_BUFFER_FORMAT_SHORT2,                   /**< Output or hint buffer format for optical flow vector */
+    NV_OF_BUFFER_FORMAT_UINT,                     /**< Legacy 32-bit Cost buffer format for optical flow vector / stereo disparity. 
+                                                       This cost buffer format is not performance efficient and results in additional GPU usage.
+                                                       Hence users are strongly recommended to use the 8-bit cost buffer format. 
+                                                       Legacy 32-bit cost buffer format is also planned to be deprecated in future. */
+    NV_OF_BUFFER_FORMAT_UINT8,                    /**< 8-bit Cost buffer format for optical flow vector / stereo disparity. */
+    NV_OF_BUFFER_FORMAT_MAX
+} NV_OF_BUFFER_FORMAT;
+
+/**
+* Stero disparity will be deprecated from next SDK release. Instead, use x compononent of Optical Flow.
+* Supported stereo disparity range.  Avaialble for GPUs later than Turing
+*/
+typedef enum _NV_OF_STEREO_DISPARITY_RANGE
+{
+    NV_OF_STEREO_DISPARITY_RANGE_UNDEFINED,
+    NV_OF_STEREO_DISPARITY_RANGE_128 = 128,
+    NV_OF_STEREO_DISPARITY_RANGE_256 = 256,
+    NV_OF_STEREO_DISPARITY_RANGE_MAX
+} NV_OF_STEREO_DISPARITY_RANGE;
+
+/**
+* \struct NV_OF_PRED_DIRECTION
+* Prediction direction of the flow estimation
+*/
+typedef enum _NV_OF_PRED_DIRECTION
+{
+    NV_OF_PRED_DIRECTION_FORWARD    = 0,                            /**< [in]: Default direction. Gives each pixel position change from ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame
+                                                                               to ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer
+                                                                               and the corresponding cost in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputCostBuffer if ::NV_OF_INIT_PARAMS::
+                                                                               enableOutputCost is set */
+    NV_OF_PRED_DIRECTION_BOTH       = 2,                            /**< [in]: Flow in both direction. Gives each pixel position change from ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame
+                                                                               to ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer
+                                                                               and the corresponding cost in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputCostBuffer and ::NV_OF_EXECUTE_INPUT_PARAMS::
+                                                                               referenceFrame to ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame in ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer
+                                                                               and the corresponding cost in ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputCost if NV_OF_INIT_PARAMS::enableOutputCost
+                                                                               is set. Applicable only when ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW.*/
+    NV_OF_PRED_DIRECTION_MAX
+} NV_OF_PRED_DIRECTION;
+
+/**
+* \struct NV_OF_FLOW_VECTOR
+* Struct needed for optical flow. ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer will be populated with optical flow
+* in ::NV_OF_FLOW_VECTOR format for each ::NV_OF_INIT_PARAMS::outGridSize.
+* Flow vectors flowx and flowy are 16-bit values with the lowest 5 bits holding fractional value,
+* followed by a 10-bit integer value and the most significant bit being a sign bit.
+*/
+typedef struct _NV_OF_FLOW_VECTOR
+{
+    int16_t                         flowx;        /**< x component of flow in S10.5 format */
+    int16_t                         flowy;        /**< y component of flow in S10.5 format */
+} NV_OF_FLOW_VECTOR;
+
+/**
+* \struct NV_OF_STEREO_DISPARITY
+* Struct needed for stereo /disparity. ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer will be populated
+* with stereo disparity in ::NV_OF_STEREO_DISPARITY format for each ::NV_OF_INIT_PARAMS::outGridSize.
+* Stereo disparity is a 16-bit value with the lowest 5 bits holding fractional value,
+* followed by a 11-bit unsigned integer value.
+*/
+typedef struct _NV_OF_STEREO_DISPARITY
+{
+    uint16_t                        disparity;    /**< Horizontal displacement[in pixels] in 11.5 format. */
+} NV_OF_STEREO_DISPARITY;
+
+/**
+* \struct NV_OF_INIT_PARAMS
+* Optical flow/stereo disparity session initialization parameters.
+*/
+typedef struct _NV_OF_INIT_PARAMS
+{
+    uint32_t                        width;                            /**< [in]: Specifies input buffer width */
+    uint32_t                        height;                           /**< [in]: Specifies input buffer height */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE   outGridSize;                      /**< [in]: Specifies flow vector grid size for ::NV_OF_EXECUTE_INPUT_PARAMS::outputBuffer buffer.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE     hintGridSize;                     /**< [in]: Specifies flow vector grid size for ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints buffer.
+                                                                                 This field is only considered if ::NV_OF_INIT_PARAMS::enableExternalHints is set.
+                                                                                 hintGridSize should be equal or greater than outGridSize. */
+    NV_OF_MODE                      mode;                             /**< [in]: Operating mode for NVOF. Set to a value defined by enum ::NV_OF_MODE. */
+    NV_OF_PERF_LEVEL                perfLevel;                        /**< [in]: Specifies perf level. */
+    NV_OF_BOOL                      enableExternalHints;              /**< [in]: Set to 1 to enable external hints for optical flow session. */
+    NV_OF_BOOL                      enableOutputCost;                 /**< [in]: Set to 1 to enable output cost calculation for optical flow session. */
+    NvOFPrivDataHandle              hPrivData;                        /**< [in]: Optical flow private data. It is reserved field and should be set to NULL. */
+    NV_OF_STEREO_DISPARITY_RANGE    disparityRange;                   /**< [in]: Specifies maximum disparity range. 
+                                                                                 Set to NV_OF_STEREO_DISPARITY_RANGE_UNDEFINED for Turing GPUs. */
+    NV_OF_BOOL                      enableRoi;                        /**< [in]: Set to 1 to enable estimation of optical flow/stereo for roi. */
+    NV_OF_PRED_DIRECTION            predDirection;                    /**< [in]: Prediction direction. When ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW,
+                                                                                 the possible values are ::NV_OF_PRED_DIRECTION_FORWARD and ::NV_OF_PRED_DIRECTION_BOTH.
+                                                                                 When ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, only
+                                                                                 ::NV_OF_PRED_DIRECTION_FORWARD is supported. */
+    NV_OF_BOOL                      enableGlobalFlow;                 /**< [in]: Set to 1 to enable forward global flow estimation.
+                                                                                 Applicable only when ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW. */
+    NV_OF_BUFFER_FORMAT             inputBufferFormat;                /**< [in]: Specifies the buffer format of ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame and
+                                                                                 ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame. */
+} NV_OF_INIT_PARAMS;
+
+/**
+* \struct NV_OF_BUFFER_DESCRIPTOR
+* Creation parameters for optical flow buffers.
+*/
+typedef struct _NV_OF_BUFFER_DESCRIPTOR
+{
+    uint32_t                        width;                           /**< [in]: Buffer width. */
+    uint32_t                        height;                          /**< [in]: Buffer height. */
+    NV_OF_BUFFER_USAGE              bufferUsage;                     /**< [in]: To specify buffer usage type.
+                                                                     ::NV_OF_BUFFER_USAGE_OUTPUT buffer usage type accepts ::NV_OF_BUFFER_DESCRIPTOR::width,
+                                                                     ::NV_OF_BUFFER_DESCRIPTOR::height in ::NV_OF_INIT_PARAMS::outGridSize units.
+                                                                     ::NV_OF_BUFFER_USAGE_HINT buffer usage type accepts ::NV_OF_BUFFER_DESCRIPTOR::width,
+                                                                     ::NV_OF_BUFFER_DESCRIPTOR::height in ::NV_OF_INIT_PARAMS::hintGridSize units. */
+    NV_OF_BUFFER_FORMAT             bufferFormat;                    /**< [in]: Buffer format. */
+
+} NV_OF_BUFFER_DESCRIPTOR;
+
+/**
+* \struct NV_OF_ROI_RECT
+* Specifies the co-ordinates of the Region Of Interest (ROI)
+* ROI rects should satisfy below requirements:
+*   1. NV_OF_ROI_RECT::start_x should align to (32 * NV_OF_INIT_PARAMS::outGridSize)
+*   2. NV_OF_ROI_RECT::width should align to (32 * NV_OF_INIT_PARAMS::outGridSize)
+*   3. NV_OF_ROI_RECT::start_y should align to (8 * max(NV_OF_INIT_PARAMS::outGridSize, 2))
+*   4. NV_OF_ROI_RECT::height should align to (8 * NV_OF_INIT_PARAMS::outGridSize)
+*   5. NV_OF_ROI_RECT::width >= 32 && NV_OF_ROI_RECT::height >= 16; maximum size 8192x8192
+*   6. Whole ROI region should be inside of the image
+* Optical flow/stereo disparity vectors out side of ROI are invalid and should not be used.
+*/
+typedef struct NV_OF_ROI_RECT
+{
+    uint32_t                        start_x;                         /**< [in]: ROI start position in x-direction. */
+    uint32_t                        start_y;                         /**< [in]: ROI start position in y-direction. */
+    uint32_t                        width;                           /**< [in]: Width of ROI. */
+    uint32_t                        height;                          /**< [in]: Height of ROI. */
+} NV_OF_ROI_RECT;
+
+/**
+* \struct NV_OF_EXECUTE_INPUT_PARAMS
+* Parameters which are sent per frame for optical flow/stereo disparity execution.
+*/
+typedef struct _NV_OF_EXECUTE_INPUT_PARAMS
+{
+    NvOFGPUBufferHandle             inputFrame;                      /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the input frame.
+                                                                                If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified left view. */
+    NvOFGPUBufferHandle             referenceFrame;                  /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the reference frame.
+                                                                                If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified right view. */
+    NvOFGPUBufferHandle             externalHints;                   /**< [in]: It is an optional input, This field will be considered if client had set ::NV_OF_INIT_PARAMS::enableExternalHint flag.
+                                                                                Client can pass some available predictors as hints. 
+                                                                                Optical flow driver will search around those hints to optimize flow vectors quality.
+                                                                                Expected hint buffer format is ::NV_OF_FLOW_VECTOR, ::NV_OF_STEREO_DISPARITY 
+                                                                                for ::NV_OF_MODE_OPTICALFLOW, ::NV_OF_MODE_STEREODISPARITY modes respectively for
+                                                                                each ::NV_OF_INIT_PARAMS::hintGridSize in a frame. */
+    NV_OF_BOOL                      disableTemporalHints;            /**< [in]: Temporal hints yield better accuracy flow vectors when running on successive frames of a continuous video (without major scene changes).
+                                                                                When disableTemporalHints = 0, optical flow vectors from previous NvOFExecute call are automatically used as hints for the current NvOFExecute call.
+                                                                                However, when running optical flow on pairs of images which are completely independent of each other, temporal hints are useless
+                                                                                and in fact, they will degrade the quality. Therefore, it is recommended to set disableTemporalHints = 1 in this case.*/
+    uint32_t                        padding;                         /**< [in]: Padding.  Must be set to 0. */
+    NvOFPrivDataHandle              hPrivData;                       /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+    uint32_t                        padding2;                        /**< [in]: Padding.  Must be set to 0. */
+    uint32_t                        numRois;                         /**< [in]: Number of ROIs. */
+    NV_OF_ROI_RECT*                 roiData;                         /**< [in]: Pointer to the NV_OF_ROI_RECTs data.  Size of this buffer should be atleast numROIs * sizeof(NV_OF_ROI_RECT). */
+} NV_OF_EXECUTE_INPUT_PARAMS;
+
+/**
+* \struct NV_OF_EXECUTE_OUTPUT_PARAMS
+* Parameters which are received per frame for optical flow/stereo disparity execution.
+*/
+typedef struct _NV_OF_EXECUTE_OUTPUT_PARAMS
+{
+    NvOFGPUBufferHandle            outputBuffer;                     /**< [in]: Specifies the pointer to optical flow or stereo disparity buffer handle.
+                                                                                ::outputBuffer will be populated with optical flow in
+                                                                                ::NV_OF_FLOW_VECTOR format or stereo disparity in 
+                                                                                ::NV_OF_STEREO_DISPARITY format for each 
+                                                                                ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGridSize in a frame.*/
+    NvOFGPUBufferHandle            outputCostBuffer;                 /**< [in]: Specifies the pointer to output cost calculation buffer handle. */
+    NvOFPrivDataHandle             hPrivData;                        /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+    NvOFGPUBufferHandle            bwdOutputBuffer;                  /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH,
+                                                                                this specifies the pointer to backward optical flow buffer handle.
+                                                                                ::bwOutputBuffer will be populated with optical flow in ::NV_OF_FLOW_VECTOR format
+                                                                                for each ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGidSize in a frame. */
+    NvOFGPUBufferHandle            bwdOutputCostBuffer;              /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH and
+                                                                                ::NV_OF_INIT_PARAMS::enableOutputCost is NV_TRUE, this specifies the pointer
+                                                                                to the backward output cost calculation buffer handle. */
+    NvOFGPUBufferHandle            globalFlowBuffer;                 /**< [in]: When ::NV_OF_INIT_PARAMS::enableGlobalFlow is set to NV_true, this specifies the
+                                                                                pointer to the global flow buffer handle. ::globalFlowBuffer will be populated in
+                                                                                ::NV_OF_FLOW_VECTOR format. */
+} NV_OF_EXECUTE_OUTPUT_PARAMS;
+
+/**
+* \brief Initialize NVIDIA Video Optical Flow Interface and validates input params.
+*
+* Initializes NVIDIA Video Optical Flow Interface and validates input params.
+* It also initializes NVIDIA Video Optical Flow driver with the init value passed in ::NV_OF_INIT_PARAMS
+* structure.
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in] initParams
+*   Pointer to the ::NV_OF_INIT_PARAMS structure.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_UNSUPPORTED_DEVICE \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFINIT) (NvOFHandle hOf, const NV_OF_INIT_PARAMS *initParams);
+
+/**
+* \brief Kick off computation of optical flow between input and reference frame.
+*
+* This is asynchronous function call which kicks off computation of optical flow or stereo disparity
+* between ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame and ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame and returns
+* after submitting  execute paramaters to optical flow engine. 
+* ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer will be populated with optical flow or stereo disparity
+* based on ::NV_OF_INIT_PARAMS:mode is NV_OF_MODE_OPTICALFLOW or NV_OF_MODE_STEREODISPARITY respectively.
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in] executeInParams
+*   pointer to the ::NV_OF_EXECUTE_INPUT_PARAMS structure.
+* \param [out] executeOutParams
+*   pointer to the ::NV_OF_EXECUTE_OUTPUT_PARAMS structure.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_INVALID_DEVICE \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFEXECUTE) (NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS *executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS *executeOutParams);
+
+/**
+* \brief Release optical flow API and driver resources.
+*
+* Releases resources and waits until all resources are gracefully released.
+*
+*  \param [in] hOf
+*   Object of ::NvOFHandle type.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFDESTROY) (NvOFHandle hOf);
+
+/**
+* \brief Populate error buffer with the description of last failure.
+*
+* Populates lastError[] with the description of last failure.
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in/out] lastError
+*   lastError is a char array, minimum expected size of lastError[] is MIN_ERROR_STRING_SIZE characters.
+*   After execution of this function call, lastError[] is populated with error string.
+* \param [in/out] As an input parameter, "size" indicates the size of the array provided by the client.
+*   After execution of this function call, "size" field indicates the number of characters written into
+*   "lastError" excluding null character.
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETLASTERROR) (NvOFHandle hOf, char lastError[], uint32_t *size);
+
+/**
+* \brief Populate capability array for specified ::NV_OF_CAPS value.
+* This is to be called in two stages.
+* It returns the number of capability values for specified ::NV_OF_CAPS value when
+* queried with "capsVal" set to NULL.
+* It populates capsVal array with capability values for specified ::NV_OF_CAPS value
+* when queried with "capsVal" set to non-NULL value.
+*
+*  \param [in] hOf
+*   Object of ::NvOFHandle type.
+*  \param [in] capsParam
+*   object of ::NV_OF_CAPS type.
+*  \param [out] capsVal
+*   Pointer to uint32_t, minimum expected size of capsVal is the "size" returned by the this function call
+*   queried with "capsVal" set to NULL.
+* \param [out] size
+*   Pointer to uint32_t, which stores size of populated capsVal.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETCAPS) (NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t *capsVal, uint32_t *size);
+
+/**
+* \brief Get the largest API version supported by the driver.
+*
+* This function can be used by clients to determine if the driver supports
+* the API header the application was compiled with.
+*
+* \param [out] version
+*   Pointer to the requested value. The 4 least significant bits in the returned
+*   indicate the minor version and the rest of the bits indicate the major
+*   version of the largest supported version.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+*/
+NV_OF_STATUS NVOFAPI NvOFGetMaxSupportedApiVersion(uint32_t* version);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowCuda.h b/inc/nvofapi/nvOpticalFlowCuda.h
new file mode 100644
index 00000000..a249dd29
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowCuda.h
@@ -0,0 +1,236 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file NvOpticalFlowCuda.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowCuda.h provides cuda specific enums, structure definitions and function pointers prototypes.
+*/
+
+#ifndef _NV_OPTICALFLOW_CUDA_H_
+#define _NV_OPTICALFLOW_CUDA_H_
+#include "nvOpticalFlowCommon.h"
+#include <cuda.h>
+#define MAX_NUM_PLANES 3
+
+#if defined(__cplusplus)
+
+extern "C" 
+{
+#endif /* __cplusplus */
+
+/**
+* Supported CUDA buffer types.
+*/
+typedef enum _NV_OF_CUDA_BUFFER_TYPE
+{
+    NV_OF_CUDA_BUFFER_TYPE_UNDEFINED,
+    NV_OF_CUDA_BUFFER_TYPE_CUARRAY,           /**< Buffer type is CUarray */
+    NV_OF_CUDA_BUFFER_TYPE_CUDEVICEPTR,       /**< Buffer type is CUdeviceptr */
+    NV_OF_CUDA_BUFFER_TYPE_MAX
+} NV_OF_CUDA_BUFFER_TYPE;
+
+/**
+* \struct NV_BUFFER_STRIDE
+* Horizontal and vertical strides of a plane.
+*/
+typedef struct _NV_OF_BUFFER_STRIDE
+{
+    uint32_t strideXInBytes;               /**< Horizontal stride. */
+    uint32_t strideYInBytes;               /**< Vertical stride. */
+} NV_OF_BUFFER_STRIDE;
+
+/**
+* \struct NV_OF_CUDA_BUFFER_STRIDE_INFO
+* This structure stores buffer stride information which is populated in the ::nvOFGPUBufferGetStrideInfo() API.
+*/
+typedef struct _NV_OF_CUDA_BUFFER_STRIDE_INFO
+{
+    NV_OF_BUFFER_STRIDE strideInfo[MAX_NUM_PLANES];    /**< Stride information of each plane.*/
+    uint32_t            numPlanes;                     /**< Number of planes. */
+} NV_OF_CUDA_BUFFER_STRIDE_INFO;
+
+/**
+* \brief Create an instance of NvOFHandle object.
+*
+* This function creates an instance of NvOFHandle object and returns status.
+* Client is expected to release NvOFHandle resource using Destroy function call.
+*
+* \param [in] cuContext
+*   Should be set to cuda context created by Client.
+* \param [out] NvOFHandle*
+*   Pointer of class ::NvOFHandle object.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWCUDA) (CUcontext device, NvOFHandle *hOf);
+
+/**
+* \brief Set input and output cuda stream for specified optical flow instance.
+*
+* Optical flow algorithm may optionally involve cuda preprocessing on the input buffers and post
+* processing on the output flow vectors. This function is used to set input and output cuda stream
+* to pipeline and synchronize the cuda preprocessing and post processing tasks with OF HW engine.
+* Client should call this function before Execute function to update input and/or output streams otherwise
+* Execute function will either use preset input, output streams or default streams(If streams are never set before).
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in] inputStream
+*   CUstream type object which is used to process ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame,
+*   ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame and optional NV_OF_EXECUTE_INPUT_PARAMS::externalHints.
+* \param [in] outputStream
+*  CUstream type object which is used to process ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer and 
+*  optional ::NV_OF_EXECUTE_OUTPUT_PARAMS::costBuffer, ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer,
+*  ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputCostBuffer.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_INVALID_DEVICE \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFSETIOCUDASTREAMS) (NvOFHandle hOf, CUstream inputStream, CUstream outputStream);
+
+/**
+* \brief Create ::NvOFGPUBufferHandle resource.
+*
+* This function creates ::NvOFGPUBufferHandle resource for specified cuda bufferType.
+*
+* \param [in] hOf
+*   Pointer to the NvOFHandle.
+* \param [in] createBufferParams
+*   pointer of the ::NV_OF_CREATE_BUFFER.
+* \param [out] ofGpuBuffer
+*   Output pointer of ::NvOFGPUBufferHandle type.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFCREATEGPUBUFFERCUDA) (NvOFHandle hOf, const NV_OF_BUFFER_DESCRIPTOR *bufferDesc,
+                                                         NV_OF_CUDA_BUFFER_TYPE bufferType, NvOFGPUBufferHandle *hOfGpuBuffer);
+
+/**
+* \brief Return CUarray object associated with ::NvOFGPUBufferHandle type resource.
+*
+* \param [in] ofGpuBuffer
+*  Object of type NvOFGPUBufferHandle, created by a call to NvOFCreateGPUBufferCuda() with bufferType set to ::NV_OF_CUDA_BUFFER_TYPE_CUARRAY.
+*
+* \return  
+* Object of CUarray type.
+* If ofGpubuffer corresponds to a GPU buffer that was not created with buffer type NV_OF_CUDA_BUFFER_TYPE_CUARRAY,
+* this function returns NULL
+*/
+typedef CUarray(NVOFAPI* PFNNVOFGPUBUFFERGETCUARRAY) (NvOFGPUBufferHandle ofGpuBuffer);
+
+/**
+* \brief Return CUdeviceptr object associated with ::NvOFGPUBufferHandle type resource.
+*
+* \param [in] ofGpuBuffer
+*  Object of type NvOFGPUBufferHandle, created by a call to NvOFCreateGPUBufferCuda() with bufferType set to ::NV_OF_CUDA_BUFFER_TYPE_CUDEVICEPTR.
+*
+* \return 
+* Object of the CUdeviceptr type.
+* If ofGpubuffer corresponds to a GPU buffer that was not created with buffer type NV_OF_CUDA_BUFFER_TYPE_CUDEVICEPTR,
+* this function returns 0
+*/
+typedef CUdeviceptr(NVOFAPI* PFNNVOFGPUBUFFERGETCUDEVICEPTR) (NvOFGPUBufferHandle ofGpuBuffer);
+
+/**
+* \brief Populates buffer information associated with ::NvOFGPUBufferHandle type resource.
+*
+* Populates structure ::NV_OF_CUDA_BUFFER_STRIDE_INFO with the horizontal and vertical stride details of all the planes.
+* \param [in] ofGpuBuffer
+*   Object of type NvOFGPUBufferHandle, created by a call to NvOFCreateGPUBufferCuda().
+* \param [out] strideInfo
+*   pointer to the ::NV_OF_CUDA_BUFFER_STRIDE_INFO.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNVOFGPUBUFFERGETSTRIDEINFO) (NvOFGPUBufferHandle ofGpuBuffer, NV_OF_CUDA_BUFFER_STRIDE_INFO *strideInfo);
+
+/**
+* \brief Destroy NvOFGPUBufferHandle object and associated resources.
+*
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFDESTROYGPUBUFFERCUDA) (NvOFGPUBufferHandle buffer);
+
+/**
+* \struct NV_OF_CUDA_API_FUNCTION_LIST
+* This is structure of function pointers  which are populated by ::NvOFAPICreateInstanceCuda() API.
+* Defination of each cuda specific function pointer is defined above.
+*/
+typedef struct _NV_OF_CUDA_API_FUNCTION_LIST
+{
+    PFNNVCREATEOPTICALFLOWCUDA                                 nvCreateOpticalFlowCuda;
+    PFNNVOFINIT                                                nvOFInit;
+    PFNNVOFCREATEGPUBUFFERCUDA                                 nvOFCreateGPUBufferCuda;
+    PFNNVOFGPUBUFFERGETCUARRAY                                 nvOFGPUBufferGetCUarray;
+    PFNNVOFGPUBUFFERGETCUDEVICEPTR                             nvOFGPUBufferGetCUdeviceptr;
+    PFNVOFGPUBUFFERGETSTRIDEINFO                               nvOFGPUBufferGetStrideInfo;
+    PFNNVOFSETIOCUDASTREAMS                                    nvOFSetIOCudaStreams;
+    PFNNVOFEXECUTE                                             nvOFExecute;
+    PFNNVOFDESTROYGPUBUFFERCUDA                                nvOFDestroyGPUBufferCuda;
+    PFNNVOFDESTROY                                             nvOFDestroy;
+    PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+    PFNNVOFGETCAPS                                             nvOFGetCaps;
+} NV_OF_CUDA_API_FUNCTION_LIST;
+
+/**
+* \brief ::NvOFAPICreateInstanceCuda() API is the entry point to the NvOFAPI interface.
+*
+* ::NvOFAPICreateInstanceCuda() API populates functionList with function pointers to the API routines implemented by the
+ * NvOFAPI interface.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* :: NV_OF_ERR_INVALID_PTR \n
+*/
+NV_OF_STATUS NVOFAPI NvOFAPICreateInstanceCuda(uint32_t apiVer, NV_OF_CUDA_API_FUNCTION_LIST  *functionList);
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowD3D11.h b/inc/nvofapi/nvOpticalFlowD3D11.h
new file mode 100644
index 00000000..a609e1d1
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowD3D11.h
@@ -0,0 +1,193 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowD3D11.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowD3D11.h provides D3D11 specific enums, structure definitions and function prototypes.
+*  for Direct3D11 resource.
+*/
+#ifndef _NV_OPTICALFLOW_D3D11_H_
+#define _NV_OPTICALFLOW_D3D11_H_
+#include "nvOpticalFlowCommon.h"
+#include <d3d11.h>
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+    /**
+    * \brief Create an instance of NvOFHandle object.
+    *
+    * This function creates an instance of NvOFHandle object and returns status.
+    * Client is expected to release NvOFHandle resource using Destroy function call.
+    *
+    * \param [in] pD3D11Device
+    *   Client must provide set this to the ID3D11Device created by the client.
+    * \param [in] pD3D11DeviceContext
+    *   Client must provide ID3D11DeviceContext* for the ID3D11Device created by the client.
+    * \param [out] NvOFHandle*
+    *   Pointer of class ::NvOFHandle object.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OF_NOT_AVAILABLE \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWD3D11) (ID3D11Device* const pD3D11Device, ID3D11DeviceContext* const pD3D11DeviceContext, NvOFHandle *hOFInstance);
+
+    /**
+    * \brief Populate the count of the DXGI_FORMATs supported.
+    *
+    * This function returns the count of the DXGI_FORMAT supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client can use this count to allocate a sufficiently large array for 
+    * querying the DXGI_FORMATS supported.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pCount
+    *  The count is returned by uint32_t* pCount
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATCOUNTD3D11) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, uint32_t* const pCount);
+
+    /**
+    * \brief Populate the array of the DXGI_FORMATs supported.
+    *
+    * This function returns the array of the DXGI_FORMATs supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client must populate surface format count prior to this call.
+    * Client must allocate sufficiently large array size for this function call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pFormat
+    *  The list is returned through client allocated array of DXGI_FORMAT.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATD3D11) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat);
+
+    /**
+    * \brief Register the app allocated ID3D11Resource with the NvOFAPI.
+    *
+    * This function registers the app allocated ID3D11Resource with the NvOFAPI and gets an opaque handle NvOFGPUBufferHandle
+    * in return. The client should call ::NvOFUnregisterResourceD3D11 with NvOFGPUBufferHandle to unregister the resource.
+    * Client need to register the ID3D11Resource with OFAPI to be able to use it in the ::NvOFExecute call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] pResource
+    *  ID3D11Resource* allocated by the client.
+    * \param [out] hOFGpuBuffer
+    *   Output pointer of ::NvOFGPUBufferHandle type.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFREGISTERRESOURCED3D11) (NvOFHandle hOf, ID3D11Resource* pResource, NvOFGPUBufferHandle* const hOFGpuBuffer);
+
+    /**
+    * \brief Unregister the app allocated ID3D11Resource with the NvOFAPI.
+    *
+    * This function unregisters the app allocated ID3D11Resource which is already registered with the NvOFAPI.
+    * Client needs to provied the NvOFGPUBufferHandle, which it has received in ::NvOFRegisterResourceD3D11 call.
+
+    * \param in] hOFGpuBuffer
+    *   Input pointer of ::NvOFGPUBufferHandle type.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFUNREGISTERRESOURCED3D11) (NvOFGPUBufferHandle hOFGpuBuffer);
+
+    /*
+    * Defining D3D11 specific API function pointers.
+    */
+    typedef struct _NV_OF_D3D11_API_FUNCTION_LIST
+    {
+        PFNNVCREATEOPTICALFLOWD3D11                                nvCreateOpticalFlowD3D11;
+        PFNNVOFINIT                                                nvOFInit;
+        PFNNVOFGETSURFACEFORMATCOUNTD3D11                          nvOFGetSurfaceFormatCountD3D11;
+        PFNNVOFGETSURFACEFORMATD3D11                               nvOFGetSurfaceFormatD3D11;
+        PFNNVOFREGISTERRESOURCED3D11                               nvOFRegisterResourceD3D11;
+        PFNNVOFUNREGISTERRESOURCED3D11                             nvOFUnregisterResourceD3D11;
+        PFNNVOFEXECUTE                                             nvOFExecute;
+        PFNNVOFDESTROY                                             nvOFDestroy;
+        PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+        PFNNVOFGETCAPS                                             nvOFGetCaps;
+    } NV_OF_D3D11_API_FUNCTION_LIST;
+
+
+    /**
+    * \brief ::NvOFAPICreateInstanceD3D11() API is the entry point to the NvOFAPI interface.
+    *
+    * ::NvOFAPICreateInstanceD3D11() API populates functionList with function pointers to the API routines implemented by the
+    * NvOFAPI interface.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    */
+    NV_OF_STATUS NVOFAPI NvOFAPICreateInstanceD3D11(uint32_t apiVer, NV_OF_D3D11_API_FUNCTION_LIST  *functionList);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowD3D12.h b/inc/nvofapi/nvOpticalFlowD3D12.h
new file mode 100644
index 00000000..7794304d
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowD3D12.h
@@ -0,0 +1,308 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowD3D12.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowD3D12.h provides D3D12 specific enums, structure definitions and function prototypes.
+* */
+#ifndef _NV_OPTICALFLOW_D3D12_H_
+#define _NV_OPTICALFLOW_D3D12_H_
+#include "nvOpticalFlowCommon.h"
+#include <d3d12.h>
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+    /** \struct NV_OF_FENCE_POINT
+    * Fence and value for synchronization.
+    */
+    typedef struct _NV_OF_FENCE_POINT
+    {
+        ID3D12Fence*                    fence;                          /**< [in]: Fence object used in synchronization. */
+        uint64_t                        value;                          /**< [in]: Value the fence to reach or exceed before the GPU operation or
+                                                                                   Value to set the fence to after the GPU operation. */
+    } NV_OF_FENCE_POINT;
+
+    /**
+    * \struct NV_OF_REGISTER_RESOURCE_PARAMS_D3D12
+    * Parameters used in registering a ID3D12Resource
+    */
+    typedef struct _NV_OF_REGISTER_RESOURCE_PARAMS_D3D12
+    {
+        ID3D12Resource*                 resource;                       /**< [in]: ID3D12Resource that need to be registered. */
+        NV_OF_FENCE_POINT               inputFencePoint;                /**< [in]: GPU wait until the specified fence reaches or exceeds the specified value. */
+        NvOFGPUBufferHandle*            hOFGpuBuffer;                   /**< [in]: Pointer to the opaque handle of the registered resource. */
+        NV_OF_FENCE_POINT               outputFencePoint;               /**< [in]: Updates the specified fence to the specified value after GPU operation. */
+    } NV_OF_REGISTER_RESOURCE_PARAMS_D3D12;
+
+    /**
+    * \struct NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12
+    * Parameters used in unregistering a ID3D12Resource
+    */
+    typedef struct _NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12
+    {
+        NvOFGPUBufferHandle             hOFGpuBuffer;                   /**< [in]: Registered handle of the resource that need to be unregistered. */
+    } NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12;
+
+    /**
+    * \struct NV_OF_EXECUTE_INPUT_PARAMS_D3D12
+    * Parameters which are sent per frame for optical flow/stereo disparity execution.
+    */
+    typedef struct _NV_OF_EXECUTE_INPUT_PARAMS_D3D12
+    {
+        NvOFGPUBufferHandle             inputFrame;                      /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the input frame.
+                                                                                    If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified left view. */
+        NvOFGPUBufferHandle             referenceFrame;                  /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the reference frame.
+                                                                                    If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified right view. */
+        NvOFGPUBufferHandle             externalHints;                   /**< [in]: It is an optional input, This field will be considered if client had set ::NV_OF_INIT_PARAMS::enableExternalHint flag.
+                                                                                    Client can pass some available predictors as hints. 
+                                                                                    Optical flow driver will search around those hints to optimize flow vectors quality.
+                                                                                    Expected hint buffer format is ::NV_OF_FLOW_VECTOR, ::NV_OF_STEREO_DISPARITY 
+                                                                                    for ::NV_OF_MODE_OPTICALFLOW, ::NV_OF_MODE_STEREODISPARITY modes respectively for
+                                                                                    each ::NV_OF_INIT_PARAMS::hintGridSize in a frame. */
+        NV_OF_BOOL                      disableTemporalHints;            /**< [in]: Temporal hints yield better accuracy flow vectors when running on successive frames of a continuous video (without major scene changes).
+                                                                                    When disableTemporalHints = 0, optical flow vectors from previous NvOFExecute call are automatically used as hints for the current NvOFExecute call.
+                                                                                    However, when running optical flow on pairs of images which are completely independent of each other, temporal hints are useless
+                                                                                    and in fact, they will degrade the quality. Therefore, it is recommended to set disableTemporalHints = 1 in this case.*/
+        uint32_t                        padding;                         /**< [in]: Padding.  Must be set to 0. */
+        NvOFPrivDataHandle              hPrivData;                       /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        uint32_t                        padding2;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numRois;                         /**< [in]: Number of ROIs. */
+        NV_OF_ROI_RECT*                 roiData;                         /**< [in]: Pointer to the NV_OF_ROI_RECTs data.  Size of this buffer should be atleast numROIs * sizeof(NV_OF_ROI_RECT). */
+        uint32_t                        padding3;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numFencePoints;                  /**< [in]: Number of fence points to reach or exceed before GPU operation starts.
+                                                                                    Client can use different fence points for different buffers syncrhonization.  Client shall speicify all the fence points
+                                                                                    used for the buffers synchronization which will be used in Optical Flow estimation. */
+        NV_OF_FENCE_POINT*              fencePoint;                      /**< [in]: Pointer to an array of fence points to reach or exceed before GPU operation starts. */
+    } NV_OF_EXECUTE_INPUT_PARAMS_D3D12;
+
+    /**
+    * \struct NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12
+    * Parameters which are received per frame for optical flow/stereo disparity execution.
+    */
+    typedef struct _NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12
+    {
+        NvOFGPUBufferHandle             outputBuffer;                     /**< [in]: Specifies the pointer to optical flow or stereo disparity buffer handle.
+                                                                                    ::outputBuffer will be populated with optical flow in
+                                                                                    ::NV_OF_FLOW_VECTOR format or stereo disparity in 
+                                                                                    ::NV_OF_STEREO_DISPARITY format for each 
+                                                                                    ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGridSize in a frame.*/
+        NvOFGPUBufferHandle             outputCostBuffer;                 /**< [in]: Specifies the pointer to output cost calculation buffer handle. */
+        NvOFPrivDataHandle              hPrivData;                        /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        NvOFGPUBufferHandle             bwdOutputBuffer;                  /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH,
+                                                                                    this specifies the pointer to backward optical flow buffer handle.
+                                                                                    ::bwOutputBuffer will be populated with optical flow in ::NV_OF_FLOW_VECTOR format
+                                                                                    for each ::NV_OF_VECTOR_GRID_SIZE::outGidSize in a frame. */
+        NvOFGPUBufferHandle             bwdOutputCostBuffer;              /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH and
+                                                                                    ::NV_OF_INIT_PARAMS::enableOutputCost is NV_TRUE, this specifies the pointer
+                                                                                    to the backward output cost calculation buffer handle. */
+        NvOFGPUBufferHandle             globalFlowBuffer;                 /**< [in]: When ::NV_OF_INIT_PARAMS::enableGlobalFlow is set to NV_true, this specifies the
+                                                                                    pointer to the global flow buffer handle. ::globalFlowBuffer will be populated in
+                                                                                    ::NV_OF_FLOW_VECTOR format. */
+        uint32_t                        padding[2];                       /**< [in]: Reserved.  Must be set to 0. */
+        NV_OF_FENCE_POINT*              fencePoint;                       /**< [in]: Pointer to a single fence point to set after GPU operation. */
+    } NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12;
+
+    /**
+    * \brief Create an instance of NvOFHandle object.
+    *
+    * This function creates an instance of NvOFHandle object and returns status.
+    * Client is expected to release NvOFHandle resource using Destroy function call.
+    *
+    * \param [in] pD3D12Device
+    *   Client must provide set this to the ID3D12Device created by the client.
+    * \param [out] NvOFHandle*
+    *   Pointer of class ::NvOFHandle object.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OF_NOT_AVAILABLE \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWD3D12) (ID3D12Device* const pD3D12Device, NvOFHandle* hOFInstance);
+
+    /**
+    * \brief Populate the count of the DXGI_FORMATs supported.
+    *
+    * This function returns the count of the DXGI_FORMAT supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client can use this count to allocate a sufficiently large array for 
+    * querying the DXGI_FORMATS supported.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pCount
+    *  The count is returned by uint32_t* pCount
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATCOUNTD3D12) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, uint32_t* const pCount);
+
+    /**
+    * \brief Populate the array of the DXGI_FORMATs supported.
+    *
+    * This function returns the array of the DXGI_FORMATs supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client must populate surface format count prior to this call.
+    * Client must allocate sufficiently large array size for this function call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pFormat
+    *  The list is returned through client allocated array of DXGI_FORMAT.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATD3D12) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat);
+
+    /**
+    * \brief Register the app allocated ID3D12Resource with the NvOFAPI.
+    *
+    * This function registers the app allocated ID3D12Resource with the NvOFAPI and gets an opaque handle NvOFGPUBufferHandle
+    * in return. The client should call ::NvOFUnregisterResourceD3D12 with NvOFGPUBufferHandle to unregister the resource.
+    * Client need to register the ID3D12Resource with OFAPI to be able to use it in the ::NvOFExecute call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in/out] registerParams
+    *   pointer to the ::NV_OF_REGISTER_RESOURCE_PARAMS_D3D12 strcture.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFREGISTERRESOURCED3D12) (NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
+
+    /**
+    * \brief Unregister the app allocated ID3D12Resource with the NvOFAPI.
+    *
+    * This function unregisters the app allocated ID3D12Resource which is already registered with the NvOFAPI.
+    * Client needs to provied the NvOFGPUBufferHandle, which it has received in ::NvOFRegisterResourceD3D12 call.
+
+    * \param [in] unregisterParams
+    *   pointer to the ::NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12 strcture
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFUNREGISTERRESOURCED3D12) (NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* unregisterParams);
+
+    /**
+    * \brief Kick off computation of optical flow between input and reference frame.
+    *
+    * This is asynchronous function call which kicks off computation of optical flow or stereo disparity
+    * between ::NV_OF_EXECUTE_INPUT_PARAMS_D3D12::inputFrame and ::NV_OF_EXECUTE_INPUT_PARAMS_D3D12::referenceFrame and returns
+    * after submitting  execute paramaters to optical flow engine. 
+    * ::NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12::outputBuffer will be populated with optical flow or stereo disparity
+    * based on ::NV_OF_INIT_PARAMS:mode is NV_OF_MODE_OPTICALFLOW or NV_OF_MODE_STEREODISPARITY respectively.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] executeInParams
+    *   pointer to the ::NV_OF_EXECUTE_INPUT_PARAMS_D3D12 structure.
+    * \param [out] executeOutParams
+    *   pointer to the ::NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12 structure.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFEXECUTED3D12) (NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12 *executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12 *executeOutParams);
+
+    /*
+    * Defining D3D12 specific API function pointers.
+    */
+    typedef struct _NV_OF_D3D12_API_FUNCTION_LIST
+    {
+        PFNNVCREATEOPTICALFLOWD3D12                                nvCreateOpticalFlowD3D12;
+        PFNNVOFINIT                                                nvOFInit;
+        PFNNVOFGETSURFACEFORMATCOUNTD3D12                          nvOFGetSurfaceFormatCountD3D12;
+        PFNNVOFGETSURFACEFORMATD3D12                               nvOFGetSurfaceFormatD3D12;
+        PFNNVOFREGISTERRESOURCED3D12                               nvOFRegisterResourceD3D12;
+        PFNNVOFUNREGISTERRESOURCED3D12                             nvOFUnregisterResourceD3D12;
+        PFNNVOFEXECUTED3D12                                        nvOFExecuteD3D12;
+        PFNNVOFDESTROY                                             nvOFDestroy;
+        PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+        PFNNVOFGETCAPS                                             nvOFGetCaps;
+    } NV_OF_D3D12_API_FUNCTION_LIST;
+
+
+    /**
+    * \brief ::NvOFAPICreateInstanceD3D12() API is the entry point to the NvOFAPI interface.
+    *
+    * ::NvOFAPICreateInstanceD3D12() API populates functionList with function pointers to the API routines implemented by the
+    * NvOFAPI interface.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    */
+    NV_OF_STATUS NVOFAPI NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowVulkan.h b/inc/nvofapi/nvOpticalFlowVulkan.h
new file mode 100644
index 00000000..36455a6b
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowVulkan.h
@@ -0,0 +1,312 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowVulkan.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow.
+*   nvOpticalFlowVulkan.h provides Vulkan specific enums, structure definitions and function prototypes.
+*   Vulkan optical flow is not supported for the WSL(Window subsystem for Linux) architecture.
+*   Vulkan optical flow is not supported for the Stereo disparity mode.
+*   Vulkan optical flow is not supported on the Turing GPU.
+* */
+#ifndef _NV_OPTICALFLOW_VULKAN_H_
+#define _NV_OPTICALFLOW_VULKAN_H_
+#include "nvOpticalFlowCommon.h"
+#include <vulkan/vulkan.h>
+#ifdef _WIN32
+#include <vulkan/vulkan_win32.h>
+#endif
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+    /** \struct NV_OF_SYNC_VK
+    * Semaphore and value for synchronization.
+    */
+    typedef struct _NV_OF_SYNC_VK
+    {
+        VkSemaphore                     semaphore;                      /**< [in]: Timeline semaphore object used in synchronization. */
+        uint64_t                        value;                          /**< [in]: Value the fence to reach or exceed before the GPU operation or
+                                                                                   Value to set the fence to after the GPU operation. */
+    } NV_OF_SYNC_VK;
+
+    /**
+    * \struct NV_OF_REGISTER_RESOURCE_PARAMS_VK
+    * Parameters used in registering a Vulkan resource
+    */
+    typedef struct _NV_OF_REGISTER_RESOURCE_PARAMS_VK
+    {
+		VkImage                         image;                          /**< [in]: Vulkan resource that need to be registered. */
+		VkFormat                        format;                         /**< [in]: Vulkan resource format. */
+        NvOFGPUBufferHandle*            hOFGpuBuffer;                   /**< [in]: Pointer to the opaque handle of the registered resource. */
+    } NV_OF_REGISTER_RESOURCE_PARAMS_VK;
+
+    /**
+    * \struct NV_OF_UNREGISTER_RESOURCE_PARAMS_VK
+    * Parameters used in unregistering a Vulkan resource
+    */
+    typedef struct _NV_OF_UNREGISTER_RESOURCE_PARAMS_VK
+    {
+        NvOFGPUBufferHandle             hOFGpuBuffer;                   /**< [in]: Registered handle of the resource that need to be unregistered. */
+    } NV_OF_UNREGISTER_RESOURCE_PARAMS_VK;
+
+    /**
+    * \struct NV_OF_EXECUTE_INPUT_PARAMS_VK
+    * Parameters which are sent per frame for optical flow execution.
+    */
+    typedef struct _NV_OF_EXECUTE_INPUT_PARAMS_VK
+    {
+        NvOFGPUBufferHandle             inputFrame;                      /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the input frame. */
+        NvOFGPUBufferHandle             referenceFrame;                  /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the reference frame. */
+        NvOFGPUBufferHandle             externalHints;                   /**< [in]: It is an optional input, This field will be considered if client had set ::NV_OF_INIT_PARAMS::enableExternalHint flag.
+                                                                                    Client can pass some available predictors as hints. 
+                                                                                    Optical flow driver will search around those hints to optimize flow vectors quality.
+                                                                                    Expected hint buffer format is ::NV_OF_FLOW_VECTOR for ::NV_OF_MODE_OPTICALFLOW
+                                                                                    each ::NV_OF_INIT_PARAMS::hintGridSize in a frame. */
+        NV_OF_BOOL                      disableTemporalHints;            /**< [in]: Temporal hints yield better accuracy flow vectors when running on successive frames of a continuous video (without major scene changes).
+                                                                                    When disableTemporalHints = 0, optical flow vectors from previous NvOFExecute call are automatically used as hints for the current NvOFExecute call.
+                                                                                    However, when running optical flow on pairs of images which are completely independent of each other, temporal hints are useless
+                                                                                    and in fact, they will degrade the quality. Therefore, it is recommended to set disableTemporalHints = 1 in this case.*/
+        uint32_t                        padding;                         /**< [in]: Padding.  Must be set to 0. */
+        NvOFPrivDataHandle              hPrivData;                       /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        uint32_t                        padding2;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numRois;                         /**< [in]: Number of ROIs. */
+        NV_OF_ROI_RECT*                 roiData;                         /**< [in]: Pointer to the NV_OF_ROI_RECTs data.  Size of this buffer should be atleast numROIs * sizeof(NV_OF_ROI_RECT). */
+        uint32_t                        padding3;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numWaitSyncs;                    /**< [in]: Number of semaphores to reach or exceed before GPU operation starts.
+                                                                                    Client can use different fence points for different buffers syncrhonization.  Client shall speicify all the fence points
+                                                                                    used for the buffers synchronization which will be used in Optical Flow estimation. */
+        NV_OF_SYNC_VK*                  pWaitSyncs;                      /**< [in]: Pointer to an array of semaphores to reach or exceed before GPU operation starts. */
+    } NV_OF_EXECUTE_INPUT_PARAMS_VK;
+
+    /**
+    * \struct NV_OF_EXECUTE_OUTPUT_PARAMS_VK
+    * Parameters which are received per frame for optical flow/stereo disparity execution.
+    */
+    typedef struct _NV_OF_EXECUTE_OUTPUT_PARAMS_VK
+    {
+        NvOFGPUBufferHandle             outputBuffer;                     /**< [in]: Specifies the pointer to optical flow buffer handle.
+                                                                                    ::outputBuffer will be populated with optical flow in
+                                                                                    ::NV_OF_FLOW_VECTOR format for each ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGridSize in a frame.*/
+        NvOFGPUBufferHandle             outputCostBuffer;                 /**< [in]: Specifies the pointer to output cost calculation buffer handle. */
+        NvOFPrivDataHandle              hPrivData;                        /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        NvOFGPUBufferHandle             bwdOutputBuffer;                  /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH,
+                                                                                    this specifies the pointer to backward optical flow buffer handle.
+                                                                                    ::bwOutputBuffer will be populated with optical flow in ::NV_OF_FLOW_VECTOR format
+                                                                                    for each ::NV_OF_VECTOR_GRID_SIZE::outGidSize in a frame. */
+        NvOFGPUBufferHandle             bwdOutputCostBuffer;              /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH and
+                                                                                    ::NV_OF_INIT_PARAMS::enableOutputCost is NV_TRUE, this specifies the pointer
+                                                                                    to the backward output cost calculation buffer handle. */
+        NvOFGPUBufferHandle             globalFlowBuffer;                 /**< [in]: When ::NV_OF_INIT_PARAMS::enableGlobalFlow is set to NV_true, this specifies the
+                                                                                    pointer to the global flow buffer handle. ::globalFlowBuffer will be populated in
+                                                                                    ::NV_OF_FLOW_VECTOR format. */
+        uint32_t                        padding[2];                       /**< [in]: Reserved.  Must be set to 0. */
+        NV_OF_SYNC_VK*                  pSignalSync;                      /**< [in]: Pointer to a single semaphore to signal after GPU operation. */
+    } NV_OF_EXECUTE_OUTPUT_PARAMS_VK;
+
+    /**
+    * \brief Create an instance of NvOFHandle object.
+    *
+    * This function creates an instance of NvOFHandle object and returns status.
+    * Client is expected to release NvOFHandle resource using Destroy function call.
+    *
+    * \param [in] instance
+    *   Client must set this to the vulkan instance used by the client.
+    * \param [in] physicalDevice
+    *   Client must set this to the vulkan physical device used by the client.
+    * \param [in] device
+    *   Client must set this to the vulkan device created by the client.
+    * \param [out] NvOFHandle*
+    *   Pointer of class ::NvOFHandle object.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OF_NOT_AVAILABLE \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWVK) (VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, NvOFHandle* hOFInstance);
+
+    /**
+    * \brief Populate the count of the VkFormat's supported.
+    *
+    * This function returns the count of the VkFormat's supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE_OPTICALFLOW mode. Client can use this count to allocate a sufficiently large array for 
+    * querying the VkFormat's supported.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client. Note that NV_OF_MODE_STEREODISPARITY mode is not supported for the Vulkan.
+    * \param [out] pCount
+    *  The count is returned by uint32_t* pCount
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATCOUNTVK) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, uint32_t* const pCount);
+
+    /**
+    * \brief Populate the array of the VkFormat's supported.
+    *
+    * This function returns the array of the VkFormat's supported for the given NV_OF_BUFFER_USAGE and ::NV_OF_MODE_OPTICALFLOW mode.
+    * Client must populate surface format count prior to this call.
+    * Client must allocate sufficiently large array size for this function call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client. Note that NV_OF_MODE_STEREODISPARITY mode is not supported for the Vulkan.
+    * \param [out] pFormat
+    *  The list is returned through client allocated array of VkFormat's.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATVK) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat);
+
+    /**
+    * \brief Register the app allocated vulkan resource with the NvOFAPI.
+    *
+    * This function registers the app allocated vulkan resource with the NvOFAPI and gets an opaque handle NvOFGPUBufferHandle
+    * in return. The client should call ::NvOFUnregisterResourceVk with NvOFGPUBufferHandle to unregister the resource.
+    * Client need to register the vulkan resource with OFAPI to be able to use it in the ::NvOFExecute call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in/out] registerParams
+    *   pointer to the ::NV_OF_REGISTER_RESOURCE_PARAMS_VK structure.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFREGISTERRESOURCEVK) (NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
+
+    /**
+    * \brief Unregister the app allocated vulkan resource with the NvOFAPI.
+    *
+    * This function unregisters the app allocated vulkan resource which is already registered with the NvOFAPI.
+    * Client needs to provied the NvOFGPUBufferHandle, which it has received in ::NvOFRegisterResourceVk call.
+
+    * \param [in] unregisterParams
+    *   pointer to the ::NV_OF_UNREGISTER_RESOURCE_PARAMS_VK strcture
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFUNREGISTERRESOURCEVK) (NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* unregisterParams);
+
+    /**
+    * \brief Kick off computation of optical flow between input and reference frame.
+    *
+    * This is asynchronous function call which kicks off computation of optical flow.
+    * between ::NV_OF_EXECUTE_INPUT_PARAMS_VK::inputFrame and ::NV_OF_EXECUTE_INPUT_PARAMS_VK::referenceFrame and returns
+    * after submitting  execute paramaters to optical flow engine. 
+    * ::NV_OF_EXECUTE_OUTPUT_PARAMS_VK::outputBuffer will be populated with optical flow.
+    * based on ::NV_OF_INIT_PARAMS:mode is NV_OF_MODE_OPTICALFLOW.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] executeInParams
+    *   pointer to the ::NV_OF_EXECUTE_INPUT_PARAMS_VK structure.
+    * \param [out] executeOutParams
+    *   pointer to the ::NV_OF_EXECUTE_OUTPUT_PARAMS_VK structure.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFEXECUTEVK) (NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK *executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK *executeOutParams);
+
+    /*
+    * Defining Vulkan specific API function pointers.
+    */
+    typedef struct _NV_OF_VK_API_FUNCTION_LIST
+    {
+        PFNNVCREATEOPTICALFLOWVK                                   nvCreateOpticalFlowVk;
+        PFNNVOFINIT                                                nvOFInit;
+        PFNNVOFGETSURFACEFORMATCOUNTVK                             nvOFGetSurfaceFormatCountVk;
+        PFNNVOFGETSURFACEFORMATVK                                  nvOFGetSurfaceFormatVk;
+        PFNNVOFREGISTERRESOURCEVK                                  nvOFRegisterResourceVk;
+        PFNNVOFUNREGISTERRESOURCEVK                                nvOFUnregisterResourceVk;
+        PFNNVOFEXECUTEVK                                           nvOFExecuteVk;
+        PFNNVOFDESTROY                                             nvOFDestroy;
+        PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+        PFNNVOFGETCAPS                                             nvOFGetCaps;
+    } NV_OF_VK_API_FUNCTION_LIST;
+
+    /**
+    * \brief ::NvOFAPICreateInstanceVk() API is the entry point to the NvOFAPI interface.
+    *
+    * ::NvOFAPICreateInstanceVk() API populates functionList with function pointers to the API routines implemented by the
+    * NvOFAPI interface.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    */
+
+	NV_OF_STATUS NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif

From b7fba65ebf6feb3ab765291dda6709daafe1d078 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Sat, 12 Oct 2024 16:56:28 -0700
Subject: [PATCH] vkd3d-proton: Update interfaces from c9a3cb05

Signed-off-by: Liam Middlebrook <lmiddlebrook@nvidia.com>
---
 src/vkd3d-proton/vkd3d-proton_interfaces.h | 58 +++++++++++++++++++++-
 1 file changed, 57 insertions(+), 1 deletion(-)

diff --git a/src/vkd3d-proton/vkd3d-proton_interfaces.h b/src/vkd3d-proton/vkd3d-proton_interfaces.h
index 1ab71962..17670fcf 100644
--- a/src/vkd3d-proton/vkd3d-proton_interfaces.h
+++ b/src/vkd3d-proton/vkd3d-proton_interfaces.h
@@ -26,7 +26,8 @@
 enum D3D12_VK_EXTENSION : uint32_t {
     D3D12_VK_NVX_BINARY_IMPORT = 0x1,
     D3D12_VK_NVX_IMAGE_VIEW_HANDLE = 0x2,
-    D3D12_VK_NV_LOW_LATENCY_2 = 0x3
+    D3D12_VK_NV_LOW_LATENCY_2 = 0x3,
+    D3D12_VK_NV_OPTICAL_FLOW = 0x4
 };
 
 enum D3D12_OUT_OF_BAND_CQ_TYPE : uint32_t {
@@ -84,6 +85,59 @@ ID3D12DeviceExt : public IUnknown {
         D3D12_UAV_INFO * uav_info) = 0;
 };
 
+MIDL_INTERFACE("39da4e09-bd1c-4198-9fae-86bbe3be41fd")
+ID3D12DXVKInteropDevice : public IUnknown {
+    virtual HRESULT STDMETHODCALLTYPE GetDXGIAdapter(
+        REFIID iid,
+        void** object) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetInstanceExtensions(
+        UINT * extensionCount,
+        const char** extensions) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetDeviceExtensions(
+        UINT * extensionCount,
+        const char** extensions) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetDeviceFeatures(
+        const VkPhysicalDeviceFeatures2** features) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanHandles(
+        VkInstance * vk_instance,
+        VkPhysicalDevice * vk_physical_device,
+        VkDevice * vk_device) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanQueueInfo(
+        ID3D12CommandQueue * queue,
+        VkQueue * vkQueue,
+        UINT32 * vkFamily) = 0;
+
+    virtual void STDMETHODCALLTYPE GetVulkanImageLayout(
+        ID3D12Resource * resource,
+        D3D12_RESOURCE_STATES state,
+        VkImageLayout * layout) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanResourceInfo(
+        ID3D12Resource * resource,
+        UINT64 * handle,
+        UINT64 * offset) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE LockCommandQueue(
+        ID3D12CommandQueue * queue) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE UnlockCommandQueue(
+        ID3D12CommandQueue * queue) = 0;
+};
+MIDL_INTERFACE("902d8115-59eb-4406-9518-fe00f991ee65")
+ID3D12DXVKInteropDevice1 : public ID3D12DXVKInteropDevice {
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanResourceInfo1(ID3D12Resource * resource, UINT64 * vk_handle, UINT64 * buffer_offset, VkFormat * format);
+    virtual HRESULT STDMETHODCALLTYPE CreateInteropCommandQueue(const D3D12_COMMAND_QUEUE_DESC* pDesc, UINT32 vk_queue_family_index, ID3D12CommandQueue** ppQueue);
+    virtual HRESULT STDMETHODCALLTYPE CreateInteropCommandAllocator(D3D12_COMMAND_LIST_TYPE type, UINT32 vk_queue_family_index, ID3D12CommandAllocator * *ppAllocator);
+    virtual HRESULT STDMETHODCALLTYPE BeginVkCommandBufferInterop(ID3D12CommandList * pCmdList, VkCommandBuffer * pCommandBuffer);
+    virtual HRESULT STDMETHODCALLTYPE EndVkCommandBufferInterop(ID3D12CommandList * pCmdList);
+};
+
 MIDL_INTERFACE("77a86b09-2bea-4801-b89a-37648e104af1")
 ID3D12GraphicsCommandListExt : public IUnknown {
     virtual HRESULT STDMETHODCALLTYPE GetVulkanHandle(
@@ -120,6 +174,8 @@ ID3D12CommandQueueExt : public IUnknown {
 
 #ifndef _MSC_VER
 __CRT_UUID_DECL(ID3D12DeviceExt, 0x11ea7a1a, 0x0f6a, 0x49bf, 0xb6, 0x12, 0x3e, 0x30, 0xf8, 0xe2, 0x01, 0xdd);
+__CRT_UUID_DECL(ID3D12DXVKInteropDevice, 0x39da4e09, 0xbd1c, 0x4198, 0x9f, 0xae, 0x86, 0xbb, 0xe3, 0xbe, 0x41, 0xfd);
+__CRT_UUID_DECL(ID3D12DXVKInteropDevice1, 0x902d8115, 0x59eb, 0x4406, 0x95, 0x18, 0xfe, 0x00, 0xf9, 0x91, 0xee, 0x65);
 __CRT_UUID_DECL(ID3D12GraphicsCommandListExt, 0x77a86b09, 0x2bea, 0x4801, 0xb8, 0x9a, 0x37, 0x64, 0x8e, 0x10, 0x4a, 0xf1);
 __CRT_UUID_DECL(ID3D12GraphicsCommandListExt1, 0xd53b0028, 0xafb4, 0x4b65, 0xa4, 0xf1, 0x7b, 0x0d, 0xaa, 0xa6, 0x5b, 0x4f);
 __CRT_UUID_DECL(ID3D12CommandQueueExt, 0x40ed3f96, 0xe773, 0xe9bc, 0xfc, 0x0c, 0xe9, 0x55, 0x60, 0xc9, 0x9a, 0xd6);

From a13b0f5b88c4486110cff15b162de7d1dd12299e Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Sat, 12 Oct 2024 16:57:19 -0700
Subject: [PATCH] nvofapi: Introduce library

Introduce an implementation of the NVIDIA Optical Flow API layered on
top of VK_NV_optical_flow. This implementation covers the D3D12 and
Vulkan backends for NVOFAPI.

Signed-off-by: Liam Middlebrook <lmiddlebrook@nvidia.com>
---
 src/meson.build                     |  16 ++
 src/nvofapi/nvofapi.h               | 177 ++++++++++++++++++++++
 src/nvofapi/nvofapi_common.cpp      | 209 ++++++++++++++++++++++++++
 src/nvofapi/nvofapi_d3d12.cpp       | 181 ++++++++++++++++++++++
 src/nvofapi/nvofapi_entrypoints.cpp | 223 ++++++++++++++++++++++++++++
 src/nvofapi/nvofapi_vulkan.cpp      | 168 +++++++++++++++++++++
 6 files changed, 974 insertions(+)
 create mode 100644 src/nvofapi/nvofapi.h
 create mode 100644 src/nvofapi/nvofapi_common.cpp
 create mode 100644 src/nvofapi/nvofapi_d3d12.cpp
 create mode 100644 src/nvofapi/nvofapi_entrypoints.cpp
 create mode 100644 src/nvofapi/nvofapi_vulkan.cpp

diff --git a/src/meson.build b/src/meson.build
index 18b125bc..9d40fa1e 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -31,3 +31,19 @@ nvapi_dll = shared_library('nvapi'+target_suffix, [ nvapi_src, dxvk_nvapi_versio
   dependencies        : [ lib_dxgi, lib_d3d11, lib_version ],
   include_directories : [ nvapi_headers, vk_headers ],
   install             : true)
+
+nvofapi_src = files([
+  'util/util_string.cpp',
+  'util/util_env.cpp',
+  'util/util_log.cpp',
+  'nvofapi/nvofapi_common.cpp',
+  'nvofapi/nvofapi_d3d12.cpp',
+  'nvofapi/nvofapi_vulkan.cpp',
+  'nvofapi/nvofapi_entrypoints.cpp'
+])
+
+nvofapi_dll = shared_library('nvofapi'+target_suffix, [ nvofapi_src, dxvk_nvapi_version ],
+  name_prefix         : '',
+  dependencies        : [ lib_version ],
+  include_directories : [ nvapi_headers, vk_headers ],
+  install             : true)
diff --git a/src/nvofapi/nvofapi.h b/src/nvofapi/nvofapi.h
new file mode 100644
index 00000000..d74d028b
--- /dev/null
+++ b/src/nvofapi/nvofapi.h
@@ -0,0 +1,177 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "vkd3d-proton/vkd3d-proton_interfaces.h"
+
+#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+namespace nvofapi {
+    constexpr uint32_t CMDS_IN_FLIGHT = 1;
+    class NvOFInstance;
+    class NvOFImageVk;
+
+    class NvOFInstance {
+
+      protected:
+        VkInstance m_vkInstance;
+        VkPhysicalDevice m_vkPhysicalDevice;
+        VkDevice m_vkDevice;
+        VkOpticalFlowSessionNV m_vkOfaSession{};
+        PFN_vkGetInstanceProcAddr m_vkGetInstanceProcAddr{};
+        PFN_vkGetDeviceProcAddr m_vkGetDeviceProcAddr{};
+        PFN_vkCreateOpticalFlowSessionNV m_vkCreateOpticalFlowSessionNV{};
+        PFN_vkDestroyOpticalFlowSessionNV m_vkDestroyOpticalFlowSessionNV{};
+        PFN_vkCreateImageView m_vkCreateImageView{};
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+        PFN_vkBindOpticalFlowSessionImageNV m_vkBindOpticalFlowSessionImageNV{};
+        PFN_vkCmdOpticalFlowExecuteNV m_vkCmdOpticalFlowExecuteNV{};
+
+        PFN_vkGetPhysicalDeviceQueueFamilyProperties m_vkGetPhysicalDeviceQueueFamilyProperties;
+        HMODULE m_library;
+
+        uint32_t GetVkOFAQueue();
+
+      public:
+        VkDevice GetVkDevice() { return m_vkDevice; }
+        VkOpticalFlowSessionNV GetOfaSession() { return m_vkOfaSession; }
+
+        NvOFInstance(VkInstance vkInstance,
+            VkPhysicalDevice vkPhysicalDevice,
+            VkDevice vkDevice) : m_vkInstance(vkInstance),
+                                 m_vkPhysicalDevice(vkPhysicalDevice), m_vkDevice(vkDevice) {
+        }
+
+        NvOFInstance() {};
+        virtual ~NvOFInstance() {
+            m_vkDestroyOpticalFlowSessionNV(m_vkDevice, m_vkOfaSession, nullptr);
+            FreeLibrary(m_library);
+        }
+
+        NV_OF_STATUS getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size);
+
+        NV_OF_STATUS InitSession(const NV_OF_INIT_PARAMS* initParams);
+
+        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
+
+        NV_OF_STATUS BindImageToSession(NvOFImageVk* image, VkOpticalFlowSessionBindingPointNV bindingPoint);
+
+        NV_OF_STATUS RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
+    };
+
+    class NvOFImageVk {
+      private:
+        NvOFInstance* m_ofInstance;
+        VkImage m_image;
+        VkImageView m_imageView;
+        VkFormat m_format;
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+
+      public:
+        VkImageView ImageView() { return m_imageView; }
+        NvOFImageVk(NvOFInstance* ofInstance, VkImage image, VkFormat format) : m_ofInstance(ofInstance), m_image(image), m_format(format) {
+        }
+        ~NvOFImageVk() {
+            m_vkDestroyImageView(m_ofInstance->GetVkDevice(), m_imageView, nullptr);
+        }
+
+        bool Initialize(PFN_vkCreateImageView CreateImageView,
+            PFN_vkDestroyImageView DestroyImageView);
+    };
+
+    class NvOFInstanceVk : public NvOFInstance {
+      public:
+        NvOFInstanceVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice) : NvOFInstance(vkInstance, vkPhysicalDevice, vkDevice) {
+        }
+        virtual ~NvOFInstanceVk() {
+            // free cmdbuffers
+            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, 8, m_commandBuffers);
+            m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
+        }
+        bool Initialize();
+
+        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
+
+      private:
+        VkQueue m_queue;
+        VkCommandPool m_commandPool;
+        PFN_vkCreateCommandPool m_vkCreateCommandPool;
+        PFN_vkDestroyCommandPool m_vkDestroyCommandPool;
+        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT]; // eight ought to be more than
+                                                          // enough for anybody ;)
+
+        PFN_vkAllocateCommandBuffers m_vkAllocateCommandBuffers;
+        PFN_vkFreeCommandBuffers m_vkFreeCommandBuffers;
+
+        uint32_t m_cmdBufIndex = 0;
+        PFN_vkResetCommandBuffer m_vkResetCommandBuffer;
+        PFN_vkBeginCommandBuffer m_vkBeginCommandBuffer;
+        PFN_vkEndCommandBuffer m_vkEndCommandBuffer;
+
+        PFN_vkGetDeviceQueue m_vkGetDeviceQueue;
+        PFN_vkQueueSubmit2 m_vkQueueSubmit2{};
+    };
+
+    class NvOFInstanceD3D12 : public NvOFInstance {
+      private:
+        ID3D12DXVKInteropDevice1* m_device{};
+        ID3D12DeviceExt* m_deviceExt{};
+        ID3D12Device4* m_d3ddevice{};
+        ID3D12CommandQueue* m_commandQueue{};
+        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
+        uint32_t m_cmdListIndex = 0;
+        ID3D12CommandAllocator* m_cmdAllocator{};
+
+        uint32_t m_vkQueueFamilyIndex = 0;
+
+      public:
+        bool Initialize();
+        NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
+        virtual ~NvOFInstanceD3D12() {
+            for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+                if (m_cmdList[i])
+                    m_cmdList[i]->Release();
+            }
+            if (m_cmdAllocator)
+                m_cmdAllocator->Release();
+
+            if (m_commandQueue)
+                m_commandQueue->Release();
+
+            if (m_deviceExt)
+                m_deviceExt->Release();
+
+            if (m_d3ddevice)
+                m_d3ddevice->Release();
+
+            if (m_device)
+                m_device->Release();
+        }
+
+        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
+
+        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
+    };
+}
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
new file mode 100644
index 00000000..4a54cd41
--- /dev/null
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -0,0 +1,209 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "util/util_log.h"
+#include "util/util_string.h"
+
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+#include "nvofapi.h"
+
+namespace nvofapi {
+
+    typedef struct NV_OF_PRIV_DATA {
+        uint32_t size;
+        uint32_t id;
+        void* data;
+    } NV_OF_PRIV_DATA;
+
+    typedef struct NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS {
+        NvOFGPUBufferHandle input[6];
+        NvOFGPUBufferHandle reference[6];
+        uint8_t reserved[100];
+    } NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS;
+
+    constexpr uint32_t NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS = 6;
+
+    uint32_t NvOFInstance::GetVkOFAQueue() {
+        uint32_t count = 0;
+        m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, nullptr);
+        VkQueueFamilyProperties* queueFamProps = (VkQueueFamilyProperties*)calloc(sizeof(VkQueueFamilyProperties), count);
+        m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, queueFamProps);
+
+        for (int i = 0; i < count; i++) {
+            if (queueFamProps[i].queueFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
+                free(queueFamProps);
+                return i;
+            }
+        }
+        free(queueFamProps);
+        return -1;
+    }
+
+    NV_OF_STATUS NvOFInstance::InitSession(const NV_OF_INIT_PARAMS* initParams) {
+        dxvk::log::info(
+            dxvk::str::format("OFSessionInit params:",
+                " width: ", initParams->width,
+                " height: ", initParams->height,
+                " outGrid: ", initParams->outGridSize,
+                " hintGrid: ", initParams->hintGridSize,
+                " mode: ", initParams->mode,
+                " perfLevel: ", initParams->perfLevel,
+                " enableExternalHints: ", initParams->enableExternalHints,
+                " enableOutputCost: ", initParams->enableOutputCost,
+                " hPrivData: ", initParams->hPrivData,
+                " enableRoi: ", initParams->enableRoi,
+                " predDirection: ", initParams->predDirection,
+                " enableGlobalFlow: ", initParams->enableGlobalFlow,
+                " inputBufferFormat: ", initParams->inputBufferFormat));
+
+        VkOpticalFlowSessionCreateInfoNV createInfo = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV};
+        createInfo.width = initParams->width;
+        createInfo.height = initParams->height;
+        createInfo.outputGridSize = VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV;
+
+        switch (initParams->perfLevel) {
+            case NV_OF_PERF_LEVEL_SLOW:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV;
+                break;
+            case NV_OF_PERF_LEVEL_MEDIUM:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV;
+                break;
+            case NV_OF_PERF_LEVEL_FAST:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV;
+                break;
+            default:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV;
+                break;
+        }
+
+        switch (initParams->inputBufferFormat) {
+            case NV_OF_BUFFER_FORMAT_GRAYSCALE8:
+                createInfo.imageFormat = VK_FORMAT_R8_UNORM;
+                break;
+            case NV_OF_BUFFER_FORMAT_NV12:
+                createInfo.imageFormat = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
+                break;
+            case NV_OF_BUFFER_FORMAT_ABGR8:
+                createInfo.imageFormat = VK_FORMAT_B8G8R8A8_UNORM;
+                break;
+        }
+
+        // Need to get the size/id for the private data to pass it along to VK...
+        VkOpticalFlowSessionCreatePrivateDataInfoNV privData = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV};
+        privData.size = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->size;
+        privData.id = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->id;
+        privData.pPrivateData = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->data;
+
+        createInfo.pNext = &privData;
+
+        auto ret = m_vkCreateOpticalFlowSessionNV(m_vkDevice, &createInfo, NULL, &m_vkOfaSession);
+
+        if (ret == VK_SUCCESS) {
+            return NV_OF_SUCCESS;
+        }
+
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFImageVk* image, VkOpticalFlowSessionBindingPointNV bindingPoint) {
+        VkImageLayout layout = VK_IMAGE_LAYOUT_GENERAL;
+
+        if (!image)
+            return NV_OF_ERR_GENERIC;
+
+        auto ret = m_vkBindOpticalFlowSessionImageNV(m_vkDevice,
+            m_vkOfaSession,
+            bindingPoint,
+            image->ImageView(),
+            layout);
+        if (ret != VK_SUCCESS) {
+            return NV_OF_ERR_GENERIC;
+        }
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NvOFInstance::getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size) {
+        if (param == NV_OF_CAPS_SUPPORTED_OUTPUT_GRID_SIZES) {
+            *size = 1;
+            if (capsVal) {
+                *capsVal = NV_OF_OUTPUT_VECTOR_GRID_SIZE_4;
+            }
+
+            // XXX[ljm] query VkPhysicalDevice for actual support
+            return NV_OF_SUCCESS;
+        }
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NvOFInstance::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        NvOFImageVk* nvOFImage = new NvOFImageVk(this, registerParams->image, registerParams->format);
+        nvOFImage->Initialize(m_vkCreateImageView, m_vkDestroyImageView);
+        *registerParams->hOFGpuBuffer = reinterpret_cast<NvOFGPUBufferHandle>(nvOFImage);
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NvOFInstance::RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf) {
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(inParams->inputFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(inParams->referenceFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->outputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->outputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->bwdOutputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->bwdOutputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->globalFlowBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
+        // Support INPUT_MIPS execute priv data
+        if (((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
+            NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS* mipData = ((NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS*)((NV_OF_PRIV_DATA*)inParams->hPrivData)->data);
+            for (int i = 0; i < 6; i++) {
+                if (mipData->input[i] && mipData->reference[i]) {
+                    BindImageToSession(reinterpret_cast<NvOFImageVk*>(mipData->input[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+                    BindImageToSession(reinterpret_cast<NvOFImageVk*>(mipData->reference[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+                }
+            }
+        }
+        VkRect2D* regions;
+
+        if (inParams->numRois) {
+            regions = (VkRect2D*)calloc(sizeof(VkRect2D), inParams->numRois);
+            for (int i = 0; i < inParams->numRois; i++) {
+                regions[i].offset.x = inParams->roiData[i].start_x;
+                regions[i].offset.y = inParams->roiData[i].start_y;
+                regions[i].extent.width = inParams->roiData[i].width;
+                regions[i].extent.height = inParams->roiData[i].height;
+            }
+        }
+
+        VkOpticalFlowExecuteInfoNV ofaExecuteInfo = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV};
+        ofaExecuteInfo.regionCount = inParams->numRois;
+        ofaExecuteInfo.pRegions = regions;
+
+        if (inParams->disableTemporalHints) {
+            ofaExecuteInfo.flags |= VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
+        }
+
+        m_vkCmdOpticalFlowExecuteNV(cmdBuf, m_vkOfaSession, &ofaExecuteInfo);
+
+        free(regions);
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi/nvofapi_d3d12.cpp b/src/nvofapi/nvofapi_d3d12.cpp
new file mode 100644
index 00000000..f224ea05
--- /dev/null
+++ b/src/nvofapi/nvofapi_d3d12.cpp
@@ -0,0 +1,181 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <cassert>
+
+#include "util/util_log.h"
+#include "util/util_string.h"
+
+#include "vkd3d-proton/vkd3d-proton_interfaces.h"
+#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
+
+#include "nvofapi.h"
+
+namespace nvofapi {
+
+    NvOFInstanceD3D12::NvOFInstanceD3D12(ID3D12Device* pD3D12Device) {
+        // Query for the extension interface
+        // Grab the vk triad
+        HRESULT status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_device));
+
+        if (S_OK != status) {
+            throw std::invalid_argument("Failed to query interface for m_device");
+        }
+
+        m_device->GetVulkanHandles(&m_vkInstance,
+            &m_vkPhysicalDevice,
+            &m_vkDevice);
+
+        status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_d3ddevice));
+
+        if (S_OK != status) {
+            throw std::invalid_argument("Failed to query interface for m_d3ddevice");
+        }
+
+        status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_deviceExt));
+
+        if (S_OK != status) {
+            throw std::invalid_argument("Failed to query interface for m_deviceExt");
+        }
+    }
+
+    bool NvOFInstanceD3D12::Initialize() {
+        m_library = LoadLibraryA("winevulkan.dll");
+        if (!m_library) {
+            return false;
+        }
+
+        // Confirm that OPTICAL_FLOW extension is available
+        if (!m_deviceExt->GetExtensionSupport(D3D12_VK_NV_OPTICAL_FLOW)) {
+            dxvk::log::info("Missing VK_NV_optical_flow extension!");
+            return false;
+        }
+
+        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)GetProcAddress(m_library, "vkGetInstanceProcAddr");
+        m_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetDeviceProcAddr");
+        m_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
+
+        m_vkCreateImageView = (PFN_vkCreateImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateImageView");
+        m_vkDestroyImageView = (PFN_vkDestroyImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyImageView");
+
+        // Populate the optical flow related info here
+        // fail to create if optical flow extension is unsupported
+        m_vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateOpticalFlowSessionNV");
+        m_vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyOpticalFlowSessionNV");
+        m_vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkBindOpticalFlowSessionImageNV");
+        m_vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCmdOpticalFlowExecuteNV");
+
+        // Get the OFA queue
+        m_vkQueueFamilyIndex = GetVkOFAQueue();
+
+        D3D12_COMMAND_QUEUE_DESC desc{};
+        if (m_device->CreateInteropCommandQueue(&desc, m_vkQueueFamilyIndex, &m_commandQueue)
+            != S_OK) {
+            return false;
+        }
+        if (m_device->CreateInteropCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, m_vkQueueFamilyIndex, &m_cmdAllocator)
+            != S_OK) {
+            return false;
+        }
+        for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+            if (m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdList[i]))
+                != S_OK) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    NV_OF_STATUS NvOFInstanceD3D12::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        NV_OF_REGISTER_RESOURCE_PARAMS_VK vkParams{};
+        dxvk::log::info(
+            dxvk::str::format("RegisterBuffer DX: resource: ",
+                registerParams->resource, " inputFencePoint: ",
+                registerParams->inputFencePoint.fence, " ouputFencePoint: ",
+                registerParams->outputFencePoint.fence));
+        // Convert D3D12 params to VK params
+        //
+        // ID3D12Resource -> VK Image / VkFormat pair
+        vkParams.hOFGpuBuffer = registerParams->hOFGpuBuffer;
+        uint64_t offset;
+        m_device->GetVulkanResourceInfo1(registerParams->resource, (UINT64*)&vkParams.image, &offset, &vkParams.format);
+
+        // ID3D12 fence to timeline semaphore
+        // no inputFencePoint/outputFencePoint equivalents for VK, leaving as
+        // no-op :(
+        assert(registerParams->inputFencePoint.fence == nullptr);
+        assert(registerParams->inputFencePoint.value == 0);
+        assert(registerParams->outputFencePoint.fence == nullptr);
+        assert(registerParams->outputFencePoint.value == 0);
+        return ((NvOFInstance*)this)->RegisterBuffer(&vkParams);
+    }
+
+    NV_OF_STATUS NvOFInstanceD3D12::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams) {
+        // Convert the D3D12 parameters to VK parameters
+        NV_OF_EXECUTE_INPUT_PARAMS_VK vkInputParams{};
+        NV_OF_EXECUTE_OUTPUT_PARAMS_VK vkOutputParams{};
+
+        vkInputParams.inputFrame = inParams->inputFrame;
+        vkInputParams.referenceFrame = inParams->referenceFrame;
+        vkInputParams.externalHints = inParams->externalHints;
+        vkInputParams.disableTemporalHints = inParams->disableTemporalHints;
+        vkInputParams.hPrivData = inParams->hPrivData;
+        vkInputParams.numRois = inParams->numRois;
+        vkInputParams.roiData = inParams->roiData;
+
+        vkOutputParams.outputBuffer = outParams->outputBuffer;
+        vkOutputParams.outputCostBuffer = outParams->outputCostBuffer;
+        vkOutputParams.hPrivData = outParams->hPrivData;
+        vkOutputParams.bwdOutputBuffer = outParams->bwdOutputBuffer;
+        vkOutputParams.bwdOutputCostBuffer = outParams->bwdOutputCostBuffer;
+        vkOutputParams.globalFlowBuffer = outParams->globalFlowBuffer;
+
+        // Use vkd3d-proton's interop functionality to grab a VkCommandBuffer
+        // that we record our commands into. Work submission and syncrhonization
+        // happens using D3D12.
+        m_cmdList[m_cmdListIndex]->Reset(m_cmdAllocator, nullptr);
+
+        for (int i = 0; i < inParams->numFencePoints; i++) {
+            m_commandQueue->Wait(inParams->fencePoint[i].fence, inParams->fencePoint[i].value);
+        }
+
+        VkCommandBuffer vkCmdBuf;
+        m_device->BeginVkCommandBufferInterop(m_cmdList[m_cmdListIndex], &vkCmdBuf);
+
+        this->RecordCmdBuf(&vkInputParams, &vkOutputParams, vkCmdBuf);
+
+        m_device->EndVkCommandBufferInterop(m_cmdList[m_cmdListIndex]);
+        m_cmdList[m_cmdListIndex]->Close();
+
+        m_commandQueue->ExecuteCommandLists(1, (ID3D12CommandList**)&m_cmdList[m_cmdListIndex]);
+
+        m_commandQueue->Signal(outParams->fencePoint->fence, outParams->fencePoint->value);
+
+        m_cmdListIndex++;
+        if (m_cmdListIndex >= CMDS_IN_FLIGHT)
+            m_cmdListIndex = 0;
+
+        return NV_OF_SUCCESS;
+    }
+
+}
diff --git a/src/nvofapi/nvofapi_entrypoints.cpp b/src/nvofapi/nvofapi_entrypoints.cpp
new file mode 100644
index 00000000..65eb9144
--- /dev/null
+++ b/src/nvofapi/nvofapi_entrypoints.cpp
@@ -0,0 +1,223 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "nvofapi.h"
+
+#include "util/util_env.h"
+#include "util/util_log.h"
+#include "util/util_string.h"
+#include "../version.h"
+
+extern "C" {
+
+    // Common entrypoints
+    NV_OF_STATUS NVOFAPI OFSessionInit(NvOFHandle hOf, const NV_OF_INIT_PARAMS* initParams) {
+        dxvk::log::info("OFSessionInit called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("OFSessionInit failed!"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        return nvOF->InitSession(initParams);
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionDestroy(NvOFHandle hOf) {
+        dxvk::log::info("OFSessionDestroy called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("OFSessionDestroy failed!"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        delete nvOF;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionGetLastError(NvOFHandle hOf, char lastError[], uint32_t* size) {
+        dxvk::log::info("OFSessionGetLastError called");
+        dxvk::log::info(dxvk::str::format("OFSessionGetLastError failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionGetCaps(NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t* capsVal, uint32_t* size) {
+        dxvk::log::info("OFSessionGetCaps called");
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+
+        return nvOF->getCaps(capsParam, capsVal, size);
+    }
+
+    // D3D12 entrypoints
+    NV_OF_STATUS NVOFAPI CreateOpticalFlowD3D12(ID3D12Device* pD3D12Device, NvOFHandle* hOFInstance) {
+        dxvk::log::info("CreateOpticalFlowD3D12 called");
+
+        nvofapi::NvOFInstanceD3D12* nvOF = nullptr;
+        try {
+            nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
+        } catch (std::exception e) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
+        }
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed allocation"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        if (!nvOF->Initialize()) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed creation"));
+            delete nvOF;
+            return NV_OF_ERR_GENERIC;
+        }
+
+        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
+        dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 end"));
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
+        dxvk::log::info("GetSurfaceFormatCountD3D12 called");
+        *pCount = 1;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat) {
+        dxvk::log::info("GetSurfaceFormatD3D12 called");
+        if (bufferUsage == NV_OF_BUFFER_USAGE_INPUT)
+            *pFormat = DXGI_FORMAT_R8_UNORM;
+        else
+            *pFormat = DXGI_FORMAT_R16G16_SINT;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI RegisterResourceD3D12(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        dxvk::log::info("RegisterResourceD3D12 called");
+        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+
+        return nvOF->RegisterBuffer(registerParams);
+    }
+
+    NV_OF_STATUS NVOFAPI UnregisterResourceD3D12(NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        dxvk::log::info("UnregisterResourceD3D12 called");
+        nvofapi::NvOFImageVk* nvRes = reinterpret_cast<nvofapi::NvOFImageVk*>(registerParams->hOFGpuBuffer);
+        delete nvRes;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI ExecuteD3D12(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* executeOutParams) {
+        dxvk::log::info("ExecuteD3D12 called");
+        dxvk::log::info(dxvk::str::format("handle: %p", hOf));
+        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+
+        return nvOF->Execute(executeInParams, executeOutParams);
+    }
+
+    // VK entrypoints
+    NV_OF_STATUS NVOFAPI CreateOpticalFlowVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice, NvOFHandle* hOFInstance) {
+        dxvk::log::info("CreateOpticalFlowVk called");
+        nvofapi::NvOFInstanceVk* nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed allocation"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        if (!nvOF->Initialize()) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed creation"));
+            delete nvOF;
+            return NV_OF_ERR_GENERIC;
+        }
+
+        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
+        dxvk::log::info("GetSurfaceFormatCountVk called");
+        dxvk::log::info(dxvk::str::format("GetSurfaceFormatCountVk failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat) {
+        dxvk::log::info("GetSurfaceFormatVk called");
+        dxvk::log::info(dxvk::str::format("GetSurfaceFormatVk failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI RegisterResourceVk(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        dxvk::log::info("RegisterResourceVk called");
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        return nvOF->RegisterBuffer(registerParams);
+    }
+
+    NV_OF_STATUS NVOFAPI UnregisterResourceVk(NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        dxvk::log::info("UnregisterResourceVk called");
+        nvofapi::NvOFImageVk* nvRes = reinterpret_cast<nvofapi::NvOFImageVk*>(registerParams->hOFGpuBuffer);
+        delete nvRes;
+        return NV_OF_SUCCESS;
+    }
+    NV_OF_STATUS NVOFAPI ExecuteVk(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* executeOutParams) {
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+
+        return nvOF->Execute(executeInParams, executeOutParams);
+    }
+
+    // ETBLs
+    NV_OF_STATUS __cdecl NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList) {
+        constexpr auto n = __func__;
+
+        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") VK"));
+
+        functionList->nvCreateOpticalFlowVk = CreateOpticalFlowVk;
+        functionList->nvOFInit = OFSessionInit;
+        functionList->nvOFGetSurfaceFormatCountVk = GetSurfaceFormatCountVk;
+        functionList->nvOFGetSurfaceFormatVk = GetSurfaceFormatVk;
+        functionList->nvOFRegisterResourceVk = RegisterResourceVk;
+        functionList->nvOFUnregisterResourceVk = UnregisterResourceVk;
+        functionList->nvOFExecuteVk = ExecuteVk;
+        functionList->nvOFDestroy = OFSessionDestroy;
+        functionList->nvOFGetLastError = OFSessionGetLastError;
+        functionList->nvOFGetCaps = OFSessionGetCaps;
+
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS __stdcall NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList) {
+        constexpr auto n = __func__;
+
+        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") D3D12"));
+
+        functionList->nvCreateOpticalFlowD3D12 = CreateOpticalFlowD3D12;
+        functionList->nvOFInit = OFSessionInit;
+        functionList->nvOFGetSurfaceFormatCountD3D12 = GetSurfaceFormatCountD3D12;
+        functionList->nvOFGetSurfaceFormatD3D12 = GetSurfaceFormatD3D12;
+        functionList->nvOFRegisterResourceD3D12 = RegisterResourceD3D12;
+        functionList->nvOFUnregisterResourceD3D12 = UnregisterResourceD3D12;
+        functionList->nvOFExecuteD3D12 = ExecuteD3D12;
+        functionList->nvOFDestroy = OFSessionDestroy;
+        functionList->nvOFGetLastError = OFSessionGetLastError;
+        functionList->nvOFGetCaps = OFSessionGetCaps;
+
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi/nvofapi_vulkan.cpp b/src/nvofapi/nvofapi_vulkan.cpp
new file mode 100644
index 00000000..308ccad4
--- /dev/null
+++ b/src/nvofapi/nvofapi_vulkan.cpp
@@ -0,0 +1,168 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "util/util_log.h"
+#include "util/util_string.h"
+
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+#include "nvofapi.h"
+
+namespace nvofapi {
+
+    bool NvOFInstanceVk::Initialize() {
+        m_library = LoadLibraryA("winevulkan.dll");
+        if (!m_library) {
+            return false;
+        }
+
+        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)GetProcAddress(m_library, "vkGetInstanceProcAddr");
+        m_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetDeviceProcAddr");
+        m_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
+
+        m_vkCreateImageView = (PFN_vkCreateImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateImageView");
+        m_vkDestroyImageView = (PFN_vkDestroyImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyImageView");
+
+        m_vkGetDeviceQueue = (PFN_vkGetDeviceQueue)m_vkGetDeviceProcAddr(m_vkDevice, "vkGetDeviceQueue");
+        m_vkCreateCommandPool = (PFN_vkCreateCommandPool)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateCommandPool");
+        m_vkDestroyCommandPool = (PFN_vkDestroyCommandPool)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyCommandPool");
+        m_vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)m_vkGetDeviceProcAddr(m_vkDevice, "vkAllocateCommandBuffers");
+        m_vkQueueSubmit2 = (PFN_vkQueueSubmit2)m_vkGetDeviceProcAddr(m_vkDevice, "vkQueueSubmit2");
+
+        m_vkResetCommandBuffer = (PFN_vkResetCommandBuffer)m_vkGetDeviceProcAddr(m_vkDevice, "vkResetCommandBuffer");
+        m_vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)m_vkGetDeviceProcAddr(m_vkDevice, "vkBeginCommandBuffer");
+        m_vkEndCommandBuffer = (PFN_vkEndCommandBuffer)m_vkGetDeviceProcAddr(m_vkDevice, "vkEndCommandBuffer");
+
+        // Get NvapiAdapter from the vkPhysicalDevice
+        // Populate the optical flow related info here
+        // fail to create if optical flow extension is unsupported
+        m_vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateOpticalFlowSessionNV");
+        m_vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyOpticalFlowSessionNV");
+        m_vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkBindOpticalFlowSessionImageNV");
+        m_vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCmdOpticalFlowExecuteNV");
+
+        // Get the OFA queue
+        VkCommandPoolCreateInfo createInfo = {VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};
+        createInfo.queueFamilyIndex = GetVkOFAQueue();
+        m_vkGetDeviceQueue(m_vkDevice, createInfo.queueFamilyIndex, 0, &m_queue);
+
+        if (m_vkCreateCommandPool(m_vkDevice, &createInfo, NULL, &m_commandPool)
+            != VK_SUCCESS) {
+            return false;
+        }
+
+        // ALlocate command buffers
+        VkCommandBufferAllocateInfo allocInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
+        allocInfo.commandPool = m_commandPool;
+        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+        allocInfo.commandBufferCount = CMDS_IN_FLIGHT; // more than enough for anybody ;)
+        if (m_vkAllocateCommandBuffers(m_vkDevice, &allocInfo, m_commandBuffers)
+            != VK_SUCCESS) {
+            return false;
+        }
+
+        return true;
+    }
+
+    bool NvOFImageVk::Initialize(PFN_vkCreateImageView fpCreateImageView,
+        PFN_vkDestroyImageView fpDestroyImageView) {
+        m_vkDestroyImageView = fpDestroyImageView;
+        VkOpticalFlowSessionBindingPointNV bindingPoint;
+        VkImageViewCreateInfo viewInfo = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
+        viewInfo.image = m_image;
+        viewInfo.format = m_format;
+
+        // XXX[ljm] remaining or 1???
+        viewInfo.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS};
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.flags = 0;
+
+        auto ret = fpCreateImageView(m_ofInstance->GetVkDevice(), &viewInfo, NULL, &m_imageView);
+        if (ret != VK_SUCCESS) {
+            return false;
+        }
+        return true;
+    }
+
+    NV_OF_STATUS NvOFInstanceVk::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams) {
+        dxvk::log::info(
+            dxvk::str::format("OFExecuteVK params:",
+                " inputFrame: ", inParams->inputFrame,
+                " referenceFrame: ", inParams->referenceFrame,
+                " externalHints: ", inParams->externalHints,
+                " disableTemporalHints: ", inParams->disableTemporalHints,
+                " hPrivData: ", inParams->hPrivData,
+                " numRois: ", inParams->numRois,
+                " roiData: ", inParams->roiData,
+                " numWaitSync: ", inParams->numWaitSyncs,
+                " pWaitSyncs: ", inParams->pWaitSyncs));
+
+        VkSemaphoreSubmitInfo* waitSyncs = nullptr;
+
+        if (inParams->numWaitSyncs) {
+            waitSyncs = (VkSemaphoreSubmitInfo*)calloc(sizeof(VkSemaphoreSubmitInfo), inParams->numWaitSyncs);
+            for (int i = 0; i < inParams->numWaitSyncs; i++) {
+                waitSyncs[i].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
+                waitSyncs[i].semaphore = inParams->pWaitSyncs[i].semaphore;
+                waitSyncs[i].value = inParams->pWaitSyncs[i].value;
+                waitSyncs[i].stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
+            }
+        }
+
+        VkSemaphoreSubmitInfo signalSync = {VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO};
+        if (outParams->pSignalSync) {
+            signalSync.semaphore = outParams->pSignalSync->semaphore;
+            signalSync.value = outParams->pSignalSync->value;
+            signalSync.stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
+        }
+
+        VkCommandBufferSubmitInfo cmdbufInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO};
+        cmdbufInfo.commandBuffer = m_commandBuffers[m_cmdBufIndex];
+        cmdbufInfo.deviceMask = 1;
+
+        VkCommandBufferBeginInfo begInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
+        m_vkResetCommandBuffer(m_commandBuffers[m_cmdBufIndex], 0);
+        m_vkBeginCommandBuffer(m_commandBuffers[m_cmdBufIndex], &begInfo);
+
+        RecordCmdBuf(inParams, outParams, m_commandBuffers[m_cmdBufIndex]);
+
+        m_vkEndCommandBuffer(m_commandBuffers[m_cmdBufIndex]);
+
+        VkSubmitInfo2 submit = {VK_STRUCTURE_TYPE_SUBMIT_INFO_2};
+        submit.waitSemaphoreInfoCount = inParams->numWaitSyncs;
+        submit.pWaitSemaphoreInfos = waitSyncs;
+        submit.commandBufferInfoCount = 1;
+        submit.pCommandBufferInfos = &cmdbufInfo;
+        submit.signalSemaphoreInfoCount = (outParams->pSignalSync) ? 1 : 0;
+        submit.pSignalSemaphoreInfos = &signalSync;
+
+        m_vkQueueSubmit2(m_queue, 1, &submit, VK_NULL_HANDLE);
+
+        free(waitSyncs);
+
+        m_cmdBufIndex++;
+        if (m_cmdBufIndex >= CMDS_IN_FLIGHT)
+            m_cmdBufIndex = 0;
+        return NV_OF_SUCCESS;
+    }
+}

From 6bb7775ec62a9f2b03c4cba212104bd50f7fc798 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Tue, 29 Oct 2024 20:44:47 -0700
Subject: [PATCH] nvofapi: Address feedback from Saancreed

---
 src/nvofapi/nvofapi.h               |  7 +++----
 src/nvofapi/nvofapi_common.cpp      |  2 +-
 src/nvofapi/nvofapi_entrypoints.cpp | 20 ++++++++++++++++++++
 3 files changed, 24 insertions(+), 5 deletions(-)

diff --git a/src/nvofapi/nvofapi.h b/src/nvofapi/nvofapi.h
index d74d028b..216e1752 100644
--- a/src/nvofapi/nvofapi.h
+++ b/src/nvofapi/nvofapi.h
@@ -29,7 +29,7 @@
 #include "../inc/nvofapi/nvOpticalFlowVulkan.h"
 
 namespace nvofapi {
-    constexpr uint32_t CMDS_IN_FLIGHT = 1;
+    constexpr uint32_t CMDS_IN_FLIGHT = 8;
     class NvOFInstance;
     class NvOFImageVk;
 
@@ -107,7 +107,7 @@ namespace nvofapi {
         }
         virtual ~NvOFInstanceVk() {
             // free cmdbuffers
-            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, 8, m_commandBuffers);
+            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, CMDS_IN_FLIGHT, m_commandBuffers);
             m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
         }
         bool Initialize();
@@ -119,8 +119,7 @@ namespace nvofapi {
         VkCommandPool m_commandPool;
         PFN_vkCreateCommandPool m_vkCreateCommandPool;
         PFN_vkDestroyCommandPool m_vkDestroyCommandPool;
-        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT]; // eight ought to be more than
-                                                          // enough for anybody ;)
+        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT];
 
         PFN_vkAllocateCommandBuffers m_vkAllocateCommandBuffers;
         PFN_vkFreeCommandBuffers m_vkFreeCommandBuffers;
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index 4a54cd41..9a15333d 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -181,7 +181,7 @@ namespace nvofapi {
                 }
             }
         }
-        VkRect2D* regions;
+        VkRect2D* regions = nullptr;
 
         if (inParams->numRois) {
             regions = (VkRect2D*)calloc(sizeof(VkRect2D), inParams->numRois);
diff --git a/src/nvofapi/nvofapi_entrypoints.cpp b/src/nvofapi/nvofapi_entrypoints.cpp
index 65eb9144..ac501c89 100644
--- a/src/nvofapi/nvofapi_entrypoints.cpp
+++ b/src/nvofapi/nvofapi_entrypoints.cpp
@@ -184,9 +184,15 @@ extern "C" {
 
     // ETBLs
     NV_OF_STATUS __cdecl NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList) {
+        uint32_t apiVerMajor = (apiVer & 0xfffffff0) >> 4;
+        uint32_t apiVerMinor = (apiVer & 0xf);
         constexpr auto n = __func__;
 
         dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") VK"));
+        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
+
+        if (apiVerMajor != 5)
+            return NV_OF_ERR_INVALID_VERSION;
 
         functionList->nvCreateOpticalFlowVk = CreateOpticalFlowVk;
         functionList->nvOFInit = OFSessionInit;
@@ -203,9 +209,15 @@ extern "C" {
     }
 
     NV_OF_STATUS __stdcall NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList) {
+        uint32_t apiVerMajor = (apiVer & 0xfffffff0) >> 4;
+        uint32_t apiVerMinor = (apiVer & 0xf);
         constexpr auto n = __func__;
 
         dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") D3D12"));
+        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
+
+        if (apiVerMajor != 5)
+            return NV_OF_ERR_INVALID_VERSION;
 
         functionList->nvCreateOpticalFlowD3D12 = CreateOpticalFlowD3D12;
         functionList->nvOFInit = OFSessionInit;
@@ -220,4 +232,12 @@ extern "C" {
 
         return NV_OF_SUCCESS;
     }
+
+    NV_OF_STATUS __cdecl NvOFGetMaxSupportedApiVersion(uint32_t *version) {
+        if (!version)
+            return NV_OF_ERR_INVALID_PTR;
+
+        *version = NV_OF_API_VERSION;
+        return NV_OF_SUCCESS;
+    }
 }

From c1a0ba102038f44cdbfeb47177bbf496655d2a7b Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Tue, 29 Oct 2024 21:25:02 -0700
Subject: [PATCH] nvofapi: Refactor to match suggested layout from Jens

---
 .../nvofapi_d3d12_instance.cpp}               |   5 +-
 src/d3d12/nvofapi_d3d12_instance.h            |  69 +++++
 src/meson.build                               |   9 +-
 src/nvofapi.cpp                               |  77 ++++++
 src/nvofapi/nvofapi.h                         | 176 -------------
 src/nvofapi/nvofapi_common.cpp                |  25 +-
 src/nvofapi/nvofapi_entrypoints.cpp           | 243 ------------------
 src/nvofapi/nvofapi_entrypoints.h             |  37 +++
 src/nvofapi/nvofapi_image.cpp                 |  46 ++++
 src/nvofapi/nvofapi_image.h                   |  46 ++++
 src/nvofapi/nvofapi_instance.h                |  82 ++++++
 src/nvofapi_d3d12.cpp                         | 123 +++++++++
 src/nvofapi_vulkan.cpp                        | 108 ++++++++
 .../nvofapi_vulkan_instance.cpp}              |  22 +-
 src/vulkan/nvofapi_vulkan_instance.h          |  60 +++++
 15 files changed, 669 insertions(+), 459 deletions(-)
 rename src/{nvofapi/nvofapi_d3d12.cpp => d3d12/nvofapi_d3d12_instance.cpp} (98%)
 create mode 100644 src/d3d12/nvofapi_d3d12_instance.h
 create mode 100644 src/nvofapi.cpp
 delete mode 100644 src/nvofapi/nvofapi.h
 delete mode 100644 src/nvofapi/nvofapi_entrypoints.cpp
 create mode 100644 src/nvofapi/nvofapi_entrypoints.h
 create mode 100644 src/nvofapi/nvofapi_image.cpp
 create mode 100644 src/nvofapi/nvofapi_image.h
 create mode 100644 src/nvofapi/nvofapi_instance.h
 create mode 100644 src/nvofapi_d3d12.cpp
 create mode 100644 src/nvofapi_vulkan.cpp
 rename src/{nvofapi/nvofapi_vulkan.cpp => vulkan/nvofapi_vulkan_instance.cpp} (89%)
 create mode 100644 src/vulkan/nvofapi_vulkan_instance.h

diff --git a/src/nvofapi/nvofapi_d3d12.cpp b/src/d3d12/nvofapi_d3d12_instance.cpp
similarity index 98%
rename from src/nvofapi/nvofapi_d3d12.cpp
rename to src/d3d12/nvofapi_d3d12_instance.cpp
index f224ea05..4e638c9c 100644
--- a/src/nvofapi/nvofapi_d3d12.cpp
+++ b/src/d3d12/nvofapi_d3d12_instance.cpp
@@ -26,10 +26,7 @@
 #include "util/util_log.h"
 #include "util/util_string.h"
 
-#include "vkd3d-proton/vkd3d-proton_interfaces.h"
-#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
-
-#include "nvofapi.h"
+#include "d3d12/nvofapi_d3d12_instance.h"
 
 namespace nvofapi {
 
diff --git a/src/d3d12/nvofapi_d3d12_instance.h b/src/d3d12/nvofapi_d3d12_instance.h
new file mode 100644
index 00000000..7b7ccdc5
--- /dev/null
+++ b/src/d3d12/nvofapi_d3d12_instance.h
@@ -0,0 +1,69 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "nvofapi/nvofapi_instance.h"
+
+namespace nvofapi {
+    class NvOFInstanceD3D12 : public NvOFInstance {
+      private:
+        ID3D12DXVKInteropDevice1* m_device{};
+        ID3D12DeviceExt* m_deviceExt{};
+        ID3D12Device4* m_d3ddevice{};
+        ID3D12CommandQueue* m_commandQueue{};
+        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
+        uint32_t m_cmdListIndex = 0;
+        ID3D12CommandAllocator* m_cmdAllocator{};
+
+        uint32_t m_vkQueueFamilyIndex = 0;
+
+      public:
+        bool Initialize();
+        NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
+        virtual ~NvOFInstanceD3D12() {
+            for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+                if (m_cmdList[i])
+                    m_cmdList[i]->Release();
+            }
+            if (m_cmdAllocator)
+                m_cmdAllocator->Release();
+
+            if (m_commandQueue)
+                m_commandQueue->Release();
+
+            if (m_deviceExt)
+                m_deviceExt->Release();
+
+            if (m_d3ddevice)
+                m_d3ddevice->Release();
+
+            if (m_device)
+                m_device->Release();
+        }
+
+        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
+
+        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
+    };
+}
diff --git a/src/meson.build b/src/meson.build
index 9d40fa1e..204376aa 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -36,10 +36,13 @@ nvofapi_src = files([
   'util/util_string.cpp',
   'util/util_env.cpp',
   'util/util_log.cpp',
+  'nvofapi.cpp',
+  'nvofapi_d3d12.cpp',
+  'nvofapi_vulkan.cpp',
+  'd3d12/nvofapi_d3d12_instance.cpp',
+  'vulkan/nvofapi_vulkan_instance.cpp',
   'nvofapi/nvofapi_common.cpp',
-  'nvofapi/nvofapi_d3d12.cpp',
-  'nvofapi/nvofapi_vulkan.cpp',
-  'nvofapi/nvofapi_entrypoints.cpp'
+  'nvofapi/nvofapi_image.cpp',
 ])
 
 nvofapi_dll = shared_library('nvofapi'+target_suffix, [ nvofapi_src, dxvk_nvapi_version ],
diff --git a/src/nvofapi.cpp b/src/nvofapi.cpp
new file mode 100644
index 00000000..016f02ab
--- /dev/null
+++ b/src/nvofapi.cpp
@@ -0,0 +1,77 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "nvofapi/nvofapi_entrypoints.h"
+
+#include "util/util_env.h"
+#include "util/util_log.h"
+#include "util/util_string.h"
+#include "../version.h"
+
+extern "C" {
+    // Common entrypoints
+    NV_OF_STATUS NVOFAPI OFSessionInit(NvOFHandle hOf, const NV_OF_INIT_PARAMS* initParams) {
+        dxvk::log::info("OFSessionInit called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("OFSessionInit failed!"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        return nvOF->InitSession(initParams);
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionDestroy(NvOFHandle hOf) {
+        dxvk::log::info("OFSessionDestroy called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("OFSessionDestroy failed!"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        delete nvOF;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionGetLastError(NvOFHandle hOf, char lastError[], uint32_t* size) {
+        dxvk::log::info("OFSessionGetLastError called");
+        dxvk::log::info(dxvk::str::format("OFSessionGetLastError failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionGetCaps(NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t* capsVal, uint32_t* size) {
+        dxvk::log::info("OFSessionGetCaps called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+
+        return nvOF->getCaps(capsParam, capsVal, size);
+    }
+
+    NV_OF_STATUS __cdecl NvOFGetMaxSupportedApiVersion(uint32_t* version) {
+        if (!version)
+            return NV_OF_ERR_INVALID_PTR;
+
+        *version = NV_OF_API_VERSION;
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi/nvofapi.h b/src/nvofapi/nvofapi.h
deleted file mode 100644
index 216e1752..00000000
--- a/src/nvofapi/nvofapi.h
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
- * SPDX-License-Identifier: MIT
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#pragma once
-
-#include "vkd3d-proton/vkd3d-proton_interfaces.h"
-
-#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
-#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
-
-namespace nvofapi {
-    constexpr uint32_t CMDS_IN_FLIGHT = 8;
-    class NvOFInstance;
-    class NvOFImageVk;
-
-    class NvOFInstance {
-
-      protected:
-        VkInstance m_vkInstance;
-        VkPhysicalDevice m_vkPhysicalDevice;
-        VkDevice m_vkDevice;
-        VkOpticalFlowSessionNV m_vkOfaSession{};
-        PFN_vkGetInstanceProcAddr m_vkGetInstanceProcAddr{};
-        PFN_vkGetDeviceProcAddr m_vkGetDeviceProcAddr{};
-        PFN_vkCreateOpticalFlowSessionNV m_vkCreateOpticalFlowSessionNV{};
-        PFN_vkDestroyOpticalFlowSessionNV m_vkDestroyOpticalFlowSessionNV{};
-        PFN_vkCreateImageView m_vkCreateImageView{};
-        PFN_vkDestroyImageView m_vkDestroyImageView{};
-        PFN_vkBindOpticalFlowSessionImageNV m_vkBindOpticalFlowSessionImageNV{};
-        PFN_vkCmdOpticalFlowExecuteNV m_vkCmdOpticalFlowExecuteNV{};
-
-        PFN_vkGetPhysicalDeviceQueueFamilyProperties m_vkGetPhysicalDeviceQueueFamilyProperties;
-        HMODULE m_library;
-
-        uint32_t GetVkOFAQueue();
-
-      public:
-        VkDevice GetVkDevice() { return m_vkDevice; }
-        VkOpticalFlowSessionNV GetOfaSession() { return m_vkOfaSession; }
-
-        NvOFInstance(VkInstance vkInstance,
-            VkPhysicalDevice vkPhysicalDevice,
-            VkDevice vkDevice) : m_vkInstance(vkInstance),
-                                 m_vkPhysicalDevice(vkPhysicalDevice), m_vkDevice(vkDevice) {
-        }
-
-        NvOFInstance() {};
-        virtual ~NvOFInstance() {
-            m_vkDestroyOpticalFlowSessionNV(m_vkDevice, m_vkOfaSession, nullptr);
-            FreeLibrary(m_library);
-        }
-
-        NV_OF_STATUS getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size);
-
-        NV_OF_STATUS InitSession(const NV_OF_INIT_PARAMS* initParams);
-
-        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
-
-        NV_OF_STATUS BindImageToSession(NvOFImageVk* image, VkOpticalFlowSessionBindingPointNV bindingPoint);
-
-        NV_OF_STATUS RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
-    };
-
-    class NvOFImageVk {
-      private:
-        NvOFInstance* m_ofInstance;
-        VkImage m_image;
-        VkImageView m_imageView;
-        VkFormat m_format;
-        PFN_vkDestroyImageView m_vkDestroyImageView{};
-
-      public:
-        VkImageView ImageView() { return m_imageView; }
-        NvOFImageVk(NvOFInstance* ofInstance, VkImage image, VkFormat format) : m_ofInstance(ofInstance), m_image(image), m_format(format) {
-        }
-        ~NvOFImageVk() {
-            m_vkDestroyImageView(m_ofInstance->GetVkDevice(), m_imageView, nullptr);
-        }
-
-        bool Initialize(PFN_vkCreateImageView CreateImageView,
-            PFN_vkDestroyImageView DestroyImageView);
-    };
-
-    class NvOFInstanceVk : public NvOFInstance {
-      public:
-        NvOFInstanceVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice) : NvOFInstance(vkInstance, vkPhysicalDevice, vkDevice) {
-        }
-        virtual ~NvOFInstanceVk() {
-            // free cmdbuffers
-            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, CMDS_IN_FLIGHT, m_commandBuffers);
-            m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
-        }
-        bool Initialize();
-
-        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
-
-      private:
-        VkQueue m_queue;
-        VkCommandPool m_commandPool;
-        PFN_vkCreateCommandPool m_vkCreateCommandPool;
-        PFN_vkDestroyCommandPool m_vkDestroyCommandPool;
-        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT];
-
-        PFN_vkAllocateCommandBuffers m_vkAllocateCommandBuffers;
-        PFN_vkFreeCommandBuffers m_vkFreeCommandBuffers;
-
-        uint32_t m_cmdBufIndex = 0;
-        PFN_vkResetCommandBuffer m_vkResetCommandBuffer;
-        PFN_vkBeginCommandBuffer m_vkBeginCommandBuffer;
-        PFN_vkEndCommandBuffer m_vkEndCommandBuffer;
-
-        PFN_vkGetDeviceQueue m_vkGetDeviceQueue;
-        PFN_vkQueueSubmit2 m_vkQueueSubmit2{};
-    };
-
-    class NvOFInstanceD3D12 : public NvOFInstance {
-      private:
-        ID3D12DXVKInteropDevice1* m_device{};
-        ID3D12DeviceExt* m_deviceExt{};
-        ID3D12Device4* m_d3ddevice{};
-        ID3D12CommandQueue* m_commandQueue{};
-        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
-        uint32_t m_cmdListIndex = 0;
-        ID3D12CommandAllocator* m_cmdAllocator{};
-
-        uint32_t m_vkQueueFamilyIndex = 0;
-
-      public:
-        bool Initialize();
-        NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
-        virtual ~NvOFInstanceD3D12() {
-            for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
-                if (m_cmdList[i])
-                    m_cmdList[i]->Release();
-            }
-            if (m_cmdAllocator)
-                m_cmdAllocator->Release();
-
-            if (m_commandQueue)
-                m_commandQueue->Release();
-
-            if (m_deviceExt)
-                m_deviceExt->Release();
-
-            if (m_d3ddevice)
-                m_d3ddevice->Release();
-
-            if (m_device)
-                m_device->Release();
-        }
-
-        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
-
-        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
-    };
-}
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index 9a15333d..1a298b7a 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -26,7 +26,8 @@
 
 #include "../inc/nvofapi/nvOpticalFlowVulkan.h"
 
-#include "nvofapi.h"
+#include "nvofapi_image.h"
+#include "nvofapi_instance.h"
 
 namespace nvofapi {
 
@@ -126,7 +127,7 @@ namespace nvofapi {
         return NV_OF_ERR_GENERIC;
     }
 
-    NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFImageVk* image, VkOpticalFlowSessionBindingPointNV bindingPoint) {
+    NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFImage* image, VkOpticalFlowSessionBindingPointNV bindingPoint) {
         VkImageLayout layout = VK_IMAGE_LAYOUT_GENERAL;
 
         if (!image)
@@ -157,27 +158,27 @@ namespace nvofapi {
     }
 
     NV_OF_STATUS NvOFInstance::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
-        NvOFImageVk* nvOFImage = new NvOFImageVk(this, registerParams->image, registerParams->format);
+        NvOFImage* nvOFImage = new NvOFImage(m_vkDevice, registerParams->image, registerParams->format);
         nvOFImage->Initialize(m_vkCreateImageView, m_vkDestroyImageView);
         *registerParams->hOFGpuBuffer = reinterpret_cast<NvOFGPUBufferHandle>(nvOFImage);
         return NV_OF_SUCCESS;
     }
 
     NV_OF_STATUS NvOFInstance::RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf) {
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(inParams->inputFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(inParams->referenceFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->outputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->outputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV);
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->bwdOutputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV);
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->bwdOutputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
-        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->globalFlowBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(inParams->inputFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(inParams->referenceFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->outputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->outputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->bwdOutputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->bwdOutputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
+        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->globalFlowBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
         // Support INPUT_MIPS execute priv data
         if (((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
             NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS* mipData = ((NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS*)((NV_OF_PRIV_DATA*)inParams->hPrivData)->data);
             for (int i = 0; i < 6; i++) {
                 if (mipData->input[i] && mipData->reference[i]) {
-                    BindImageToSession(reinterpret_cast<NvOFImageVk*>(mipData->input[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
-                    BindImageToSession(reinterpret_cast<NvOFImageVk*>(mipData->reference[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+                    BindImageToSession(reinterpret_cast<NvOFImage*>(mipData->input[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+                    BindImageToSession(reinterpret_cast<NvOFImage*>(mipData->reference[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
                 }
             }
         }
diff --git a/src/nvofapi/nvofapi_entrypoints.cpp b/src/nvofapi/nvofapi_entrypoints.cpp
deleted file mode 100644
index ac501c89..00000000
--- a/src/nvofapi/nvofapi_entrypoints.cpp
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
- * SPDX-License-Identifier: MIT
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#include "nvofapi.h"
-
-#include "util/util_env.h"
-#include "util/util_log.h"
-#include "util/util_string.h"
-#include "../version.h"
-
-extern "C" {
-
-    // Common entrypoints
-    NV_OF_STATUS NVOFAPI OFSessionInit(NvOFHandle hOf, const NV_OF_INIT_PARAMS* initParams) {
-        dxvk::log::info("OFSessionInit called");
-        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
-
-        if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("OFSessionInit failed!"));
-            return NV_OF_ERR_GENERIC;
-        }
-
-        return nvOF->InitSession(initParams);
-    }
-
-    NV_OF_STATUS NVOFAPI OFSessionDestroy(NvOFHandle hOf) {
-        dxvk::log::info("OFSessionDestroy called");
-        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
-        if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("OFSessionDestroy failed!"));
-            return NV_OF_ERR_GENERIC;
-        }
-
-        delete nvOF;
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS NVOFAPI OFSessionGetLastError(NvOFHandle hOf, char lastError[], uint32_t* size) {
-        dxvk::log::info("OFSessionGetLastError called");
-        dxvk::log::info(dxvk::str::format("OFSessionGetLastError failed!"));
-        return NV_OF_ERR_GENERIC;
-    }
-
-    NV_OF_STATUS NVOFAPI OFSessionGetCaps(NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t* capsVal, uint32_t* size) {
-        dxvk::log::info("OFSessionGetCaps called");
-        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
-
-        return nvOF->getCaps(capsParam, capsVal, size);
-    }
-
-    // D3D12 entrypoints
-    NV_OF_STATUS NVOFAPI CreateOpticalFlowD3D12(ID3D12Device* pD3D12Device, NvOFHandle* hOFInstance) {
-        dxvk::log::info("CreateOpticalFlowD3D12 called");
-
-        nvofapi::NvOFInstanceD3D12* nvOF = nullptr;
-        try {
-            nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
-        } catch (std::exception e) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
-        }
-
-        if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed allocation"));
-            return NV_OF_ERR_GENERIC;
-        }
-
-        if (!nvOF->Initialize()) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed creation"));
-            delete nvOF;
-            return NV_OF_ERR_GENERIC;
-        }
-
-        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
-        dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 end"));
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
-        dxvk::log::info("GetSurfaceFormatCountD3D12 called");
-        *pCount = 1;
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS NVOFAPI GetSurfaceFormatD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat) {
-        dxvk::log::info("GetSurfaceFormatD3D12 called");
-        if (bufferUsage == NV_OF_BUFFER_USAGE_INPUT)
-            *pFormat = DXGI_FORMAT_R8_UNORM;
-        else
-            *pFormat = DXGI_FORMAT_R16G16_SINT;
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS NVOFAPI RegisterResourceD3D12(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
-        dxvk::log::info("RegisterResourceD3D12 called");
-        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
-
-        return nvOF->RegisterBuffer(registerParams);
-    }
-
-    NV_OF_STATUS NVOFAPI UnregisterResourceD3D12(NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
-        dxvk::log::info("UnregisterResourceD3D12 called");
-        nvofapi::NvOFImageVk* nvRes = reinterpret_cast<nvofapi::NvOFImageVk*>(registerParams->hOFGpuBuffer);
-        delete nvRes;
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS NVOFAPI ExecuteD3D12(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* executeOutParams) {
-        dxvk::log::info("ExecuteD3D12 called");
-        dxvk::log::info(dxvk::str::format("handle: %p", hOf));
-        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
-
-        return nvOF->Execute(executeInParams, executeOutParams);
-    }
-
-    // VK entrypoints
-    NV_OF_STATUS NVOFAPI CreateOpticalFlowVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice, NvOFHandle* hOFInstance) {
-        dxvk::log::info("CreateOpticalFlowVk called");
-        nvofapi::NvOFInstanceVk* nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
-
-        if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed allocation"));
-            return NV_OF_ERR_GENERIC;
-        }
-
-        if (!nvOF->Initialize()) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed creation"));
-            delete nvOF;
-            return NV_OF_ERR_GENERIC;
-        }
-
-        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
-        dxvk::log::info("GetSurfaceFormatCountVk called");
-        dxvk::log::info(dxvk::str::format("GetSurfaceFormatCountVk failed!"));
-        return NV_OF_ERR_GENERIC;
-    }
-
-    NV_OF_STATUS NVOFAPI GetSurfaceFormatVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat) {
-        dxvk::log::info("GetSurfaceFormatVk called");
-        dxvk::log::info(dxvk::str::format("GetSurfaceFormatVk failed!"));
-        return NV_OF_ERR_GENERIC;
-    }
-
-    NV_OF_STATUS NVOFAPI RegisterResourceVk(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
-        dxvk::log::info("RegisterResourceVk called");
-        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
-        return nvOF->RegisterBuffer(registerParams);
-    }
-
-    NV_OF_STATUS NVOFAPI UnregisterResourceVk(NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* registerParams) {
-        dxvk::log::info("UnregisterResourceVk called");
-        nvofapi::NvOFImageVk* nvRes = reinterpret_cast<nvofapi::NvOFImageVk*>(registerParams->hOFGpuBuffer);
-        delete nvRes;
-        return NV_OF_SUCCESS;
-    }
-    NV_OF_STATUS NVOFAPI ExecuteVk(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* executeOutParams) {
-        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
-
-        return nvOF->Execute(executeInParams, executeOutParams);
-    }
-
-    // ETBLs
-    NV_OF_STATUS __cdecl NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList) {
-        uint32_t apiVerMajor = (apiVer & 0xfffffff0) >> 4;
-        uint32_t apiVerMinor = (apiVer & 0xf);
-        constexpr auto n = __func__;
-
-        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") VK"));
-        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
-
-        if (apiVerMajor != 5)
-            return NV_OF_ERR_INVALID_VERSION;
-
-        functionList->nvCreateOpticalFlowVk = CreateOpticalFlowVk;
-        functionList->nvOFInit = OFSessionInit;
-        functionList->nvOFGetSurfaceFormatCountVk = GetSurfaceFormatCountVk;
-        functionList->nvOFGetSurfaceFormatVk = GetSurfaceFormatVk;
-        functionList->nvOFRegisterResourceVk = RegisterResourceVk;
-        functionList->nvOFUnregisterResourceVk = UnregisterResourceVk;
-        functionList->nvOFExecuteVk = ExecuteVk;
-        functionList->nvOFDestroy = OFSessionDestroy;
-        functionList->nvOFGetLastError = OFSessionGetLastError;
-        functionList->nvOFGetCaps = OFSessionGetCaps;
-
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS __stdcall NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList) {
-        uint32_t apiVerMajor = (apiVer & 0xfffffff0) >> 4;
-        uint32_t apiVerMinor = (apiVer & 0xf);
-        constexpr auto n = __func__;
-
-        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") D3D12"));
-        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
-
-        if (apiVerMajor != 5)
-            return NV_OF_ERR_INVALID_VERSION;
-
-        functionList->nvCreateOpticalFlowD3D12 = CreateOpticalFlowD3D12;
-        functionList->nvOFInit = OFSessionInit;
-        functionList->nvOFGetSurfaceFormatCountD3D12 = GetSurfaceFormatCountD3D12;
-        functionList->nvOFGetSurfaceFormatD3D12 = GetSurfaceFormatD3D12;
-        functionList->nvOFRegisterResourceD3D12 = RegisterResourceD3D12;
-        functionList->nvOFUnregisterResourceD3D12 = UnregisterResourceD3D12;
-        functionList->nvOFExecuteD3D12 = ExecuteD3D12;
-        functionList->nvOFDestroy = OFSessionDestroy;
-        functionList->nvOFGetLastError = OFSessionGetLastError;
-        functionList->nvOFGetCaps = OFSessionGetCaps;
-
-        return NV_OF_SUCCESS;
-    }
-
-    NV_OF_STATUS __cdecl NvOFGetMaxSupportedApiVersion(uint32_t *version) {
-        if (!version)
-            return NV_OF_ERR_INVALID_PTR;
-
-        *version = NV_OF_API_VERSION;
-        return NV_OF_SUCCESS;
-    }
-}
diff --git a/src/nvofapi/nvofapi_entrypoints.h b/src/nvofapi/nvofapi_entrypoints.h
new file mode 100644
index 00000000..7281f629
--- /dev/null
+++ b/src/nvofapi/nvofapi_entrypoints.h
@@ -0,0 +1,37 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "nvofapi_instance.h"
+
+extern "C" {
+    // Common entrypoints
+    NV_OF_STATUS NVOFAPI OFSessionInit(NvOFHandle hOf, const NV_OF_INIT_PARAMS* initParams);
+
+    NV_OF_STATUS NVOFAPI OFSessionDestroy(NvOFHandle hOf);
+
+    NV_OF_STATUS NVOFAPI OFSessionGetLastError(NvOFHandle hOf, char lastError[], uint32_t* size);
+
+    NV_OF_STATUS NVOFAPI OFSessionGetCaps(NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t* capsVal, uint32_t* size);
+}
diff --git a/src/nvofapi/nvofapi_image.cpp b/src/nvofapi/nvofapi_image.cpp
new file mode 100644
index 00000000..e99dc2cb
--- /dev/null
+++ b/src/nvofapi/nvofapi_image.cpp
@@ -0,0 +1,46 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "nvofapi_image.h"
+
+namespace nvofapi {
+    bool NvOFImage::Initialize(PFN_vkCreateImageView fpCreateImageView,
+        PFN_vkDestroyImageView fpDestroyImageView) {
+        m_vkDestroyImageView = fpDestroyImageView;
+        VkOpticalFlowSessionBindingPointNV bindingPoint;
+        VkImageViewCreateInfo viewInfo = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
+        viewInfo.image = m_image;
+        viewInfo.format = m_format;
+
+        // XXX[ljm] remaining or 1???
+        viewInfo.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS};
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.flags = 0;
+
+        auto ret = fpCreateImageView(m_vkDevice, &viewInfo, NULL, &m_imageView);
+        if (ret != VK_SUCCESS) {
+            return false;
+        }
+        return true;
+    }
+}
diff --git a/src/nvofapi/nvofapi_image.h b/src/nvofapi/nvofapi_image.h
new file mode 100644
index 00000000..bc297aa7
--- /dev/null
+++ b/src/nvofapi/nvofapi_image.h
@@ -0,0 +1,46 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <vulkan/vulkan_core.h>
+
+namespace nvofapi {
+    class NvOFImage {
+      private:
+        VkDevice m_vkDevice;
+        VkImage m_image;
+        VkImageView m_imageView;
+        VkFormat m_format;
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+
+      public:
+        VkImageView ImageView() { return m_imageView; }
+        NvOFImage(VkDevice device, VkImage image, VkFormat format) : m_vkDevice(device), m_image(image), m_format(format) {
+        }
+        ~NvOFImage() {
+            m_vkDestroyImageView(m_vkDevice, m_imageView, nullptr);
+        }
+
+        bool Initialize(PFN_vkCreateImageView CreateImageView,
+            PFN_vkDestroyImageView DestroyImageView);
+    };
+}
diff --git a/src/nvofapi/nvofapi_instance.h b/src/nvofapi/nvofapi_instance.h
new file mode 100644
index 00000000..f886aee1
--- /dev/null
+++ b/src/nvofapi/nvofapi_instance.h
@@ -0,0 +1,82 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "vkd3d-proton/vkd3d-proton_interfaces.h"
+#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+namespace nvofapi {
+    constexpr uint32_t CMDS_IN_FLIGHT = 8;
+    class NvOFInstance;
+    class NvOFImage;
+
+    class NvOFInstance {
+
+      protected:
+        VkInstance m_vkInstance;
+        VkPhysicalDevice m_vkPhysicalDevice;
+        VkDevice m_vkDevice;
+        VkOpticalFlowSessionNV m_vkOfaSession{};
+        PFN_vkGetInstanceProcAddr m_vkGetInstanceProcAddr{};
+        PFN_vkGetDeviceProcAddr m_vkGetDeviceProcAddr{};
+        PFN_vkCreateOpticalFlowSessionNV m_vkCreateOpticalFlowSessionNV{};
+        PFN_vkDestroyOpticalFlowSessionNV m_vkDestroyOpticalFlowSessionNV{};
+        PFN_vkCreateImageView m_vkCreateImageView{};
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+        PFN_vkBindOpticalFlowSessionImageNV m_vkBindOpticalFlowSessionImageNV{};
+        PFN_vkCmdOpticalFlowExecuteNV m_vkCmdOpticalFlowExecuteNV{};
+
+        PFN_vkGetPhysicalDeviceQueueFamilyProperties m_vkGetPhysicalDeviceQueueFamilyProperties;
+        HMODULE m_library;
+
+        uint32_t GetVkOFAQueue();
+
+      public:
+        VkDevice GetVkDevice() { return m_vkDevice; }
+        VkOpticalFlowSessionNV GetOfaSession() { return m_vkOfaSession; }
+
+        NvOFInstance(VkInstance vkInstance,
+            VkPhysicalDevice vkPhysicalDevice,
+            VkDevice vkDevice) : m_vkInstance(vkInstance),
+                                 m_vkPhysicalDevice(vkPhysicalDevice), m_vkDevice(vkDevice) {
+        }
+
+        NvOFInstance() {};
+        virtual ~NvOFInstance() {
+            m_vkDestroyOpticalFlowSessionNV(m_vkDevice, m_vkOfaSession, nullptr);
+            FreeLibrary(m_library);
+        }
+
+        NV_OF_STATUS getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size);
+
+        NV_OF_STATUS InitSession(const NV_OF_INIT_PARAMS* initParams);
+
+        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
+
+        NV_OF_STATUS BindImageToSession(NvOFImage* image, VkOpticalFlowSessionBindingPointNV bindingPoint);
+
+        NV_OF_STATUS RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
+    };
+}
diff --git a/src/nvofapi_d3d12.cpp b/src/nvofapi_d3d12.cpp
new file mode 100644
index 00000000..ec8cfc8a
--- /dev/null
+++ b/src/nvofapi_d3d12.cpp
@@ -0,0 +1,123 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "nvofapi/nvofapi_entrypoints.h"
+#include "d3d12/nvofapi_d3d12_instance.h"
+
+#include "util/util_env.h"
+#include "util/util_log.h"
+#include "util/util_string.h"
+#include "../version.h"
+
+extern "C" {
+
+    // D3D12 entrypoints
+    NV_OF_STATUS NVOFAPI CreateOpticalFlowD3D12(ID3D12Device* pD3D12Device, NvOFHandle* hOFInstance) {
+        dxvk::log::info("CreateOpticalFlowD3D12 called");
+
+        nvofapi::NvOFInstanceD3D12* nvOF = nullptr;
+        try {
+            nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
+        } catch (std::exception e) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
+        }
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed allocation"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        if (!nvOF->Initialize()) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed creation"));
+            delete nvOF;
+            return NV_OF_ERR_GENERIC;
+        }
+
+        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
+        dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 end"));
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
+        dxvk::log::info("GetSurfaceFormatCountD3D12 called");
+        *pCount = 1;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat) {
+        dxvk::log::info("GetSurfaceFormatD3D12 called");
+        if (bufferUsage == NV_OF_BUFFER_USAGE_INPUT)
+            *pFormat = DXGI_FORMAT_R8_UNORM;
+        else
+            *pFormat = DXGI_FORMAT_R16G16_SINT;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI RegisterResourceD3D12(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        dxvk::log::info("RegisterResourceD3D12 called");
+        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+
+        return nvOF->RegisterBuffer(registerParams);
+    }
+
+    NV_OF_STATUS NVOFAPI UnregisterResourceD3D12(NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        dxvk::log::info("UnregisterResourceD3D12 called");
+        nvofapi::NvOFImage* nvRes = reinterpret_cast<nvofapi::NvOFImage*>(registerParams->hOFGpuBuffer);
+        delete nvRes;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI ExecuteD3D12(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* executeOutParams) {
+        dxvk::log::info("ExecuteD3D12 called");
+        dxvk::log::info(dxvk::str::format("handle: %p", hOf));
+        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+
+        return nvOF->Execute(executeInParams, executeOutParams);
+    }
+
+    // ETBLs
+    NV_OF_STATUS __stdcall NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList) {
+        uint32_t apiVerMajor = (apiVer & 0xfffffff0) >> 4;
+        uint32_t apiVerMinor = (apiVer & 0xf);
+        constexpr auto n = __func__;
+
+        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") D3D12"));
+        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
+
+        if (apiVerMajor != 5)
+            return NV_OF_ERR_INVALID_VERSION;
+
+        functionList->nvCreateOpticalFlowD3D12 = CreateOpticalFlowD3D12;
+        functionList->nvOFInit = OFSessionInit;
+        functionList->nvOFGetSurfaceFormatCountD3D12 = GetSurfaceFormatCountD3D12;
+        functionList->nvOFGetSurfaceFormatD3D12 = GetSurfaceFormatD3D12;
+        functionList->nvOFRegisterResourceD3D12 = RegisterResourceD3D12;
+        functionList->nvOFUnregisterResourceD3D12 = UnregisterResourceD3D12;
+        functionList->nvOFExecuteD3D12 = ExecuteD3D12;
+        functionList->nvOFDestroy = OFSessionDestroy;
+        functionList->nvOFGetLastError = OFSessionGetLastError;
+        functionList->nvOFGetCaps = OFSessionGetCaps;
+
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi_vulkan.cpp b/src/nvofapi_vulkan.cpp
new file mode 100644
index 00000000..25f08256
--- /dev/null
+++ b/src/nvofapi_vulkan.cpp
@@ -0,0 +1,108 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "nvofapi/nvofapi_entrypoints.h"
+#include "vulkan/nvofapi_vulkan_instance.h"
+
+#include "util/util_env.h"
+#include "util/util_log.h"
+#include "util/util_string.h"
+#include "../version.h"
+
+extern "C" {
+    // VK entrypoints
+    NV_OF_STATUS NVOFAPI CreateOpticalFlowVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice, NvOFHandle* hOFInstance) {
+        dxvk::log::info("CreateOpticalFlowVk called");
+        nvofapi::NvOFInstanceVk* nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed allocation"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        if (!nvOF->Initialize()) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed creation"));
+            delete nvOF;
+            return NV_OF_ERR_GENERIC;
+        }
+
+        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
+        dxvk::log::info("GetSurfaceFormatCountVk called");
+        dxvk::log::info(dxvk::str::format("GetSurfaceFormatCountVk failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat) {
+        dxvk::log::info("GetSurfaceFormatVk called");
+        dxvk::log::info(dxvk::str::format("GetSurfaceFormatVk failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI RegisterResourceVk(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        dxvk::log::info("RegisterResourceVk called");
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        return nvOF->RegisterBuffer(registerParams);
+    }
+
+    NV_OF_STATUS NVOFAPI UnregisterResourceVk(NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        dxvk::log::info("UnregisterResourceVk called");
+        nvofapi::NvOFImage* nvRes = reinterpret_cast<nvofapi::NvOFImage*>(registerParams->hOFGpuBuffer);
+        delete nvRes;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI ExecuteVk(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* executeOutParams) {
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+
+        return nvOF->Execute(executeInParams, executeOutParams);
+    }
+
+    NV_OF_STATUS __cdecl NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList) {
+        uint32_t apiVerMajor = (apiVer & 0xfffffff0) >> 4;
+        uint32_t apiVerMinor = (apiVer & 0xf);
+        constexpr auto n = __func__;
+
+        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") VK"));
+        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
+
+        if (apiVerMajor != 5)
+            return NV_OF_ERR_INVALID_VERSION;
+
+        functionList->nvCreateOpticalFlowVk = CreateOpticalFlowVk;
+        functionList->nvOFInit = OFSessionInit;
+        functionList->nvOFGetSurfaceFormatCountVk = GetSurfaceFormatCountVk;
+        functionList->nvOFGetSurfaceFormatVk = GetSurfaceFormatVk;
+        functionList->nvOFRegisterResourceVk = RegisterResourceVk;
+        functionList->nvOFUnregisterResourceVk = UnregisterResourceVk;
+        functionList->nvOFExecuteVk = ExecuteVk;
+        functionList->nvOFDestroy = OFSessionDestroy;
+        functionList->nvOFGetLastError = OFSessionGetLastError;
+        functionList->nvOFGetCaps = OFSessionGetCaps;
+
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi/nvofapi_vulkan.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
similarity index 89%
rename from src/nvofapi/nvofapi_vulkan.cpp
rename to src/vulkan/nvofapi_vulkan_instance.cpp
index 308ccad4..b1dcd93d 100644
--- a/src/nvofapi/nvofapi_vulkan.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -26,7 +26,7 @@
 
 #include "../inc/nvofapi/nvOpticalFlowVulkan.h"
 
-#include "nvofapi.h"
+#include "vulkan/nvofapi_vulkan_instance.h"
 
 namespace nvofapi {
 
@@ -84,26 +84,6 @@ namespace nvofapi {
         return true;
     }
 
-    bool NvOFImageVk::Initialize(PFN_vkCreateImageView fpCreateImageView,
-        PFN_vkDestroyImageView fpDestroyImageView) {
-        m_vkDestroyImageView = fpDestroyImageView;
-        VkOpticalFlowSessionBindingPointNV bindingPoint;
-        VkImageViewCreateInfo viewInfo = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
-        viewInfo.image = m_image;
-        viewInfo.format = m_format;
-
-        // XXX[ljm] remaining or 1???
-        viewInfo.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS};
-        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
-        viewInfo.flags = 0;
-
-        auto ret = fpCreateImageView(m_ofInstance->GetVkDevice(), &viewInfo, NULL, &m_imageView);
-        if (ret != VK_SUCCESS) {
-            return false;
-        }
-        return true;
-    }
-
     NV_OF_STATUS NvOFInstanceVk::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams) {
         dxvk::log::info(
             dxvk::str::format("OFExecuteVK params:",
diff --git a/src/vulkan/nvofapi_vulkan_instance.h b/src/vulkan/nvofapi_vulkan_instance.h
new file mode 100644
index 00000000..dd4ba616
--- /dev/null
+++ b/src/vulkan/nvofapi_vulkan_instance.h
@@ -0,0 +1,60 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "nvofapi/nvofapi_instance.h"
+
+namespace nvofapi {
+    class NvOFInstanceVk : public NvOFInstance {
+      public:
+        NvOFInstanceVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice) : NvOFInstance(vkInstance, vkPhysicalDevice, vkDevice) {
+        }
+        virtual ~NvOFInstanceVk() {
+            // free cmdbuffers
+            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, CMDS_IN_FLIGHT, m_commandBuffers);
+            m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
+        }
+        bool Initialize();
+
+        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
+
+      private:
+        VkQueue m_queue;
+        VkCommandPool m_commandPool;
+        PFN_vkCreateCommandPool m_vkCreateCommandPool;
+        PFN_vkDestroyCommandPool m_vkDestroyCommandPool;
+        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT];
+
+        PFN_vkAllocateCommandBuffers m_vkAllocateCommandBuffers;
+        PFN_vkFreeCommandBuffers m_vkFreeCommandBuffers;
+
+        uint32_t m_cmdBufIndex = 0;
+        PFN_vkResetCommandBuffer m_vkResetCommandBuffer;
+        PFN_vkBeginCommandBuffer m_vkBeginCommandBuffer;
+        PFN_vkEndCommandBuffer m_vkEndCommandBuffer;
+
+        PFN_vkGetDeviceQueue m_vkGetDeviceQueue;
+        PFN_vkQueueSubmit2 m_vkQueueSubmit2{};
+    };
+}

From f862c17492a99eb6e5abb0bc19881bed560bc22a Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Tue, 29 Oct 2024 22:08:52 -0700
Subject: [PATCH] util/statuscode: Add NvOFAPI functions

---
 src/util/util_statuscode.h | 184 +++++++++++++++++++++++++++++++++++++
 1 file changed, 184 insertions(+)

diff --git a/src/util/util_statuscode.h b/src/util/util_statuscode.h
index 5fd1675c..6de378d0 100644
--- a/src/util/util_statuscode.h
+++ b/src/util/util_statuscode.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include "../nvapi_private.h"
+#include "../inc/nvofapi/nvOpticalFlowCommon.h"
 #include "util_string.h"
 #include "util_log.h"
 
@@ -151,4 +152,187 @@ namespace dxvk {
         log::info(str::format("<-", logMessage, ": Insufficient Buffer"));
         return NVAPI_INSUFFICIENT_BUFFER;
     }
+
+    inline NV_OF_STATUS Success() {
+        return NV_OF_SUCCESS;
+    }
+
+    inline NV_OF_STATUS Success(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Success"));
+        return NV_OF_SUCCESS;
+    }
+
+    inline NV_OF_STATUS Success(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Success"));
+
+        return NV_OF_SUCCESS;
+    }
+
+    inline NV_OF_STATUS OFNotAvailable() {
+        return NV_OF_ERR_OF_NOT_AVAILABLE;
+    }
+
+    inline NV_OF_STATUS OFNotAvailable(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": OpticalFlow Not Available"));
+        return NV_OF_ERR_OF_NOT_AVAILABLE;
+    }
+
+    inline NV_OF_STATUS OFNotAvailable(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": OpticalFlow Not Available"));
+
+        return NV_OF_ERR_OF_NOT_AVAILABLE;
+    }
+
+    inline NV_OF_STATUS UnsupportedDevice() {
+        return NV_OF_ERR_UNSUPPORTED_DEVICE;
+    }
+
+    inline NV_OF_STATUS UnsupportedDevice(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Unsupported Device"));
+        return NV_OF_ERR_UNSUPPORTED_DEVICE;
+    }
+
+    inline NV_OF_STATUS UnsupportedDevice(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Unsupported Device"));
+
+        return NV_OF_ERR_UNSUPPORTED_DEVICE;
+    }
+
+    inline NV_OF_STATUS DeviceDoesNotExist() {
+        return NV_OF_ERR_DEVICE_DOES_NOT_EXIST;
+    }
+
+    inline NV_OF_STATUS DeviceDoesNotExist(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Device Does Not Exist"));
+        return NV_OF_ERR_DEVICE_DOES_NOT_EXIST;
+    }
+
+    inline NV_OF_STATUS DeviceDoesNotExist(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Device Does Not Exist"));
+        return NV_OF_ERR_DEVICE_DOES_NOT_EXIST;
+    }
+
+    inline NV_OF_STATUS InvalidPtr() {
+        return NV_OF_ERR_INVALID_PTR;
+    }
+
+    inline NV_OF_STATUS InvalidPtr(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Invalid Pointer"));
+        return NV_OF_ERR_INVALID_PTR;
+    }
+
+    inline NV_OF_STATUS InvalidPtr(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Invalid Pointer"));
+        return NV_OF_ERR_INVALID_PTR;
+    }
+
+    inline NV_OF_STATUS InvalidParam() {
+        return NV_OF_ERR_INVALID_PARAM;
+    }
+
+    inline NV_OF_STATUS InvalidParam(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Invalid Parameter"));
+        return NV_OF_ERR_INVALID_PARAM;
+    }
+
+    inline NV_OF_STATUS InvalidParam(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Invalid Parameter"));
+        return NV_OF_ERR_INVALID_PARAM;
+    }
+
+    inline NV_OF_STATUS InvalidCall() {
+        return NV_OF_ERR_INVALID_CALL;
+    }
+
+    inline NV_OF_STATUS InvalidCall(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Invalid Call"));
+        return NV_OF_ERR_INVALID_CALL;
+    }
+
+    inline NV_OF_STATUS InvalidCall(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Invalid Call"));
+        return NV_OF_ERR_INVALID_CALL;
+    }
+
+    inline NV_OF_STATUS InvalidVersion() {
+        return NV_OF_ERR_INVALID_VERSION;
+    }
+
+    inline NV_OF_STATUS InvalidVersion(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Invalid Version"));
+        return NV_OF_ERR_INVALID_VERSION;
+    }
+
+    inline NV_OF_STATUS InvalidVersion(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Invalid Version"));
+        return NV_OF_ERR_INVALID_VERSION;
+    }
+
+    inline NV_OF_STATUS OutOfMemory() {
+        return NV_OF_ERR_OUT_OF_MEMORY;
+    }
+
+    inline NV_OF_STATUS OutOfMemory(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Out of Memory"));
+        return NV_OF_ERR_OUT_OF_MEMORY;
+    }
+
+    inline NV_OF_STATUS OutOfMemory(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Out of Memory"));
+        return NV_OF_ERR_OUT_OF_MEMORY;
+    }
+
+    inline NV_OF_STATUS NotInitialized() {
+        return NV_OF_ERR_NOT_INITIALIZED;
+    }
+
+    inline NV_OF_STATUS NotInitialized(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Not Initialized"));
+        return NV_OF_ERR_NOT_INITIALIZED;
+    }
+
+    inline NV_OF_STATUS NotInitialized(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Not Initialized"));
+        return NV_OF_ERR_NOT_INITIALIZED;
+    }
+
+    inline NV_OF_STATUS UnsupportedFeature() {
+        return NV_OF_ERR_UNSUPPORTED_FEATURE;
+    }
+
+    inline NV_OF_STATUS UnsupportedFeature(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Unsupported Feature"));
+        return NV_OF_ERR_UNSUPPORTED_FEATURE;
+    }
+
+    inline NV_OF_STATUS UnsupportedFeature(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Unsupported Feature"));
+        return NV_OF_ERR_UNSUPPORTED_FEATURE;
+    }
+
+    inline NV_OF_STATUS GenericError() {
+        return NV_OF_ERR_GENERIC;
+    }
+
+    inline NV_OF_STATUS GenericError(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Generic Error"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    inline NV_OF_STATUS GenericError(const std::string& logMessage, bool& alreadyLogged) {
+        if (log::tracing() || !std::exchange(alreadyLogged, true))
+            log::info(str::format("<-", logMessage, ": Generic Error"));
+        return NV_OF_ERR_GENERIC;
+    }
 }

From 29f2f98629e16376888221a687476a86a8110bf2 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Tue, 29 Oct 2024 22:28:49 -0700
Subject: [PATCH] nvofapi: Use statuscode util and improve logging

Additionally, fixup some stray warnings in affected files.
---
 src/d3d12/nvofapi_d3d12_instance.cpp   | 14 ++---
 src/d3d12/nvofapi_d3d12_instance.h     |  6 +-
 src/nvofapi.cpp                        | 49 ++++++++++++-----
 src/nvofapi/nvofapi_common.cpp         | 74 ++++++++++++++-----------
 src/nvofapi/nvofapi_image.cpp          |  4 +-
 src/nvofapi/nvofapi_instance.h         |  4 +-
 src/nvofapi_d3d12.cpp                  | 76 ++++++++++++++++++--------
 src/nvofapi_vulkan.cpp                 | 72 +++++++++++++++++-------
 src/util/util_statuscode.h             | 10 ++--
 src/vulkan/nvofapi_vulkan_instance.cpp | 25 +++++----
 src/vulkan/nvofapi_vulkan_instance.h   |  2 +-
 11 files changed, 213 insertions(+), 123 deletions(-)

diff --git a/src/d3d12/nvofapi_d3d12_instance.cpp b/src/d3d12/nvofapi_d3d12_instance.cpp
index 4e638c9c..d811e73a 100644
--- a/src/d3d12/nvofapi_d3d12_instance.cpp
+++ b/src/d3d12/nvofapi_d3d12_instance.cpp
@@ -68,7 +68,7 @@ namespace nvofapi {
             return false;
         }
 
-        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)GetProcAddress(m_library, "vkGetInstanceProcAddr");
+        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr) reinterpret_cast<void*>(GetProcAddress(m_library, "vkGetInstanceProcAddr"));
         m_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetDeviceProcAddr");
         m_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
 
@@ -94,7 +94,7 @@ namespace nvofapi {
             != S_OK) {
             return false;
         }
-        for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+        for (uint32_t i = 0; i < CMDS_IN_FLIGHT; i++) {
             if (m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdList[i]))
                 != S_OK) {
                 return false;
@@ -103,7 +103,7 @@ namespace nvofapi {
         return true;
     }
 
-    NV_OF_STATUS NvOFInstanceD3D12::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+    void NvOFInstanceD3D12::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
         NV_OF_REGISTER_RESOURCE_PARAMS_VK vkParams{};
         dxvk::log::info(
             dxvk::str::format("RegisterBuffer DX: resource: ",
@@ -124,10 +124,10 @@ namespace nvofapi {
         assert(registerParams->inputFencePoint.value == 0);
         assert(registerParams->outputFencePoint.fence == nullptr);
         assert(registerParams->outputFencePoint.value == 0);
-        return ((NvOFInstance*)this)->RegisterBuffer(&vkParams);
+        ((NvOFInstance*)this)->RegisterBuffer(&vkParams);
     }
 
-    NV_OF_STATUS NvOFInstanceD3D12::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams) {
+    void NvOFInstanceD3D12::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams) {
         // Convert the D3D12 parameters to VK parameters
         NV_OF_EXECUTE_INPUT_PARAMS_VK vkInputParams{};
         NV_OF_EXECUTE_OUTPUT_PARAMS_VK vkOutputParams{};
@@ -152,7 +152,7 @@ namespace nvofapi {
         // happens using D3D12.
         m_cmdList[m_cmdListIndex]->Reset(m_cmdAllocator, nullptr);
 
-        for (int i = 0; i < inParams->numFencePoints; i++) {
+        for (uint32_t i = 0; i < inParams->numFencePoints; i++) {
             m_commandQueue->Wait(inParams->fencePoint[i].fence, inParams->fencePoint[i].value);
         }
 
@@ -171,8 +171,6 @@ namespace nvofapi {
         m_cmdListIndex++;
         if (m_cmdListIndex >= CMDS_IN_FLIGHT)
             m_cmdListIndex = 0;
-
-        return NV_OF_SUCCESS;
     }
 
 }
diff --git a/src/d3d12/nvofapi_d3d12_instance.h b/src/d3d12/nvofapi_d3d12_instance.h
index 7b7ccdc5..aa7ca243 100644
--- a/src/d3d12/nvofapi_d3d12_instance.h
+++ b/src/d3d12/nvofapi_d3d12_instance.h
@@ -42,7 +42,7 @@ namespace nvofapi {
         bool Initialize();
         NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
         virtual ~NvOFInstanceD3D12() {
-            for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+            for (uint32_t i = 0; i < CMDS_IN_FLIGHT; i++) {
                 if (m_cmdList[i])
                     m_cmdList[i]->Release();
             }
@@ -62,8 +62,8 @@ namespace nvofapi {
                 m_device->Release();
         }
 
-        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
+        void RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
 
-        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
+        void Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
     };
 }
diff --git a/src/nvofapi.cpp b/src/nvofapi.cpp
index 016f02ab..6096c256 100644
--- a/src/nvofapi.cpp
+++ b/src/nvofapi.cpp
@@ -26,52 +26,73 @@
 #include "util/util_env.h"
 #include "util/util_log.h"
 #include "util/util_string.h"
+#include "util/util_statuscode.h"
 #include "../version.h"
 
+using namespace dxvk;
+
 extern "C" {
     // Common entrypoints
     NV_OF_STATUS NVOFAPI OFSessionInit(NvOFHandle hOf, const NV_OF_INIT_PARAMS* initParams) {
-        dxvk::log::info("OFSessionInit called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(initParams));
+
         nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
 
         if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("OFSessionInit failed!"));
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric(n);
         }
 
         return nvOF->InitSession(initParams);
     }
 
     NV_OF_STATUS NVOFAPI OFSessionDestroy(NvOFHandle hOf) {
-        dxvk::log::info("OFSessionDestroy called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf));
+
         nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
         if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("OFSessionDestroy failed!"));
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric(n);
         }
 
         delete nvOF;
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI OFSessionGetLastError(NvOFHandle hOf, char lastError[], uint32_t* size) {
-        dxvk::log::info("OFSessionGetLastError called");
-        dxvk::log::info(dxvk::str::format("OFSessionGetLastError failed!"));
-        return NV_OF_ERR_GENERIC;
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(lastError), log::fmt::ptr(size));
+
+        return ErrorGeneric(n);
     }
 
     NV_OF_STATUS NVOFAPI OFSessionGetCaps(NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t* capsVal, uint32_t* size) {
-        dxvk::log::info("OFSessionGetCaps called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), capsParam, log::fmt::ptr(capsVal), log::fmt::ptr(size));
+
         nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
 
         return nvOF->getCaps(capsParam, capsVal, size);
     }
 
-    NV_OF_STATUS __cdecl NvOFGetMaxSupportedApiVersion(uint32_t* version) {
+    NV_OF_STATUS NVOFAPI NvOFGetMaxSupportedApiVersion(uint32_t* version) {
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::ptr(version));
+
         if (!version)
-            return NV_OF_ERR_INVALID_PTR;
+            return InvalidPtr(n);
 
         *version = NV_OF_API_VERSION;
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 }
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index 1a298b7a..c483aec7 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -23,12 +23,14 @@
 
 #include "util/util_log.h"
 #include "util/util_string.h"
+#include "util/util_statuscode.h"
 
 #include "../inc/nvofapi/nvOpticalFlowVulkan.h"
 
 #include "nvofapi_image.h"
 #include "nvofapi_instance.h"
 
+using namespace dxvk;
 namespace nvofapi {
 
     typedef struct NV_OF_PRIV_DATA {
@@ -51,7 +53,7 @@ namespace nvofapi {
         VkQueueFamilyProperties* queueFamProps = (VkQueueFamilyProperties*)calloc(sizeof(VkQueueFamilyProperties), count);
         m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, queueFamProps);
 
-        for (int i = 0; i < count; i++) {
+        for (uint32_t i = 0; i < count; i++) {
             if (queueFamProps[i].queueFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
                 free(queueFamProps);
                 return i;
@@ -62,23 +64,26 @@ namespace nvofapi {
     }
 
     NV_OF_STATUS NvOFInstance::InitSession(const NV_OF_INIT_PARAMS* initParams) {
-        dxvk::log::info(
-            dxvk::str::format("OFSessionInit params:",
-                " width: ", initParams->width,
-                " height: ", initParams->height,
-                " outGrid: ", initParams->outGridSize,
-                " hintGrid: ", initParams->hintGridSize,
-                " mode: ", initParams->mode,
-                " perfLevel: ", initParams->perfLevel,
-                " enableExternalHints: ", initParams->enableExternalHints,
-                " enableOutputCost: ", initParams->enableOutputCost,
-                " hPrivData: ", initParams->hPrivData,
-                " enableRoi: ", initParams->enableRoi,
-                " predDirection: ", initParams->predDirection,
-                " enableGlobalFlow: ", initParams->enableGlobalFlow,
-                " inputBufferFormat: ", initParams->inputBufferFormat));
-
-        VkOpticalFlowSessionCreateInfoNV createInfo = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV};
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n,
+                initParams->width,
+                initParams->height,
+                initParams->outGridSize,
+                initParams->hintGridSize,
+                initParams->mode,
+                initParams->perfLevel,
+                initParams->enableExternalHints,
+                initParams->enableOutputCost,
+                log::fmt::hnd(initParams->hPrivData),
+                initParams->enableRoi,
+                initParams->predDirection,
+                initParams->enableGlobalFlow,
+                initParams->inputBufferFormat);
+
+        VkOpticalFlowSessionCreateInfoNV createInfo{};
+        createInfo.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV;
         createInfo.width = initParams->width;
         createInfo.height = initParams->height;
         createInfo.outputGridSize = VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV;
@@ -108,10 +113,14 @@ namespace nvofapi {
             case NV_OF_BUFFER_FORMAT_ABGR8:
                 createInfo.imageFormat = VK_FORMAT_B8G8R8A8_UNORM;
                 break;
+            default:
+                createInfo.imageFormat = VK_FORMAT_UNDEFINED;
+                break;
         }
 
         // Need to get the size/id for the private data to pass it along to VK...
-        VkOpticalFlowSessionCreatePrivateDataInfoNV privData = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV};
+        VkOpticalFlowSessionCreatePrivateDataInfoNV privData{};
+        privData.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
         privData.size = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->size;
         privData.id = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->id;
         privData.pPrivateData = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->data;
@@ -121,17 +130,17 @@ namespace nvofapi {
         auto ret = m_vkCreateOpticalFlowSessionNV(m_vkDevice, &createInfo, NULL, &m_vkOfaSession);
 
         if (ret == VK_SUCCESS) {
-            return NV_OF_SUCCESS;
+            return Success();
         }
 
-        return NV_OF_ERR_GENERIC;
+        return ErrorGeneric();
     }
 
     NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFImage* image, VkOpticalFlowSessionBindingPointNV bindingPoint) {
         VkImageLayout layout = VK_IMAGE_LAYOUT_GENERAL;
 
         if (!image)
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric();
 
         auto ret = m_vkBindOpticalFlowSessionImageNV(m_vkDevice,
             m_vkOfaSession,
@@ -139,9 +148,9 @@ namespace nvofapi {
             image->ImageView(),
             layout);
         if (ret != VK_SUCCESS) {
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric();
         }
-        return NV_OF_SUCCESS;
+        return Success();
     }
 
     NV_OF_STATUS NvOFInstance::getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size) {
@@ -152,19 +161,18 @@ namespace nvofapi {
             }
 
             // XXX[ljm] query VkPhysicalDevice for actual support
-            return NV_OF_SUCCESS;
+            return Success();
         }
-        return NV_OF_ERR_GENERIC;
+        return ErrorGeneric();
     }
 
-    NV_OF_STATUS NvOFInstance::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
+    void NvOFInstance::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
         NvOFImage* nvOFImage = new NvOFImage(m_vkDevice, registerParams->image, registerParams->format);
         nvOFImage->Initialize(m_vkCreateImageView, m_vkDestroyImageView);
         *registerParams->hOFGpuBuffer = reinterpret_cast<NvOFGPUBufferHandle>(nvOFImage);
-        return NV_OF_SUCCESS;
     }
 
-    NV_OF_STATUS NvOFInstance::RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf) {
+    void NvOFInstance::RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf) {
         BindImageToSession(reinterpret_cast<NvOFImage*>(inParams->inputFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
         BindImageToSession(reinterpret_cast<NvOFImage*>(inParams->referenceFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
         BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->outputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
@@ -175,7 +183,7 @@ namespace nvofapi {
         // Support INPUT_MIPS execute priv data
         if (((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
             NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS* mipData = ((NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS*)((NV_OF_PRIV_DATA*)inParams->hPrivData)->data);
-            for (int i = 0; i < 6; i++) {
+            for (uint32_t i = 0; i < 6; i++) {
                 if (mipData->input[i] && mipData->reference[i]) {
                     BindImageToSession(reinterpret_cast<NvOFImage*>(mipData->input[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
                     BindImageToSession(reinterpret_cast<NvOFImage*>(mipData->reference[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
@@ -186,7 +194,7 @@ namespace nvofapi {
 
         if (inParams->numRois) {
             regions = (VkRect2D*)calloc(sizeof(VkRect2D), inParams->numRois);
-            for (int i = 0; i < inParams->numRois; i++) {
+            for (uint32_t i = 0; i < inParams->numRois; i++) {
                 regions[i].offset.x = inParams->roiData[i].start_x;
                 regions[i].offset.y = inParams->roiData[i].start_y;
                 regions[i].extent.width = inParams->roiData[i].width;
@@ -194,7 +202,8 @@ namespace nvofapi {
             }
         }
 
-        VkOpticalFlowExecuteInfoNV ofaExecuteInfo = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV};
+        VkOpticalFlowExecuteInfoNV ofaExecuteInfo{};
+        ofaExecuteInfo.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV;
         ofaExecuteInfo.regionCount = inParams->numRois;
         ofaExecuteInfo.pRegions = regions;
 
@@ -205,6 +214,5 @@ namespace nvofapi {
         m_vkCmdOpticalFlowExecuteNV(cmdBuf, m_vkOfaSession, &ofaExecuteInfo);
 
         free(regions);
-        return NV_OF_SUCCESS;
     }
 }
diff --git a/src/nvofapi/nvofapi_image.cpp b/src/nvofapi/nvofapi_image.cpp
index e99dc2cb..0786010a 100644
--- a/src/nvofapi/nvofapi_image.cpp
+++ b/src/nvofapi/nvofapi_image.cpp
@@ -27,8 +27,8 @@ namespace nvofapi {
     bool NvOFImage::Initialize(PFN_vkCreateImageView fpCreateImageView,
         PFN_vkDestroyImageView fpDestroyImageView) {
         m_vkDestroyImageView = fpDestroyImageView;
-        VkOpticalFlowSessionBindingPointNV bindingPoint;
-        VkImageViewCreateInfo viewInfo = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
+        VkImageViewCreateInfo viewInfo{};
+        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
         viewInfo.image = m_image;
         viewInfo.format = m_format;
 
diff --git a/src/nvofapi/nvofapi_instance.h b/src/nvofapi/nvofapi_instance.h
index f886aee1..c06a6d86 100644
--- a/src/nvofapi/nvofapi_instance.h
+++ b/src/nvofapi/nvofapi_instance.h
@@ -73,10 +73,10 @@ namespace nvofapi {
 
         NV_OF_STATUS InitSession(const NV_OF_INIT_PARAMS* initParams);
 
-        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
+        void RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
 
         NV_OF_STATUS BindImageToSession(NvOFImage* image, VkOpticalFlowSessionBindingPointNV bindingPoint);
 
-        NV_OF_STATUS RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
+        void RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
     };
 }
diff --git a/src/nvofapi_d3d12.cpp b/src/nvofapi_d3d12.cpp
index ec8cfc8a..b095866a 100644
--- a/src/nvofapi_d3d12.cpp
+++ b/src/nvofapi_d3d12.cpp
@@ -22,77 +22,102 @@
  */
 
 #include "nvofapi/nvofapi_entrypoints.h"
+#include "nvofapi/nvofapi_image.h"
 #include "d3d12/nvofapi_d3d12_instance.h"
 
 #include "util/util_env.h"
 #include "util/util_log.h"
 #include "util/util_string.h"
+#include "util/util_statuscode.h"
 #include "../version.h"
 
+using namespace dxvk;
 extern "C" {
 
     // D3D12 entrypoints
     NV_OF_STATUS NVOFAPI CreateOpticalFlowD3D12(ID3D12Device* pD3D12Device, NvOFHandle* hOFInstance) {
-        dxvk::log::info("CreateOpticalFlowD3D12 called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::ptr(pD3D12Device), log::fmt::ptr(hOFInstance));
 
         nvofapi::NvOFInstanceD3D12* nvOF = nullptr;
         try {
             nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
-        } catch (std::exception e) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
+        } catch (std::exception const& e) {
+            log::info(str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
         }
 
         if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed allocation"));
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric(n);
         }
 
         if (!nvOF->Initialize()) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed creation"));
             delete nvOF;
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric(n);
         }
 
         *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
-        dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 end"));
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI GetSurfaceFormatCountD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
-        dxvk::log::info("GetSurfaceFormatCountD3D12 called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), bufferUsage, ofMode, log::fmt::ptr(pCount));
+
         *pCount = 1;
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI GetSurfaceFormatD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat) {
-        dxvk::log::info("GetSurfaceFormatD3D12 called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), bufferUsage, ofMode, log::fmt::ptr(pFormat));
+
         if (bufferUsage == NV_OF_BUFFER_USAGE_INPUT)
             *pFormat = DXGI_FORMAT_R8_UNORM;
         else
             *pFormat = DXGI_FORMAT_R16G16_SINT;
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI RegisterResourceD3D12(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
-        dxvk::log::info("RegisterResourceD3D12 called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(registerParams));
+
         nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
 
-        return nvOF->RegisterBuffer(registerParams);
+        nvOF->RegisterBuffer(registerParams);
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI UnregisterResourceD3D12(NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
-        dxvk::log::info("UnregisterResourceD3D12 called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::ptr(registerParams));
+
         nvofapi::NvOFImage* nvRes = reinterpret_cast<nvofapi::NvOFImage*>(registerParams->hOFGpuBuffer);
         delete nvRes;
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI ExecuteD3D12(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* executeOutParams) {
-        dxvk::log::info("ExecuteD3D12 called");
-        dxvk::log::info(dxvk::str::format("handle: %p", hOf));
+        constexpr auto n = __func__;
+        thread_local bool alreadyLoggedOk = false;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(executeInParams), log::fmt::ptr(executeOutParams));
+
         nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
 
-        return nvOF->Execute(executeInParams, executeOutParams);
+        nvOF->Execute(executeInParams, executeOutParams);
+        return Success(n, alreadyLoggedOk);
     }
 
     // ETBLs
@@ -101,11 +126,14 @@ extern "C" {
         uint32_t apiVerMinor = (apiVer & 0xf);
         constexpr auto n = __func__;
 
-        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") D3D12"));
-        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
+        if (log::tracing())
+            log::trace(n, apiVer, log::fmt::ptr(functionList));
+
+        log::info(str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", env::getExecutableName(), ") D3D12"));
+        log::info(str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
 
         if (apiVerMajor != 5)
-            return NV_OF_ERR_INVALID_VERSION;
+            return InvalidVersion(n);
 
         functionList->nvCreateOpticalFlowD3D12 = CreateOpticalFlowD3D12;
         functionList->nvOFInit = OFSessionInit;
@@ -118,6 +146,6 @@ extern "C" {
         functionList->nvOFGetLastError = OFSessionGetLastError;
         functionList->nvOFGetCaps = OFSessionGetCaps;
 
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 }
diff --git a/src/nvofapi_vulkan.cpp b/src/nvofapi_vulkan.cpp
index 25f08256..b5d4790a 100644
--- a/src/nvofapi_vulkan.cpp
+++ b/src/nvofapi_vulkan.cpp
@@ -22,63 +22,90 @@
  */
 
 #include "nvofapi/nvofapi_entrypoints.h"
+#include "nvofapi/nvofapi_image.h"
 #include "vulkan/nvofapi_vulkan_instance.h"
 
 #include "util/util_env.h"
 #include "util/util_log.h"
 #include "util/util_string.h"
+#include "util/util_statuscode.h"
 #include "../version.h"
 
+using namespace dxvk;
 extern "C" {
     // VK entrypoints
     NV_OF_STATUS NVOFAPI CreateOpticalFlowVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice, NvOFHandle* hOFInstance) {
-        dxvk::log::info("CreateOpticalFlowVk called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(vkInstance), log::fmt::hnd(vkPhysicalDevice), log::fmt::hnd(vkDevice), log::fmt::ptr(hOFInstance));
+
         nvofapi::NvOFInstanceVk* nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
 
         if (!nvOF) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed allocation"));
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric(n);
         }
 
         if (!nvOF->Initialize()) {
-            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed creation"));
             delete nvOF;
-            return NV_OF_ERR_GENERIC;
+            return ErrorGeneric(n);
         }
 
         *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI GetSurfaceFormatCountVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
-        dxvk::log::info("GetSurfaceFormatCountVk called");
-        dxvk::log::info(dxvk::str::format("GetSurfaceFormatCountVk failed!"));
-        return NV_OF_ERR_GENERIC;
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), bufferUsage, ofMode, log::fmt::ptr(pCount));
+
+        return ErrorGeneric(n);
     }
 
     NV_OF_STATUS NVOFAPI GetSurfaceFormatVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat) {
-        dxvk::log::info("GetSurfaceFormatVk called");
-        dxvk::log::info(dxvk::str::format("GetSurfaceFormatVk failed!"));
-        return NV_OF_ERR_GENERIC;
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), bufferUsage, ofMode, log::fmt::ptr(pFormat));
+
+        return ErrorGeneric(n);
     }
 
     NV_OF_STATUS NVOFAPI RegisterResourceVk(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
-        dxvk::log::info("RegisterResourceVk called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(registerParams));
+
         nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
-        return nvOF->RegisterBuffer(registerParams);
+        nvOF->RegisterBuffer(registerParams);
+        return Success(n);
     }
 
     NV_OF_STATUS NVOFAPI UnregisterResourceVk(NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* registerParams) {
-        dxvk::log::info("UnregisterResourceVk called");
+        constexpr auto n = __func__;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::ptr(registerParams));
+
         nvofapi::NvOFImage* nvRes = reinterpret_cast<nvofapi::NvOFImage*>(registerParams->hOFGpuBuffer);
         delete nvRes;
-        return NV_OF_SUCCESS;
+        return ErrorGeneric(n);
     }
 
     NV_OF_STATUS NVOFAPI ExecuteVk(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* executeOutParams) {
+        constexpr auto n = __func__;
+        thread_local bool alreadyLoggedOk = false;
+
+        if (log::tracing())
+            log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(executeInParams), log::fmt::ptr(executeOutParams));
+
         nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
 
-        return nvOF->Execute(executeInParams, executeOutParams);
+        nvOF->Execute(executeInParams, executeOutParams);
+        return Success(n, alreadyLoggedOk);
     }
 
     NV_OF_STATUS __cdecl NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList) {
@@ -86,11 +113,14 @@ extern "C" {
         uint32_t apiVerMinor = (apiVer & 0xf);
         constexpr auto n = __func__;
 
-        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") VK"));
-        dxvk::log::info(dxvk::str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
+        if (log::tracing())
+            log::trace(n, apiVer, log::fmt::ptr(functionList));
+
+        log::info(str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", env::getExecutableName(), ") VK"));
+        log::info(str::format("OFAPI Client Version: ", apiVerMajor, ".", apiVerMinor));
 
         if (apiVerMajor != 5)
-            return NV_OF_ERR_INVALID_VERSION;
+            return InvalidVersion(n);
 
         functionList->nvCreateOpticalFlowVk = CreateOpticalFlowVk;
         functionList->nvOFInit = OFSessionInit;
@@ -103,6 +133,6 @@ extern "C" {
         functionList->nvOFGetLastError = OFSessionGetLastError;
         functionList->nvOFGetCaps = OFSessionGetCaps;
 
-        return NV_OF_SUCCESS;
+        return Success(n);
     }
 }
diff --git a/src/util/util_statuscode.h b/src/util/util_statuscode.h
index 6de378d0..292cebf7 100644
--- a/src/util/util_statuscode.h
+++ b/src/util/util_statuscode.h
@@ -321,18 +321,18 @@ namespace dxvk {
         return NV_OF_ERR_UNSUPPORTED_FEATURE;
     }
 
-    inline NV_OF_STATUS GenericError() {
+    inline NV_OF_STATUS ErrorGeneric() {
         return NV_OF_ERR_GENERIC;
     }
 
-    inline NV_OF_STATUS GenericError(const std::string& logMessage) {
-        log::info(str::format("<-", logMessage, ": Generic Error"));
+    inline NV_OF_STATUS ErrorGeneric(const std::string& logMessage) {
+        log::info(str::format("<-", logMessage, ": Error"));
         return NV_OF_ERR_GENERIC;
     }
 
-    inline NV_OF_STATUS GenericError(const std::string& logMessage, bool& alreadyLogged) {
+    inline NV_OF_STATUS ErrorGeneric(const std::string& logMessage, bool& alreadyLogged) {
         if (log::tracing() || !std::exchange(alreadyLogged, true))
-            log::info(str::format("<-", logMessage, ": Generic Error"));
+            log::info(str::format("<-", logMessage, ": Error"));
         return NV_OF_ERR_GENERIC;
     }
 }
diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index b1dcd93d..f0463bac 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -36,7 +36,7 @@ namespace nvofapi {
             return false;
         }
 
-        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)GetProcAddress(m_library, "vkGetInstanceProcAddr");
+        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr) reinterpret_cast<void*>(GetProcAddress(m_library, "vkGetInstanceProcAddr"));
         m_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetDeviceProcAddr");
         m_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
 
@@ -62,7 +62,8 @@ namespace nvofapi {
         m_vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCmdOpticalFlowExecuteNV");
 
         // Get the OFA queue
-        VkCommandPoolCreateInfo createInfo = {VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};
+        VkCommandPoolCreateInfo createInfo{};
+        createInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
         createInfo.queueFamilyIndex = GetVkOFAQueue();
         m_vkGetDeviceQueue(m_vkDevice, createInfo.queueFamilyIndex, 0, &m_queue);
 
@@ -72,7 +73,8 @@ namespace nvofapi {
         }
 
         // ALlocate command buffers
-        VkCommandBufferAllocateInfo allocInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
+        VkCommandBufferAllocateInfo allocInfo{};
+        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
         allocInfo.commandPool = m_commandPool;
         allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
         allocInfo.commandBufferCount = CMDS_IN_FLIGHT; // more than enough for anybody ;)
@@ -84,7 +86,7 @@ namespace nvofapi {
         return true;
     }
 
-    NV_OF_STATUS NvOFInstanceVk::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams) {
+    void NvOFInstanceVk::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams) {
         dxvk::log::info(
             dxvk::str::format("OFExecuteVK params:",
                 " inputFrame: ", inParams->inputFrame,
@@ -101,7 +103,7 @@ namespace nvofapi {
 
         if (inParams->numWaitSyncs) {
             waitSyncs = (VkSemaphoreSubmitInfo*)calloc(sizeof(VkSemaphoreSubmitInfo), inParams->numWaitSyncs);
-            for (int i = 0; i < inParams->numWaitSyncs; i++) {
+            for (uint32_t i = 0; i < inParams->numWaitSyncs; i++) {
                 waitSyncs[i].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
                 waitSyncs[i].semaphore = inParams->pWaitSyncs[i].semaphore;
                 waitSyncs[i].value = inParams->pWaitSyncs[i].value;
@@ -109,18 +111,21 @@ namespace nvofapi {
             }
         }
 
-        VkSemaphoreSubmitInfo signalSync = {VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO};
+        VkSemaphoreSubmitInfo signalSync{};
+        signalSync.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
         if (outParams->pSignalSync) {
             signalSync.semaphore = outParams->pSignalSync->semaphore;
             signalSync.value = outParams->pSignalSync->value;
             signalSync.stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
         }
 
-        VkCommandBufferSubmitInfo cmdbufInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO};
+        VkCommandBufferSubmitInfo cmdbufInfo{};
+        cmdbufInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO;
         cmdbufInfo.commandBuffer = m_commandBuffers[m_cmdBufIndex];
         cmdbufInfo.deviceMask = 1;
 
-        VkCommandBufferBeginInfo begInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
+        VkCommandBufferBeginInfo begInfo{};
+        begInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
         m_vkResetCommandBuffer(m_commandBuffers[m_cmdBufIndex], 0);
         m_vkBeginCommandBuffer(m_commandBuffers[m_cmdBufIndex], &begInfo);
 
@@ -128,7 +133,8 @@ namespace nvofapi {
 
         m_vkEndCommandBuffer(m_commandBuffers[m_cmdBufIndex]);
 
-        VkSubmitInfo2 submit = {VK_STRUCTURE_TYPE_SUBMIT_INFO_2};
+        VkSubmitInfo2 submit{};
+        submit.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
         submit.waitSemaphoreInfoCount = inParams->numWaitSyncs;
         submit.pWaitSemaphoreInfos = waitSyncs;
         submit.commandBufferInfoCount = 1;
@@ -143,6 +149,5 @@ namespace nvofapi {
         m_cmdBufIndex++;
         if (m_cmdBufIndex >= CMDS_IN_FLIGHT)
             m_cmdBufIndex = 0;
-        return NV_OF_SUCCESS;
     }
 }
diff --git a/src/vulkan/nvofapi_vulkan_instance.h b/src/vulkan/nvofapi_vulkan_instance.h
index dd4ba616..59b27757 100644
--- a/src/vulkan/nvofapi_vulkan_instance.h
+++ b/src/vulkan/nvofapi_vulkan_instance.h
@@ -37,7 +37,7 @@ namespace nvofapi {
         }
         bool Initialize();
 
-        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
+        void Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
 
       private:
         VkQueue m_queue;

From a0d7c83ccb0f09bfe0f065ed4994e64bc3ed9dbc Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Tue, 29 Oct 2024 23:40:00 -0700
Subject: [PATCH] nvofapi-vulkan: Load vulkan-1.dll instead of winevulkan.dll

---
 src/vulkan/nvofapi_vulkan_instance.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index f0463bac..90c04c41 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -31,7 +31,9 @@
 namespace nvofapi {
 
     bool NvOFInstanceVk::Initialize() {
-        m_library = LoadLibraryA("winevulkan.dll");
+        // For VK we cannot load winevulkan directly or we may break handle
+        // opacity.
+        m_library = LoadLibraryA("vulkan-1.dll");
         if (!m_library) {
             return false;
         }

From aec1b74a1ea416cb0d5e92d9be4e35809ae8322e Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 21:39:25 -0700
Subject: [PATCH] nvofapi: Address style feedback

---
 src/d3d12/nvofapi_d3d12_instance.cpp   | 35 ++++++------------
 src/d3d12/nvofapi_d3d12_instance.h     | 27 +++++++-------
 src/nvofapi.cpp                        |  6 ++--
 src/nvofapi/nvofapi_common.cpp         | 32 ++++++++---------
 src/nvofapi/nvofapi_image.cpp          |  2 +-
 src/nvofapi/nvofapi_image.h            | 18 +++++-----
 src/nvofapi/nvofapi_instance.h         | 50 +++++++++++++-------------
 src/nvofapi_d3d12.cpp                  |  4 +--
 src/nvofapi_vulkan.cpp                 |  6 ++--
 src/vulkan/nvofapi_vulkan_instance.cpp |  2 +-
 src/vulkan/nvofapi_vulkan_instance.h   |  3 +-
 11 files changed, 88 insertions(+), 97 deletions(-)

diff --git a/src/d3d12/nvofapi_d3d12_instance.cpp b/src/d3d12/nvofapi_d3d12_instance.cpp
index d811e73a..3bb4ed31 100644
--- a/src/d3d12/nvofapi_d3d12_instance.cpp
+++ b/src/d3d12/nvofapi_d3d12_instance.cpp
@@ -33,27 +33,18 @@ namespace nvofapi {
     NvOFInstanceD3D12::NvOFInstanceD3D12(ID3D12Device* pD3D12Device) {
         // Query for the extension interface
         // Grab the vk triad
-        HRESULT status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_device));
-
-        if (S_OK != status) {
+        if (FAILED(pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_device))))
             throw std::invalid_argument("Failed to query interface for m_device");
-        }
 
         m_device->GetVulkanHandles(&m_vkInstance,
             &m_vkPhysicalDevice,
             &m_vkDevice);
 
-        status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_d3ddevice));
-
-        if (S_OK != status) {
+        if (FAILED(pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_d3ddevice))))
             throw std::invalid_argument("Failed to query interface for m_d3ddevice");
-        }
-
-        status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_deviceExt));
 
-        if (S_OK != status) {
+        if (FAILED(pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_deviceExt))))
             throw std::invalid_argument("Failed to query interface for m_deviceExt");
-        }
     }
 
     bool NvOFInstanceD3D12::Initialize() {
@@ -86,19 +77,15 @@ namespace nvofapi {
         m_vkQueueFamilyIndex = GetVkOFAQueue();
 
         D3D12_COMMAND_QUEUE_DESC desc{};
-        if (m_device->CreateInteropCommandQueue(&desc, m_vkQueueFamilyIndex, &m_commandQueue)
-            != S_OK) {
+        if (FAILED(m_device->CreateInteropCommandQueue(&desc, m_vkQueueFamilyIndex, &m_commandQueue)))
             return false;
-        }
-        if (m_device->CreateInteropCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, m_vkQueueFamilyIndex, &m_cmdAllocator)
-            != S_OK) {
+
+        if (FAILED(m_device->CreateInteropCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, m_vkQueueFamilyIndex, &m_cmdAllocator)))
             return false;
-        }
+
         for (uint32_t i = 0; i < CMDS_IN_FLIGHT; i++) {
-            if (m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdList[i]))
-                != S_OK) {
+            if (FAILED(m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdList[i]))))
                 return false;
-            }
         }
         return true;
     }
@@ -108,14 +95,14 @@ namespace nvofapi {
         dxvk::log::info(
             dxvk::str::format("RegisterBuffer DX: resource: ",
                 registerParams->resource, " inputFencePoint: ",
-                registerParams->inputFencePoint.fence, " ouputFencePoint: ",
+                registerParams->inputFencePoint.fence, " outputFencePoint: ",
                 registerParams->outputFencePoint.fence));
         // Convert D3D12 params to VK params
         //
         // ID3D12Resource -> VK Image / VkFormat pair
         vkParams.hOFGpuBuffer = registerParams->hOFGpuBuffer;
         uint64_t offset;
-        m_device->GetVulkanResourceInfo1(registerParams->resource, (UINT64*)&vkParams.image, &offset, &vkParams.format);
+        m_device->GetVulkanResourceInfo1(registerParams->resource, reinterpret_cast<UINT64*>(&vkParams.image), &offset, &vkParams.format);
 
         // ID3D12 fence to timeline semaphore
         // no inputFencePoint/outputFencePoint equivalents for VK, leaving as
@@ -124,7 +111,7 @@ namespace nvofapi {
         assert(registerParams->inputFencePoint.value == 0);
         assert(registerParams->outputFencePoint.fence == nullptr);
         assert(registerParams->outputFencePoint.value == 0);
-        ((NvOFInstance*)this)->RegisterBuffer(&vkParams);
+        NvOFInstance::RegisterBuffer(&vkParams);
     }
 
     void NvOFInstanceD3D12::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams) {
diff --git a/src/d3d12/nvofapi_d3d12_instance.h b/src/d3d12/nvofapi_d3d12_instance.h
index aa7ca243..e8f933cc 100644
--- a/src/d3d12/nvofapi_d3d12_instance.h
+++ b/src/d3d12/nvofapi_d3d12_instance.h
@@ -27,20 +27,10 @@
 
 namespace nvofapi {
     class NvOFInstanceD3D12 : public NvOFInstance {
-      private:
-        ID3D12DXVKInteropDevice1* m_device{};
-        ID3D12DeviceExt* m_deviceExt{};
-        ID3D12Device4* m_d3ddevice{};
-        ID3D12CommandQueue* m_commandQueue{};
-        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
-        uint32_t m_cmdListIndex = 0;
-        ID3D12CommandAllocator* m_cmdAllocator{};
-
-        uint32_t m_vkQueueFamilyIndex = 0;
 
       public:
-        bool Initialize();
         NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
+
         virtual ~NvOFInstanceD3D12() {
             for (uint32_t i = 0; i < CMDS_IN_FLIGHT; i++) {
                 if (m_cmdList[i])
@@ -62,8 +52,21 @@ namespace nvofapi {
                 m_device->Release();
         }
 
+        void Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
+
+        bool Initialize();
+
         void RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
 
-        void Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
+      private:
+        ID3D12DXVKInteropDevice1* m_device{};
+        ID3D12DeviceExt* m_deviceExt{};
+        ID3D12Device4* m_d3ddevice{};
+        ID3D12CommandQueue* m_commandQueue{};
+        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
+        uint32_t m_cmdListIndex = 0;
+        ID3D12CommandAllocator* m_cmdAllocator{};
+
+        uint32_t m_vkQueueFamilyIndex = 0;
     };
 }
diff --git a/src/nvofapi.cpp b/src/nvofapi.cpp
index 6096c256..06be6182 100644
--- a/src/nvofapi.cpp
+++ b/src/nvofapi.cpp
@@ -39,7 +39,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(initParams));
 
-        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
 
         if (!nvOF) {
             return ErrorGeneric(n);
@@ -54,7 +54,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf));
 
-        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
         if (!nvOF) {
             return ErrorGeneric(n);
         }
@@ -78,7 +78,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), capsParam, log::fmt::ptr(capsVal), log::fmt::ptr(size));
 
-        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
 
         return nvOF->getCaps(capsParam, capsVal, size);
     }
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index c483aec7..989860b3 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -127,7 +127,7 @@ namespace nvofapi {
 
         createInfo.pNext = &privData;
 
-        auto ret = m_vkCreateOpticalFlowSessionNV(m_vkDevice, &createInfo, NULL, &m_vkOfaSession);
+        auto ret = m_vkCreateOpticalFlowSessionNV(m_vkDevice, &createInfo, nullptr, &m_vkOfaSession);
 
         if (ret == VK_SUCCESS) {
             return Success();
@@ -136,17 +136,17 @@ namespace nvofapi {
         return ErrorGeneric();
     }
 
-    NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFImage* image, VkOpticalFlowSessionBindingPointNV bindingPoint) {
-        VkImageLayout layout = VK_IMAGE_LAYOUT_GENERAL;
+    NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFGPUBufferHandle hBuffer, VkOpticalFlowSessionBindingPointNV bindingPoint) {
+        auto nvOFImage = reinterpret_cast<NvOFImage*>(hBuffer);
 
-        if (!image)
+        if (!nvOFImage)
             return ErrorGeneric();
 
         auto ret = m_vkBindOpticalFlowSessionImageNV(m_vkDevice,
             m_vkOfaSession,
             bindingPoint,
-            image->ImageView(),
-            layout);
+            nvOFImage->ImageView(),
+            VK_IMAGE_LAYOUT_GENERAL);
         if (ret != VK_SUCCESS) {
             return ErrorGeneric();
         }
@@ -167,26 +167,26 @@ namespace nvofapi {
     }
 
     void NvOFInstance::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
-        NvOFImage* nvOFImage = new NvOFImage(m_vkDevice, registerParams->image, registerParams->format);
+        auto nvOFImage = new NvOFImage(m_vkDevice, registerParams->image, registerParams->format);
         nvOFImage->Initialize(m_vkCreateImageView, m_vkDestroyImageView);
         *registerParams->hOFGpuBuffer = reinterpret_cast<NvOFGPUBufferHandle>(nvOFImage);
     }
 
     void NvOFInstance::RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf) {
-        BindImageToSession(reinterpret_cast<NvOFImage*>(inParams->inputFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
-        BindImageToSession(reinterpret_cast<NvOFImage*>(inParams->referenceFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
-        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->outputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
-        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->outputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV);
-        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->bwdOutputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV);
-        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->bwdOutputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
-        BindImageToSession(reinterpret_cast<NvOFImage*>(outParams->globalFlowBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
+        BindImageToSession(inParams->inputFrame, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+        BindImageToSession(inParams->referenceFrame, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+        BindImageToSession(outParams->outputBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
+        BindImageToSession(outParams->outputCostBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV);
+        BindImageToSession(outParams->bwdOutputBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV);
+        BindImageToSession(outParams->bwdOutputCostBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
+        BindImageToSession(outParams->globalFlowBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
         // Support INPUT_MIPS execute priv data
         if (((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
             NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS* mipData = ((NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS*)((NV_OF_PRIV_DATA*)inParams->hPrivData)->data);
             for (uint32_t i = 0; i < 6; i++) {
                 if (mipData->input[i] && mipData->reference[i]) {
-                    BindImageToSession(reinterpret_cast<NvOFImage*>(mipData->input[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
-                    BindImageToSession(reinterpret_cast<NvOFImage*>(mipData->reference[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+                    BindImageToSession(mipData->input[i], VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+                    BindImageToSession(mipData->reference[i], VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
                 }
             }
         }
diff --git a/src/nvofapi/nvofapi_image.cpp b/src/nvofapi/nvofapi_image.cpp
index 0786010a..14c1c0a3 100644
--- a/src/nvofapi/nvofapi_image.cpp
+++ b/src/nvofapi/nvofapi_image.cpp
@@ -37,7 +37,7 @@ namespace nvofapi {
         viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
         viewInfo.flags = 0;
 
-        auto ret = fpCreateImageView(m_vkDevice, &viewInfo, NULL, &m_imageView);
+        auto ret = fpCreateImageView(m_vkDevice, &viewInfo, nullptr, &m_imageView);
         if (ret != VK_SUCCESS) {
             return false;
         }
diff --git a/src/nvofapi/nvofapi_image.h b/src/nvofapi/nvofapi_image.h
index bc297aa7..e60ba307 100644
--- a/src/nvofapi/nvofapi_image.h
+++ b/src/nvofapi/nvofapi_image.h
@@ -25,22 +25,24 @@
 
 namespace nvofapi {
     class NvOFImage {
-      private:
-        VkDevice m_vkDevice;
-        VkImage m_image;
-        VkImageView m_imageView;
-        VkFormat m_format;
-        PFN_vkDestroyImageView m_vkDestroyImageView{};
-
       public:
-        VkImageView ImageView() { return m_imageView; }
         NvOFImage(VkDevice device, VkImage image, VkFormat format) : m_vkDevice(device), m_image(image), m_format(format) {
         }
+
         ~NvOFImage() {
             m_vkDestroyImageView(m_vkDevice, m_imageView, nullptr);
         }
 
+        VkImageView ImageView() { return m_imageView; }
+
         bool Initialize(PFN_vkCreateImageView CreateImageView,
             PFN_vkDestroyImageView DestroyImageView);
+
+      private:
+        VkDevice m_vkDevice{};
+        VkImage m_image{};
+        VkImageView m_imageView{};
+        VkFormat m_format{};
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
     };
 }
diff --git a/src/nvofapi/nvofapi_instance.h b/src/nvofapi/nvofapi_instance.h
index c06a6d86..0bbf3d7f 100644
--- a/src/nvofapi/nvofapi_instance.h
+++ b/src/nvofapi/nvofapi_instance.h
@@ -29,34 +29,9 @@
 
 namespace nvofapi {
     constexpr uint32_t CMDS_IN_FLIGHT = 8;
-    class NvOFInstance;
-    class NvOFImage;
 
     class NvOFInstance {
-
-      protected:
-        VkInstance m_vkInstance;
-        VkPhysicalDevice m_vkPhysicalDevice;
-        VkDevice m_vkDevice;
-        VkOpticalFlowSessionNV m_vkOfaSession{};
-        PFN_vkGetInstanceProcAddr m_vkGetInstanceProcAddr{};
-        PFN_vkGetDeviceProcAddr m_vkGetDeviceProcAddr{};
-        PFN_vkCreateOpticalFlowSessionNV m_vkCreateOpticalFlowSessionNV{};
-        PFN_vkDestroyOpticalFlowSessionNV m_vkDestroyOpticalFlowSessionNV{};
-        PFN_vkCreateImageView m_vkCreateImageView{};
-        PFN_vkDestroyImageView m_vkDestroyImageView{};
-        PFN_vkBindOpticalFlowSessionImageNV m_vkBindOpticalFlowSessionImageNV{};
-        PFN_vkCmdOpticalFlowExecuteNV m_vkCmdOpticalFlowExecuteNV{};
-
-        PFN_vkGetPhysicalDeviceQueueFamilyProperties m_vkGetPhysicalDeviceQueueFamilyProperties;
-        HMODULE m_library;
-
-        uint32_t GetVkOFAQueue();
-
       public:
-        VkDevice GetVkDevice() { return m_vkDevice; }
-        VkOpticalFlowSessionNV GetOfaSession() { return m_vkOfaSession; }
-
         NvOFInstance(VkInstance vkInstance,
             VkPhysicalDevice vkPhysicalDevice,
             VkDevice vkDevice) : m_vkInstance(vkInstance),
@@ -64,19 +39,42 @@ namespace nvofapi {
         }
 
         NvOFInstance() {};
+
         virtual ~NvOFInstance() {
             m_vkDestroyOpticalFlowSessionNV(m_vkDevice, m_vkOfaSession, nullptr);
             FreeLibrary(m_library);
         }
 
+        VkDevice GetVkDevice() { return m_vkDevice; }
+        VkOpticalFlowSessionNV GetOfaSession() { return m_vkOfaSession; }
+
         NV_OF_STATUS getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size);
 
         NV_OF_STATUS InitSession(const NV_OF_INIT_PARAMS* initParams);
 
         void RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
 
-        NV_OF_STATUS BindImageToSession(NvOFImage* image, VkOpticalFlowSessionBindingPointNV bindingPoint);
+        NV_OF_STATUS BindImageToSession(NvOFGPUBufferHandle hBuffer, VkOpticalFlowSessionBindingPointNV bindingPoint);
 
         void RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
+
+      protected:
+        VkInstance m_vkInstance;
+        VkPhysicalDevice m_vkPhysicalDevice;
+        VkDevice m_vkDevice;
+        VkOpticalFlowSessionNV m_vkOfaSession{};
+        PFN_vkGetInstanceProcAddr m_vkGetInstanceProcAddr{};
+        PFN_vkGetDeviceProcAddr m_vkGetDeviceProcAddr{};
+        PFN_vkCreateOpticalFlowSessionNV m_vkCreateOpticalFlowSessionNV{};
+        PFN_vkDestroyOpticalFlowSessionNV m_vkDestroyOpticalFlowSessionNV{};
+        PFN_vkCreateImageView m_vkCreateImageView{};
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+        PFN_vkBindOpticalFlowSessionImageNV m_vkBindOpticalFlowSessionImageNV{};
+        PFN_vkCmdOpticalFlowExecuteNV m_vkCmdOpticalFlowExecuteNV{};
+
+        PFN_vkGetPhysicalDeviceQueueFamilyProperties m_vkGetPhysicalDeviceQueueFamilyProperties;
+        HMODULE m_library;
+
+        uint32_t GetVkOFAQueue();
     };
 }
diff --git a/src/nvofapi_d3d12.cpp b/src/nvofapi_d3d12.cpp
index b095866a..1d5c6983 100644
--- a/src/nvofapi_d3d12.cpp
+++ b/src/nvofapi_d3d12.cpp
@@ -90,7 +90,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(registerParams));
 
-        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
 
         nvOF->RegisterBuffer(registerParams);
         return Success(n);
@@ -114,7 +114,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(executeInParams), log::fmt::ptr(executeOutParams));
 
-        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
 
         nvOF->Execute(executeInParams, executeOutParams);
         return Success(n, alreadyLoggedOk);
diff --git a/src/nvofapi_vulkan.cpp b/src/nvofapi_vulkan.cpp
index b5d4790a..8267a524 100644
--- a/src/nvofapi_vulkan.cpp
+++ b/src/nvofapi_vulkan.cpp
@@ -40,7 +40,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(vkInstance), log::fmt::hnd(vkPhysicalDevice), log::fmt::hnd(vkDevice), log::fmt::ptr(hOFInstance));
 
-        nvofapi::NvOFInstanceVk* nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
+        auto nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
 
         if (!nvOF) {
             return ErrorGeneric(n);
@@ -79,7 +79,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(registerParams));
 
-        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
         nvOF->RegisterBuffer(registerParams);
         return Success(n);
     }
@@ -102,7 +102,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(executeInParams), log::fmt::ptr(executeOutParams));
 
-        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
 
         nvOF->Execute(executeInParams, executeOutParams);
         return Success(n, alreadyLoggedOk);
diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index 90c04c41..640fbd14 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -69,7 +69,7 @@ namespace nvofapi {
         createInfo.queueFamilyIndex = GetVkOFAQueue();
         m_vkGetDeviceQueue(m_vkDevice, createInfo.queueFamilyIndex, 0, &m_queue);
 
-        if (m_vkCreateCommandPool(m_vkDevice, &createInfo, NULL, &m_commandPool)
+        if (m_vkCreateCommandPool(m_vkDevice, &createInfo, nullptr, &m_commandPool)
             != VK_SUCCESS) {
             return false;
         }
diff --git a/src/vulkan/nvofapi_vulkan_instance.h b/src/vulkan/nvofapi_vulkan_instance.h
index 59b27757..7fc02840 100644
--- a/src/vulkan/nvofapi_vulkan_instance.h
+++ b/src/vulkan/nvofapi_vulkan_instance.h
@@ -35,10 +35,11 @@ namespace nvofapi {
             m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, CMDS_IN_FLIGHT, m_commandBuffers);
             m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
         }
-        bool Initialize();
 
         void Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
 
+        bool Initialize();
+
       private:
         VkQueue m_queue;
         VkCommandPool m_commandPool;

From 2789cb5bbcad5b6cfa5c129eee7e44f1066c9e65 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 21:35:43 -0700
Subject: [PATCH] nvofapi_vulkan_instance: Create reset-able cmdbufs

---
 src/vulkan/nvofapi_vulkan_instance.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index 640fbd14..8f2fab05 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -67,6 +67,7 @@ namespace nvofapi {
         VkCommandPoolCreateInfo createInfo{};
         createInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
         createInfo.queueFamilyIndex = GetVkOFAQueue();
+        createInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
         m_vkGetDeviceQueue(m_vkDevice, createInfo.queueFamilyIndex, 0, &m_queue);
 
         if (m_vkCreateCommandPool(m_vkDevice, &createInfo, nullptr, &m_commandPool)

From ce91e29d0a2499df38f2e13a0124af6f9d5355e2 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 21:39:04 -0700
Subject: [PATCH] nvofapi: Check if hPrivData is set before usage

---
 src/nvofapi/nvofapi_common.cpp | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index 989860b3..8b6887be 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -120,12 +120,15 @@ namespace nvofapi {
 
         // Need to get the size/id for the private data to pass it along to VK...
         VkOpticalFlowSessionCreatePrivateDataInfoNV privData{};
-        privData.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
-        privData.size = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->size;
-        privData.id = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->id;
-        privData.pPrivateData = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->data;
 
-        createInfo.pNext = &privData;
+        if (initParams->hPrivData != nullptr) {
+            privData.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
+            privData.size = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->size;
+            privData.id = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->id;
+            privData.pPrivateData = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->data;
+
+            createInfo.pNext = &privData;
+        }
 
         auto ret = m_vkCreateOpticalFlowSessionNV(m_vkDevice, &createInfo, nullptr, &m_vkOfaSession);
 
@@ -181,7 +184,7 @@ namespace nvofapi {
         BindImageToSession(outParams->bwdOutputCostBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
         BindImageToSession(outParams->globalFlowBuffer, VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
         // Support INPUT_MIPS execute priv data
-        if (((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
+        if (inParams->hPrivData != nullptr && ((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
             NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS* mipData = ((NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS*)((NV_OF_PRIV_DATA*)inParams->hPrivData)->data);
             for (uint32_t i = 0; i < 6; i++) {
                 if (mipData->input[i] && mipData->reference[i]) {

From ced97fac5f507c47abdf28b3022484ff59c9abfb Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 21:47:04 -0700
Subject: [PATCH] nvofapi: Use std::vector rather than callocing arrays

---
 src/nvofapi/nvofapi_common.cpp         | 26 +++++++++-----------------
 src/vulkan/nvofapi_vulkan_instance.cpp | 22 ++++++++--------------
 2 files changed, 17 insertions(+), 31 deletions(-)

diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index 8b6887be..0b6253ae 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -50,16 +50,14 @@ namespace nvofapi {
     uint32_t NvOFInstance::GetVkOFAQueue() {
         uint32_t count = 0;
         m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, nullptr);
-        VkQueueFamilyProperties* queueFamProps = (VkQueueFamilyProperties*)calloc(sizeof(VkQueueFamilyProperties), count);
-        m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, queueFamProps);
+        auto queueFamProps = std::vector<VkQueueFamilyProperties>(count);
+        m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, queueFamProps.data());
 
         for (uint32_t i = 0; i < count; i++) {
             if (queueFamProps[i].queueFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
-                free(queueFamProps);
                 return i;
             }
         }
-        free(queueFamProps);
         return -1;
     }
 
@@ -193,29 +191,23 @@ namespace nvofapi {
                 }
             }
         }
-        VkRect2D* regions = nullptr;
-
-        if (inParams->numRois) {
-            regions = (VkRect2D*)calloc(sizeof(VkRect2D), inParams->numRois);
-            for (uint32_t i = 0; i < inParams->numRois; i++) {
-                regions[i].offset.x = inParams->roiData[i].start_x;
-                regions[i].offset.y = inParams->roiData[i].start_y;
-                regions[i].extent.width = inParams->roiData[i].width;
-                regions[i].extent.height = inParams->roiData[i].height;
-            }
+        auto regions = std::vector<VkRect2D>(inParams->numRois);
+        for (uint32_t i = 0; i < inParams->numRois; i++) {
+            regions[i].offset.x = inParams->roiData[i].start_x;
+            regions[i].offset.y = inParams->roiData[i].start_y;
+            regions[i].extent.width = inParams->roiData[i].width;
+            regions[i].extent.height = inParams->roiData[i].height;
         }
 
         VkOpticalFlowExecuteInfoNV ofaExecuteInfo{};
         ofaExecuteInfo.sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV;
         ofaExecuteInfo.regionCount = inParams->numRois;
-        ofaExecuteInfo.pRegions = regions;
+        ofaExecuteInfo.pRegions = regions.data();
 
         if (inParams->disableTemporalHints) {
             ofaExecuteInfo.flags |= VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
         }
 
         m_vkCmdOpticalFlowExecuteNV(cmdBuf, m_vkOfaSession, &ofaExecuteInfo);
-
-        free(regions);
     }
 }
diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index 8f2fab05..d7c0487e 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -102,16 +102,12 @@ namespace nvofapi {
                 " numWaitSync: ", inParams->numWaitSyncs,
                 " pWaitSyncs: ", inParams->pWaitSyncs));
 
-        VkSemaphoreSubmitInfo* waitSyncs = nullptr;
-
-        if (inParams->numWaitSyncs) {
-            waitSyncs = (VkSemaphoreSubmitInfo*)calloc(sizeof(VkSemaphoreSubmitInfo), inParams->numWaitSyncs);
-            for (uint32_t i = 0; i < inParams->numWaitSyncs; i++) {
-                waitSyncs[i].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
-                waitSyncs[i].semaphore = inParams->pWaitSyncs[i].semaphore;
-                waitSyncs[i].value = inParams->pWaitSyncs[i].value;
-                waitSyncs[i].stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
-            }
+        auto waitSyncs = std::vector<VkSemaphoreSubmitInfo>(inParams->numWaitSyncs);
+        for (uint32_t i = 0; i < inParams->numWaitSyncs; i++) {
+            waitSyncs[i].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
+            waitSyncs[i].semaphore = inParams->pWaitSyncs[i].semaphore;
+            waitSyncs[i].value = inParams->pWaitSyncs[i].value;
+            waitSyncs[i].stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
         }
 
         VkSemaphoreSubmitInfo signalSync{};
@@ -138,8 +134,8 @@ namespace nvofapi {
 
         VkSubmitInfo2 submit{};
         submit.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2;
-        submit.waitSemaphoreInfoCount = inParams->numWaitSyncs;
-        submit.pWaitSemaphoreInfos = waitSyncs;
+        submit.waitSemaphoreInfoCount = waitSyncs.size();
+        submit.pWaitSemaphoreInfos = waitSyncs.data();
         submit.commandBufferInfoCount = 1;
         submit.pCommandBufferInfos = &cmdbufInfo;
         submit.signalSemaphoreInfoCount = (outParams->pSignalSync) ? 1 : 0;
@@ -147,8 +143,6 @@ namespace nvofapi {
 
         m_vkQueueSubmit2(m_queue, 1, &submit, VK_NULL_HANDLE);
 
-        free(waitSyncs);
-
         m_cmdBufIndex++;
         if (m_cmdBufIndex >= CMDS_IN_FLIGHT)
             m_cmdBufIndex = 0;

From 5ab53d12d975fee7b7674667a4dd23c62be9d06d Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 22:09:40 -0700
Subject: [PATCH] nvofapi: Fix initalization failure error handling

---
 src/nvofapi_d3d12.cpp  | 3 ---
 src/nvofapi_vulkan.cpp | 8 +++++---
 2 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/src/nvofapi_d3d12.cpp b/src/nvofapi_d3d12.cpp
index 1d5c6983..8c6db9dc 100644
--- a/src/nvofapi_d3d12.cpp
+++ b/src/nvofapi_d3d12.cpp
@@ -46,9 +46,6 @@ extern "C" {
             nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
         } catch (std::exception const& e) {
             log::info(str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
-        }
-
-        if (!nvOF) {
             return ErrorGeneric(n);
         }
 
diff --git a/src/nvofapi_vulkan.cpp b/src/nvofapi_vulkan.cpp
index 8267a524..92733e8d 100644
--- a/src/nvofapi_vulkan.cpp
+++ b/src/nvofapi_vulkan.cpp
@@ -40,9 +40,11 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(vkInstance), log::fmt::hnd(vkPhysicalDevice), log::fmt::hnd(vkDevice), log::fmt::ptr(hOFInstance));
 
-        auto nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
-
-        if (!nvOF) {
+        nvofapi::NvOFInstanceVk* nvOF = nullptr;
+        try {
+            nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
+        } catch (std::exception const& e) {
+            log::info(str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
             return ErrorGeneric(n);
         }
 

From 5dfb3aa51e96b203782d07e3c927d535e4a1d070 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 22:12:56 -0700
Subject: [PATCH] nvofapi: Use std::array instead of C-arrays for cmdbufs

---
 src/d3d12/nvofapi_d3d12_instance.cpp   | 12 ++++++------
 src/d3d12/nvofapi_d3d12_instance.h     |  8 ++++----
 src/vulkan/nvofapi_vulkan_instance.cpp |  2 +-
 src/vulkan/nvofapi_vulkan_instance.h   |  4 ++--
 4 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/src/d3d12/nvofapi_d3d12_instance.cpp b/src/d3d12/nvofapi_d3d12_instance.cpp
index 3bb4ed31..09d8b748 100644
--- a/src/d3d12/nvofapi_d3d12_instance.cpp
+++ b/src/d3d12/nvofapi_d3d12_instance.cpp
@@ -84,7 +84,7 @@ namespace nvofapi {
             return false;
 
         for (uint32_t i = 0; i < CMDS_IN_FLIGHT; i++) {
-            if (FAILED(m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdList[i]))))
+            if (FAILED(m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdLists[i]))))
                 return false;
         }
         return true;
@@ -137,21 +137,21 @@ namespace nvofapi {
         // Use vkd3d-proton's interop functionality to grab a VkCommandBuffer
         // that we record our commands into. Work submission and syncrhonization
         // happens using D3D12.
-        m_cmdList[m_cmdListIndex]->Reset(m_cmdAllocator, nullptr);
+        m_cmdLists[m_cmdListIndex]->Reset(m_cmdAllocator, nullptr);
 
         for (uint32_t i = 0; i < inParams->numFencePoints; i++) {
             m_commandQueue->Wait(inParams->fencePoint[i].fence, inParams->fencePoint[i].value);
         }
 
         VkCommandBuffer vkCmdBuf;
-        m_device->BeginVkCommandBufferInterop(m_cmdList[m_cmdListIndex], &vkCmdBuf);
+        m_device->BeginVkCommandBufferInterop(m_cmdLists[m_cmdListIndex], &vkCmdBuf);
 
         this->RecordCmdBuf(&vkInputParams, &vkOutputParams, vkCmdBuf);
 
-        m_device->EndVkCommandBufferInterop(m_cmdList[m_cmdListIndex]);
-        m_cmdList[m_cmdListIndex]->Close();
+        m_device->EndVkCommandBufferInterop(m_cmdLists[m_cmdListIndex]);
+        m_cmdLists[m_cmdListIndex]->Close();
 
-        m_commandQueue->ExecuteCommandLists(1, (ID3D12CommandList**)&m_cmdList[m_cmdListIndex]);
+        m_commandQueue->ExecuteCommandLists(1, (ID3D12CommandList**)&m_cmdLists[m_cmdListIndex]);
 
         m_commandQueue->Signal(outParams->fencePoint->fence, outParams->fencePoint->value);
 
diff --git a/src/d3d12/nvofapi_d3d12_instance.h b/src/d3d12/nvofapi_d3d12_instance.h
index e8f933cc..03324f2f 100644
--- a/src/d3d12/nvofapi_d3d12_instance.h
+++ b/src/d3d12/nvofapi_d3d12_instance.h
@@ -32,9 +32,9 @@ namespace nvofapi {
         NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
 
         virtual ~NvOFInstanceD3D12() {
-            for (uint32_t i = 0; i < CMDS_IN_FLIGHT; i++) {
-                if (m_cmdList[i])
-                    m_cmdList[i]->Release();
+            for (auto& cmdList : m_cmdLists) {
+                if (cmdList)
+                    cmdList->Release();
             }
             if (m_cmdAllocator)
                 m_cmdAllocator->Release();
@@ -63,7 +63,7 @@ namespace nvofapi {
         ID3D12DeviceExt* m_deviceExt{};
         ID3D12Device4* m_d3ddevice{};
         ID3D12CommandQueue* m_commandQueue{};
-        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
+        std::array<ID3D12GraphicsCommandList*, CMDS_IN_FLIGHT> m_cmdLists;
         uint32_t m_cmdListIndex = 0;
         ID3D12CommandAllocator* m_cmdAllocator{};
 
diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index d7c0487e..3f113480 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -81,7 +81,7 @@ namespace nvofapi {
         allocInfo.commandPool = m_commandPool;
         allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
         allocInfo.commandBufferCount = CMDS_IN_FLIGHT; // more than enough for anybody ;)
-        if (m_vkAllocateCommandBuffers(m_vkDevice, &allocInfo, m_commandBuffers)
+        if (m_vkAllocateCommandBuffers(m_vkDevice, &allocInfo, m_commandBuffers.data())
             != VK_SUCCESS) {
             return false;
         }
diff --git a/src/vulkan/nvofapi_vulkan_instance.h b/src/vulkan/nvofapi_vulkan_instance.h
index 7fc02840..49c612a3 100644
--- a/src/vulkan/nvofapi_vulkan_instance.h
+++ b/src/vulkan/nvofapi_vulkan_instance.h
@@ -32,7 +32,7 @@ namespace nvofapi {
         }
         virtual ~NvOFInstanceVk() {
             // free cmdbuffers
-            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, CMDS_IN_FLIGHT, m_commandBuffers);
+            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, CMDS_IN_FLIGHT, m_commandBuffers.data());
             m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
         }
 
@@ -45,7 +45,7 @@ namespace nvofapi {
         VkCommandPool m_commandPool;
         PFN_vkCreateCommandPool m_vkCreateCommandPool;
         PFN_vkDestroyCommandPool m_vkDestroyCommandPool;
-        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT];
+        std::array<VkCommandBuffer, CMDS_IN_FLIGHT> m_commandBuffers;
 
         PFN_vkAllocateCommandBuffers m_vkAllocateCommandBuffers;
         PFN_vkFreeCommandBuffers m_vkFreeCommandBuffers;

From e2233ff9459ea1b7e28a11dbe3d30a6b62e4946f Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 22:32:50 -0700
Subject: [PATCH] nvofapi: Migrate to dxvk namespace

---
 src/d3d12/nvofapi_d3d12_instance.cpp   |  8 ++++----
 src/d3d12/nvofapi_d3d12_instance.h     |  2 +-
 src/nvofapi.cpp                        |  6 +++---
 src/nvofapi/nvofapi_common.cpp         |  3 +--
 src/nvofapi/nvofapi_image.cpp          |  2 +-
 src/nvofapi/nvofapi_image.h            |  2 +-
 src/nvofapi/nvofapi_instance.h         |  2 +-
 src/nvofapi_d3d12.cpp                  | 10 +++++-----
 src/nvofapi_vulkan.cpp                 | 10 +++++-----
 src/vulkan/nvofapi_vulkan_instance.cpp |  6 +++---
 src/vulkan/nvofapi_vulkan_instance.h   |  2 +-
 11 files changed, 26 insertions(+), 27 deletions(-)

diff --git a/src/d3d12/nvofapi_d3d12_instance.cpp b/src/d3d12/nvofapi_d3d12_instance.cpp
index 09d8b748..07af5983 100644
--- a/src/d3d12/nvofapi_d3d12_instance.cpp
+++ b/src/d3d12/nvofapi_d3d12_instance.cpp
@@ -28,7 +28,7 @@
 
 #include "d3d12/nvofapi_d3d12_instance.h"
 
-namespace nvofapi {
+namespace dxvk {
 
     NvOFInstanceD3D12::NvOFInstanceD3D12(ID3D12Device* pD3D12Device) {
         // Query for the extension interface
@@ -55,7 +55,7 @@ namespace nvofapi {
 
         // Confirm that OPTICAL_FLOW extension is available
         if (!m_deviceExt->GetExtensionSupport(D3D12_VK_NV_OPTICAL_FLOW)) {
-            dxvk::log::info("Missing VK_NV_optical_flow extension!");
+            log::info("Missing VK_NV_optical_flow extension!");
             return false;
         }
 
@@ -92,8 +92,8 @@ namespace nvofapi {
 
     void NvOFInstanceD3D12::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
         NV_OF_REGISTER_RESOURCE_PARAMS_VK vkParams{};
-        dxvk::log::info(
-            dxvk::str::format("RegisterBuffer DX: resource: ",
+        log::info(
+            str::format("RegisterBuffer DX: resource: ",
                 registerParams->resource, " inputFencePoint: ",
                 registerParams->inputFencePoint.fence, " outputFencePoint: ",
                 registerParams->outputFencePoint.fence));
diff --git a/src/d3d12/nvofapi_d3d12_instance.h b/src/d3d12/nvofapi_d3d12_instance.h
index 03324f2f..bfbbda33 100644
--- a/src/d3d12/nvofapi_d3d12_instance.h
+++ b/src/d3d12/nvofapi_d3d12_instance.h
@@ -25,7 +25,7 @@
 
 #include "nvofapi/nvofapi_instance.h"
 
-namespace nvofapi {
+namespace dxvk {
     class NvOFInstanceD3D12 : public NvOFInstance {
 
       public:
diff --git a/src/nvofapi.cpp b/src/nvofapi.cpp
index 06be6182..7bc2cd53 100644
--- a/src/nvofapi.cpp
+++ b/src/nvofapi.cpp
@@ -39,7 +39,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(initParams));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstance*>(hOf);
 
         if (!nvOF) {
             return ErrorGeneric(n);
@@ -54,7 +54,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstance*>(hOf);
         if (!nvOF) {
             return ErrorGeneric(n);
         }
@@ -78,7 +78,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), capsParam, log::fmt::ptr(capsVal), log::fmt::ptr(size));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstance*>(hOf);
 
         return nvOF->getCaps(capsParam, capsVal, size);
     }
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
index 0b6253ae..821131fa 100644
--- a/src/nvofapi/nvofapi_common.cpp
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -30,8 +30,7 @@
 #include "nvofapi_image.h"
 #include "nvofapi_instance.h"
 
-using namespace dxvk;
-namespace nvofapi {
+namespace dxvk {
 
     typedef struct NV_OF_PRIV_DATA {
         uint32_t size;
diff --git a/src/nvofapi/nvofapi_image.cpp b/src/nvofapi/nvofapi_image.cpp
index 14c1c0a3..56b10a32 100644
--- a/src/nvofapi/nvofapi_image.cpp
+++ b/src/nvofapi/nvofapi_image.cpp
@@ -23,7 +23,7 @@
 
 #include "nvofapi_image.h"
 
-namespace nvofapi {
+namespace dxvk {
     bool NvOFImage::Initialize(PFN_vkCreateImageView fpCreateImageView,
         PFN_vkDestroyImageView fpDestroyImageView) {
         m_vkDestroyImageView = fpDestroyImageView;
diff --git a/src/nvofapi/nvofapi_image.h b/src/nvofapi/nvofapi_image.h
index e60ba307..99799f54 100644
--- a/src/nvofapi/nvofapi_image.h
+++ b/src/nvofapi/nvofapi_image.h
@@ -23,7 +23,7 @@
 
 #include <vulkan/vulkan_core.h>
 
-namespace nvofapi {
+namespace dxvk {
     class NvOFImage {
       public:
         NvOFImage(VkDevice device, VkImage image, VkFormat format) : m_vkDevice(device), m_image(image), m_format(format) {
diff --git a/src/nvofapi/nvofapi_instance.h b/src/nvofapi/nvofapi_instance.h
index 0bbf3d7f..0382b1d4 100644
--- a/src/nvofapi/nvofapi_instance.h
+++ b/src/nvofapi/nvofapi_instance.h
@@ -27,7 +27,7 @@
 #include "../inc/nvofapi/nvOpticalFlowD3D12.h"
 #include "../inc/nvofapi/nvOpticalFlowVulkan.h"
 
-namespace nvofapi {
+namespace dxvk {
     constexpr uint32_t CMDS_IN_FLIGHT = 8;
 
     class NvOFInstance {
diff --git a/src/nvofapi_d3d12.cpp b/src/nvofapi_d3d12.cpp
index 8c6db9dc..40f4189a 100644
--- a/src/nvofapi_d3d12.cpp
+++ b/src/nvofapi_d3d12.cpp
@@ -41,9 +41,9 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::ptr(pD3D12Device), log::fmt::ptr(hOFInstance));
 
-        nvofapi::NvOFInstanceD3D12* nvOF = nullptr;
+        NvOFInstanceD3D12* nvOF = nullptr;
         try {
-            nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
+            nvOF = new NvOFInstanceD3D12(pD3D12Device);
         } catch (std::exception const& e) {
             log::info(str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
             return ErrorGeneric(n);
@@ -87,7 +87,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(registerParams));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstanceD3D12*>(hOf);
 
         nvOF->RegisterBuffer(registerParams);
         return Success(n);
@@ -99,7 +99,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::ptr(registerParams));
 
-        nvofapi::NvOFImage* nvRes = reinterpret_cast<nvofapi::NvOFImage*>(registerParams->hOFGpuBuffer);
+        NvOFImage* nvRes = reinterpret_cast<NvOFImage*>(registerParams->hOFGpuBuffer);
         delete nvRes;
         return Success(n);
     }
@@ -111,7 +111,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(executeInParams), log::fmt::ptr(executeOutParams));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstanceD3D12*>(hOf);
 
         nvOF->Execute(executeInParams, executeOutParams);
         return Success(n, alreadyLoggedOk);
diff --git a/src/nvofapi_vulkan.cpp b/src/nvofapi_vulkan.cpp
index 92733e8d..853bd75f 100644
--- a/src/nvofapi_vulkan.cpp
+++ b/src/nvofapi_vulkan.cpp
@@ -40,9 +40,9 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(vkInstance), log::fmt::hnd(vkPhysicalDevice), log::fmt::hnd(vkDevice), log::fmt::ptr(hOFInstance));
 
-        nvofapi::NvOFInstanceVk* nvOF = nullptr;
+        NvOFInstanceVk* nvOF = nullptr;
         try {
-            nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
+            nvOF = new NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
         } catch (std::exception const& e) {
             log::info(str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
             return ErrorGeneric(n);
@@ -81,7 +81,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(registerParams));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstanceVk*>(hOf);
         nvOF->RegisterBuffer(registerParams);
         return Success(n);
     }
@@ -92,7 +92,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::ptr(registerParams));
 
-        nvofapi::NvOFImage* nvRes = reinterpret_cast<nvofapi::NvOFImage*>(registerParams->hOFGpuBuffer);
+        NvOFImage* nvRes = reinterpret_cast<NvOFImage*>(registerParams->hOFGpuBuffer);
         delete nvRes;
         return ErrorGeneric(n);
     }
@@ -104,7 +104,7 @@ extern "C" {
         if (log::tracing())
             log::trace(n, log::fmt::hnd(hOf), log::fmt::ptr(executeInParams), log::fmt::ptr(executeOutParams));
 
-        auto nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        auto nvOF = reinterpret_cast<NvOFInstanceVk*>(hOf);
 
         nvOF->Execute(executeInParams, executeOutParams);
         return Success(n, alreadyLoggedOk);
diff --git a/src/vulkan/nvofapi_vulkan_instance.cpp b/src/vulkan/nvofapi_vulkan_instance.cpp
index 3f113480..ec7e47ec 100644
--- a/src/vulkan/nvofapi_vulkan_instance.cpp
+++ b/src/vulkan/nvofapi_vulkan_instance.cpp
@@ -28,7 +28,7 @@
 
 #include "vulkan/nvofapi_vulkan_instance.h"
 
-namespace nvofapi {
+namespace dxvk {
 
     bool NvOFInstanceVk::Initialize() {
         // For VK we cannot load winevulkan directly or we may break handle
@@ -90,8 +90,8 @@ namespace nvofapi {
     }
 
     void NvOFInstanceVk::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams) {
-        dxvk::log::info(
-            dxvk::str::format("OFExecuteVK params:",
+        log::info(
+            str::format("OFExecuteVK params:",
                 " inputFrame: ", inParams->inputFrame,
                 " referenceFrame: ", inParams->referenceFrame,
                 " externalHints: ", inParams->externalHints,
diff --git a/src/vulkan/nvofapi_vulkan_instance.h b/src/vulkan/nvofapi_vulkan_instance.h
index 49c612a3..699d9ebc 100644
--- a/src/vulkan/nvofapi_vulkan_instance.h
+++ b/src/vulkan/nvofapi_vulkan_instance.h
@@ -25,7 +25,7 @@
 
 #include "nvofapi/nvofapi_instance.h"
 
-namespace nvofapi {
+namespace dxvk {
     class NvOFInstanceVk : public NvOFInstance {
       public:
         NvOFInstanceVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice) : NvOFInstance(vkInstance, vkPhysicalDevice, vkDevice) {

From 520a49c80f1e8468089e5070732f6dd752f85b4f Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Wed, 30 Oct 2024 22:37:34 -0700
Subject: [PATCH] nvofapi: Disable 32-bit builds

---
 src/meson.build | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/meson.build b/src/meson.build
index 204376aa..d2644e97 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -45,8 +45,11 @@ nvofapi_src = files([
   'nvofapi/nvofapi_image.cpp',
 ])
 
-nvofapi_dll = shared_library('nvofapi'+target_suffix, [ nvofapi_src, dxvk_nvapi_version ],
-  name_prefix         : '',
-  dependencies        : [ lib_version ],
-  include_directories : [ nvapi_headers, vk_headers ],
-  install             : true)
+# Only build 64-bit versions of nvofapi
+if dxvk_cpu_family == 'x86_64'
+  nvofapi_dll = shared_library('nvofapi'+target_suffix, [ nvofapi_src, dxvk_nvapi_version ],
+    name_prefix         : '',
+    dependencies        : [ lib_version ],
+    include_directories : [ nvapi_headers, vk_headers ],
+    install             : true)
+endif
