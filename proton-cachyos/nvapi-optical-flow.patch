From d42bae60d3ed6d8edbc07bb5d09d3158c38eb572 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Sat, 12 Oct 2024 16:55:48 -0700
Subject: [PATCH] inc: Import nvofapi headers

Signed-off-by: Liam Middlebrook <lmiddlebrook@nvidia.com>
---
 inc/nvofapi/nvOpticalFlowCommon.h | 583 ++++++++++++++++++++++++++++++
 inc/nvofapi/nvOpticalFlowCuda.h   | 236 ++++++++++++
 inc/nvofapi/nvOpticalFlowD3D11.h  | 193 ++++++++++
 inc/nvofapi/nvOpticalFlowD3D12.h  | 308 ++++++++++++++++
 inc/nvofapi/nvOpticalFlowVulkan.h | 312 ++++++++++++++++
 5 files changed, 1632 insertions(+)
 create mode 100644 inc/nvofapi/nvOpticalFlowCommon.h
 create mode 100644 inc/nvofapi/nvOpticalFlowCuda.h
 create mode 100644 inc/nvofapi/nvOpticalFlowD3D11.h
 create mode 100644 inc/nvofapi/nvOpticalFlowD3D12.h
 create mode 100644 inc/nvofapi/nvOpticalFlowVulkan.h

diff --git a/inc/nvofapi/nvOpticalFlowCommon.h b/inc/nvofapi/nvOpticalFlowCommon.h
new file mode 100644
index 00000000..1023cae8
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowCommon.h
@@ -0,0 +1,583 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowCommon.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowCommon.h provides enums, structure definitions and function prototypes which are common across different devices.
+*   nvOpticalFlowCommon.h uses #pragma directives to pack structure members with one byte alignment.
+*/
+
+#ifndef _NV_OPTICALFLOW_COMMON_H_
+#define _NV_OPTICALFLOW_COMMON_H_
+#if defined(_MSC_VER_) && (_MSC_VER_ < 1600)
+#ifndef _STDINT
+typedef __int32             int32_t;
+typedef unsigned __int32    uint32_t;
+typedef __int64             int64_t;
+typedef unsigned __int64    uint64_t;
+typedef signed char         int8_t;
+typedef unsigned char       uint8_t;
+typedef short               int16_t;
+typedef unsigned short      uint16_t;
+#endif
+#else
+#include <stdint.h>
+#endif
+
+#ifdef _WIN32
+#define NVOFAPI __stdcall
+#else
+#define NVOFAPI
+#endif
+#define NV_OF_API_MAJOR_VERSION 5
+#define NV_OF_API_MINOR_VERSION 0
+#define NV_OF_API_VERSION  (uint16_t)((NV_OF_API_MAJOR_VERSION << 4) | NV_OF_API_MINOR_VERSION)
+#define MIN_ERROR_STRING_SIZE 80
+
+#if defined(__cplusplus)
+extern "C" 
+{
+#endif /* __cplusplus */
+
+typedef struct NvOFHandle_st            *NvOFHandle;
+typedef struct NvOFGPUBufferHandle_st   *NvOFGPUBufferHandle;
+typedef struct NVOFPrivDataHandle_st    *NvOFPrivDataHandle;
+
+/**
+  *  Supported error codes
+*/
+typedef enum _NV_OF_STATUS
+{
+    /**
+    * This indicates that API call returned with no errors.
+    */
+    NV_OF_SUCCESS,
+
+    /**
+    * This indicates that HW Optical flow functionality is not supported
+    */
+    NV_OF_ERR_OF_NOT_AVAILABLE,
+
+    /**
+    * This indicates that device passed by the client is not supported.
+    */
+    NV_OF_ERR_UNSUPPORTED_DEVICE,
+
+    /**
+    * This indicates that device passed to the API call is no longer available and
+    * needs to be reinitialized.
+    */
+    NV_OF_ERR_DEVICE_DOES_NOT_EXIST,
+
+    /**
+    * This indicates that one or more of the pointers passed to the API call
+    * is invalid.
+    */
+    NV_OF_ERR_INVALID_PTR,
+
+    /**
+    * This indicates that one or more of the parameter passed to the API call
+    * is invalid.
+    */
+    NV_OF_ERR_INVALID_PARAM,
+
+    /**
+    * This indicates that an API call was made in wrong sequence/order.
+    */
+    NV_OF_ERR_INVALID_CALL,
+
+    /**
+    * This indicates that an invalid struct version was used by the client.
+    */
+    NV_OF_ERR_INVALID_VERSION,
+
+    /**
+    * This indicates that the API call failed because it was unable to allocate
+    * enough memory to perform the requested operation.
+    */
+    NV_OF_ERR_OUT_OF_MEMORY,
+
+    /**
+    * This indicates that the OF session has not been initialized with
+    * ::NvOFInit() or that initialization has failed.
+    */
+    NV_OF_ERR_NOT_INITIALIZED,
+
+    /**
+    * This indicates that an unsupported parameter was passed by the client.
+    */
+    NV_OF_ERR_UNSUPPORTED_FEATURE,
+
+    /**
+    * This indicates that an unknown internal error has occurred.
+    */
+   NV_OF_ERR_GENERIC,
+} NV_OF_STATUS;
+
+/**
+*  Supported bool values
+*/
+typedef enum _NV_OF_BOOL
+{
+    NV_OF_FALSE = 0,                              /* < Represents false bool value */
+    NV_OF_TRUE  = !NV_OF_FALSE                    /* < Represents true bool value */
+} NV_OF_BOOL;
+
+/**
+* Supported optical flow and stereo disparity capability values.
+*/
+typedef enum _NV_OF_CAPS
+{
+    NV_OF_CAPS_SUPPORTED_OUTPUT_GRID_SIZES,      /**< Indicates supported values of ::NV_OF_OUTPUT_VECTOR_GRID_SIZE, 
+                                                    ::NV_OF_INIT_PARAMS::outGridSize should be set with a supported output gridsize. */
+    NV_OF_CAPS_SUPPORTED_HINT_GRID_SIZES,        /**< Indicates supported values of ::NV_OF_HINT_VECTOR_GRID_SIZE, 
+                                                    ::NV_OF_INIT_PARAMS::hintGridSize should be set with a supported hint gridsize. */
+    NV_OF_CAPS_SUPPORT_HINT_WITH_OF_MODE,        /**< Indicates external hint support for ::NV_OF_MODE_OPTICALFLOW mode. 
+                                                    0: External hint not supported for ::NV_OF_MODE_OPTICALFLOW mode.
+                                                    1: External hint is supported for ::NV_OF_MODE_OPTICALFLOW mode. */ 
+    NV_OF_CAPS_SUPPORT_HINT_WITH_ST_MODE,        /**< Indicates external hint support for ::NV_OF_MODE_STEREODISPARITY mode. 
+                                                    0: External hint not supported for ::NV_OF_MODE_STEREODISPARITY mode.
+                                                    1: External hint is supported for ::NV_OF_MODE_STEREODISPARITY mode. */ 
+    NV_OF_CAPS_WIDTH_MIN,                        /**< Minimum input width supported. */
+    NV_OF_CAPS_HEIGHT_MIN,                       /**< Minimum input height supported. */
+    NV_OF_CAPS_WIDTH_MAX,                        /**< Maximum input width supported. */
+    NV_OF_CAPS_HEIGHT_MAX,                       /**< Maximum input height supported. */
+    NV_OF_CAPS_SUPPORT_ROI,                      /**< Indicates ROI support.
+                                                    0: ROIs cannot be specified.
+                                                    1: One or more ROIs can be specified. */
+    NV_OF_CAPS_SUPPORT_ROI_MAX_NUM,              /**< Indicates maximum number of ROIs supported. */
+    NV_OF_CAPS_SUPPORT_MAX
+} NV_OF_CAPS;
+
+/**
+* Supported optical flow/stereo disparity performance levels.
+* Stereo disparity will be deprecated from next SDK release. Instead, use x component of Optical Flow.
+*/
+typedef enum _NV_OF_PERF_LEVEL
+{
+    NV_OF_PERF_LEVEL_UNDEFINED,
+    NV_OF_PERF_LEVEL_SLOW = 5,                   /**< Slow perf level results in lowest performance and best quality */
+    NV_OF_PERF_LEVEL_MEDIUM = 10,                /**< Medium perf level results in low performance and medium quality */
+    NV_OF_PERF_LEVEL_FAST = 20,                  /**< Fast perf level results in high performance and low quality */
+    NV_OF_PERF_LEVEL_MAX
+} NV_OF_PERF_LEVEL;
+
+/**
+* Supported grid size for output buffer ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer.
+* Client should set ::NV_OF_INIT_PARAMS::outGridSize with ::NV_OF_OUTPUT_VECTOR_GRID_SIZE values.
+*/
+typedef enum _NV_OF_OUTPUT_VECTOR_GRID_SIZE
+{
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_UNDEFINED,
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_1 = 1,          /**< Output buffer grid size is 1x1  */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_2 = 2,          /**< Output buffer grid size is 2x2  */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_4 = 4,          /**< Output buffer grid size is 4x4  */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE_MAX
+} NV_OF_OUTPUT_VECTOR_GRID_SIZE;
+
+/**
+* Expected grid size for optional paramater ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints buffer.
+* Client should set ::NV_OF_INIT_PARAMS::hintGridSize with ::NV_OF_HINT_VECTOR_GRID_SIZE values.
+*/
+typedef enum _NV_OF_HINT_VECTOR_GRID_SIZE
+{
+    NV_OF_HINT_VECTOR_GRID_SIZE_UNDEFINED,
+    NV_OF_HINT_VECTOR_GRID_SIZE_1 = 1,            /**< Hint buffer grid size is 1x1.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_2 = 2,            /**< Hint buffer grid size is 2x2.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_4 = 4,            /**< Hint buffer grid size is 4x4.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_8 = 8,            /**< Hint buffer grid size is 8x8.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE_MAX
+} NV_OF_HINT_VECTOR_GRID_SIZE;
+
+/**
+* ::NV_OF_MODE enum define values for Optical flow and Stereo disparity modes.
+* Client need to set ::NV_OF_INIT_PARAMS::mode with ::NV_OF_MODE values.
+* For the ::NV_OF_MODE_OPTICALFLOW mode, the buffer format for ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints,
+* ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer and ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer is ::NV_OF_FLOW_VECTOR.
+* For the ::NV_OF_MODE_STEREODISPARITY mode, the buffer format for ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints,
+* ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer and ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer is ::NV_OF_STEREO_DISPARITY.
+*/
+typedef enum _NV_OF_MODE
+{
+    NV_OF_MODE_UNDEFINED,
+    NV_OF_MODE_OPTICALFLOW,                       /**< Calculate optical flow between two frames. */
+    NV_OF_MODE_STEREODISPARITY,                   /**< Calculate disparity between Stereo view pair. Will be deprecated from next SDK release.
+                                                       Instead, use x component of output from NV_OF_MODE_OPTICALFLOW mode */
+    NV_OF_MODE_MAX
+} NV_OF_MODE;
+
+/**
+*  Supported buffer type for ::NvOFGPUBufferHandle allocation.
+*  Client need to set NV_OF_CREATE_BUFFER::bufferUsage with ::NV_OF_BUFFER_USAGE enum values.
+*/
+typedef enum _NV_OF_BUFFER_USAGE
+{
+    NV_OF_BUFFER_USAGE_UNDEFINED,
+    NV_OF_BUFFER_USAGE_INPUT,                    /**< Input buffer type is used to allocate ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame,
+                                                      ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame. */
+    NV_OF_BUFFER_USAGE_OUTPUT,                   /**< Output buffer type is used to allocate ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer. */
+    NV_OF_BUFFER_USAGE_HINT,                     /**< Hint buffer type is used to allocate ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints.*/
+    NV_OF_BUFFER_USAGE_COST,                     /**< Cost buffer type is used to allocate ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputCostBuffer.*/
+    NV_OF_BUFFER_USAGE_GLOBAL_FLOW,              /**< Global flow buffer type is used to allocate ::NV_OF_EXECUTE_OUTPUT_PARAMS::globalFlowBuffer. */
+    NV_OF_BUFFER_USAGE_MAX
+} NV_OF_BUFFER_USAGE;
+
+/**
+* Supported buffer formats
+*/
+typedef enum _NV_OF_BUFFER_FORMAT
+{
+    NV_OF_BUFFER_FORMAT_UNDEFINED,
+    NV_OF_BUFFER_FORMAT_GRAYSCALE8,               /**< Input buffer format with 8 bit planar format */
+    NV_OF_BUFFER_FORMAT_NV12,                     /**< Input buffer format with 8 bit planar, UV interleaved */
+    NV_OF_BUFFER_FORMAT_ABGR8,                    /**< Input buffer format with 8 bit packed A8B8G8R8 */
+    NV_OF_BUFFER_FORMAT_SHORT,                    /**< Output or hint buffer format for stereo disparity */
+    NV_OF_BUFFER_FORMAT_SHORT2,                   /**< Output or hint buffer format for optical flow vector */
+    NV_OF_BUFFER_FORMAT_UINT,                     /**< Legacy 32-bit Cost buffer format for optical flow vector / stereo disparity. 
+                                                       This cost buffer format is not performance efficient and results in additional GPU usage.
+                                                       Hence users are strongly recommended to use the 8-bit cost buffer format. 
+                                                       Legacy 32-bit cost buffer format is also planned to be deprecated in future. */
+    NV_OF_BUFFER_FORMAT_UINT8,                    /**< 8-bit Cost buffer format for optical flow vector / stereo disparity. */
+    NV_OF_BUFFER_FORMAT_MAX
+} NV_OF_BUFFER_FORMAT;
+
+/**
+* Stero disparity will be deprecated from next SDK release. Instead, use x compononent of Optical Flow.
+* Supported stereo disparity range.  Avaialble for GPUs later than Turing
+*/
+typedef enum _NV_OF_STEREO_DISPARITY_RANGE
+{
+    NV_OF_STEREO_DISPARITY_RANGE_UNDEFINED,
+    NV_OF_STEREO_DISPARITY_RANGE_128 = 128,
+    NV_OF_STEREO_DISPARITY_RANGE_256 = 256,
+    NV_OF_STEREO_DISPARITY_RANGE_MAX
+} NV_OF_STEREO_DISPARITY_RANGE;
+
+/**
+* \struct NV_OF_PRED_DIRECTION
+* Prediction direction of the flow estimation
+*/
+typedef enum _NV_OF_PRED_DIRECTION
+{
+    NV_OF_PRED_DIRECTION_FORWARD    = 0,                            /**< [in]: Default direction. Gives each pixel position change from ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame
+                                                                               to ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer
+                                                                               and the corresponding cost in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputCostBuffer if ::NV_OF_INIT_PARAMS::
+                                                                               enableOutputCost is set */
+    NV_OF_PRED_DIRECTION_BOTH       = 2,                            /**< [in]: Flow in both direction. Gives each pixel position change from ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame
+                                                                               to ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer
+                                                                               and the corresponding cost in ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputCostBuffer and ::NV_OF_EXECUTE_INPUT_PARAMS::
+                                                                               referenceFrame to ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame in ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer
+                                                                               and the corresponding cost in ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputCost if NV_OF_INIT_PARAMS::enableOutputCost
+                                                                               is set. Applicable only when ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW.*/
+    NV_OF_PRED_DIRECTION_MAX
+} NV_OF_PRED_DIRECTION;
+
+/**
+* \struct NV_OF_FLOW_VECTOR
+* Struct needed for optical flow. ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer will be populated with optical flow
+* in ::NV_OF_FLOW_VECTOR format for each ::NV_OF_INIT_PARAMS::outGridSize.
+* Flow vectors flowx and flowy are 16-bit values with the lowest 5 bits holding fractional value,
+* followed by a 10-bit integer value and the most significant bit being a sign bit.
+*/
+typedef struct _NV_OF_FLOW_VECTOR
+{
+    int16_t                         flowx;        /**< x component of flow in S10.5 format */
+    int16_t                         flowy;        /**< y component of flow in S10.5 format */
+} NV_OF_FLOW_VECTOR;
+
+/**
+* \struct NV_OF_STEREO_DISPARITY
+* Struct needed for stereo /disparity. ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer will be populated
+* with stereo disparity in ::NV_OF_STEREO_DISPARITY format for each ::NV_OF_INIT_PARAMS::outGridSize.
+* Stereo disparity is a 16-bit value with the lowest 5 bits holding fractional value,
+* followed by a 11-bit unsigned integer value.
+*/
+typedef struct _NV_OF_STEREO_DISPARITY
+{
+    uint16_t                        disparity;    /**< Horizontal displacement[in pixels] in 11.5 format. */
+} NV_OF_STEREO_DISPARITY;
+
+/**
+* \struct NV_OF_INIT_PARAMS
+* Optical flow/stereo disparity session initialization parameters.
+*/
+typedef struct _NV_OF_INIT_PARAMS
+{
+    uint32_t                        width;                            /**< [in]: Specifies input buffer width */
+    uint32_t                        height;                           /**< [in]: Specifies input buffer height */
+    NV_OF_OUTPUT_VECTOR_GRID_SIZE   outGridSize;                      /**< [in]: Specifies flow vector grid size for ::NV_OF_EXECUTE_INPUT_PARAMS::outputBuffer buffer.*/
+    NV_OF_HINT_VECTOR_GRID_SIZE     hintGridSize;                     /**< [in]: Specifies flow vector grid size for ::NV_OF_EXECUTE_INPUT_PARAMS::externalHints buffer.
+                                                                                 This field is only considered if ::NV_OF_INIT_PARAMS::enableExternalHints is set.
+                                                                                 hintGridSize should be equal or greater than outGridSize. */
+    NV_OF_MODE                      mode;                             /**< [in]: Operating mode for NVOF. Set to a value defined by enum ::NV_OF_MODE. */
+    NV_OF_PERF_LEVEL                perfLevel;                        /**< [in]: Specifies perf level. */
+    NV_OF_BOOL                      enableExternalHints;              /**< [in]: Set to 1 to enable external hints for optical flow session. */
+    NV_OF_BOOL                      enableOutputCost;                 /**< [in]: Set to 1 to enable output cost calculation for optical flow session. */
+    NvOFPrivDataHandle              hPrivData;                        /**< [in]: Optical flow private data. It is reserved field and should be set to NULL. */
+    NV_OF_STEREO_DISPARITY_RANGE    disparityRange;                   /**< [in]: Specifies maximum disparity range. 
+                                                                                 Set to NV_OF_STEREO_DISPARITY_RANGE_UNDEFINED for Turing GPUs. */
+    NV_OF_BOOL                      enableRoi;                        /**< [in]: Set to 1 to enable estimation of optical flow/stereo for roi. */
+    NV_OF_PRED_DIRECTION            predDirection;                    /**< [in]: Prediction direction. When ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW,
+                                                                                 the possible values are ::NV_OF_PRED_DIRECTION_FORWARD and ::NV_OF_PRED_DIRECTION_BOTH.
+                                                                                 When ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, only
+                                                                                 ::NV_OF_PRED_DIRECTION_FORWARD is supported. */
+    NV_OF_BOOL                      enableGlobalFlow;                 /**< [in]: Set to 1 to enable forward global flow estimation.
+                                                                                 Applicable only when ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW. */
+    NV_OF_BUFFER_FORMAT             inputBufferFormat;                /**< [in]: Specifies the buffer format of ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame and
+                                                                                 ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame. */
+} NV_OF_INIT_PARAMS;
+
+/**
+* \struct NV_OF_BUFFER_DESCRIPTOR
+* Creation parameters for optical flow buffers.
+*/
+typedef struct _NV_OF_BUFFER_DESCRIPTOR
+{
+    uint32_t                        width;                           /**< [in]: Buffer width. */
+    uint32_t                        height;                          /**< [in]: Buffer height. */
+    NV_OF_BUFFER_USAGE              bufferUsage;                     /**< [in]: To specify buffer usage type.
+                                                                     ::NV_OF_BUFFER_USAGE_OUTPUT buffer usage type accepts ::NV_OF_BUFFER_DESCRIPTOR::width,
+                                                                     ::NV_OF_BUFFER_DESCRIPTOR::height in ::NV_OF_INIT_PARAMS::outGridSize units.
+                                                                     ::NV_OF_BUFFER_USAGE_HINT buffer usage type accepts ::NV_OF_BUFFER_DESCRIPTOR::width,
+                                                                     ::NV_OF_BUFFER_DESCRIPTOR::height in ::NV_OF_INIT_PARAMS::hintGridSize units. */
+    NV_OF_BUFFER_FORMAT             bufferFormat;                    /**< [in]: Buffer format. */
+
+} NV_OF_BUFFER_DESCRIPTOR;
+
+/**
+* \struct NV_OF_ROI_RECT
+* Specifies the co-ordinates of the Region Of Interest (ROI)
+* ROI rects should satisfy below requirements:
+*   1. NV_OF_ROI_RECT::start_x should align to (32 * NV_OF_INIT_PARAMS::outGridSize)
+*   2. NV_OF_ROI_RECT::width should align to (32 * NV_OF_INIT_PARAMS::outGridSize)
+*   3. NV_OF_ROI_RECT::start_y should align to (8 * max(NV_OF_INIT_PARAMS::outGridSize, 2))
+*   4. NV_OF_ROI_RECT::height should align to (8 * NV_OF_INIT_PARAMS::outGridSize)
+*   5. NV_OF_ROI_RECT::width >= 32 && NV_OF_ROI_RECT::height >= 16; maximum size 8192x8192
+*   6. Whole ROI region should be inside of the image
+* Optical flow/stereo disparity vectors out side of ROI are invalid and should not be used.
+*/
+typedef struct NV_OF_ROI_RECT
+{
+    uint32_t                        start_x;                         /**< [in]: ROI start position in x-direction. */
+    uint32_t                        start_y;                         /**< [in]: ROI start position in y-direction. */
+    uint32_t                        width;                           /**< [in]: Width of ROI. */
+    uint32_t                        height;                          /**< [in]: Height of ROI. */
+} NV_OF_ROI_RECT;
+
+/**
+* \struct NV_OF_EXECUTE_INPUT_PARAMS
+* Parameters which are sent per frame for optical flow/stereo disparity execution.
+*/
+typedef struct _NV_OF_EXECUTE_INPUT_PARAMS
+{
+    NvOFGPUBufferHandle             inputFrame;                      /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the input frame.
+                                                                                If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified left view. */
+    NvOFGPUBufferHandle             referenceFrame;                  /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the reference frame.
+                                                                                If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified right view. */
+    NvOFGPUBufferHandle             externalHints;                   /**< [in]: It is an optional input, This field will be considered if client had set ::NV_OF_INIT_PARAMS::enableExternalHint flag.
+                                                                                Client can pass some available predictors as hints. 
+                                                                                Optical flow driver will search around those hints to optimize flow vectors quality.
+                                                                                Expected hint buffer format is ::NV_OF_FLOW_VECTOR, ::NV_OF_STEREO_DISPARITY 
+                                                                                for ::NV_OF_MODE_OPTICALFLOW, ::NV_OF_MODE_STEREODISPARITY modes respectively for
+                                                                                each ::NV_OF_INIT_PARAMS::hintGridSize in a frame. */
+    NV_OF_BOOL                      disableTemporalHints;            /**< [in]: Temporal hints yield better accuracy flow vectors when running on successive frames of a continuous video (without major scene changes).
+                                                                                When disableTemporalHints = 0, optical flow vectors from previous NvOFExecute call are automatically used as hints for the current NvOFExecute call.
+                                                                                However, when running optical flow on pairs of images which are completely independent of each other, temporal hints are useless
+                                                                                and in fact, they will degrade the quality. Therefore, it is recommended to set disableTemporalHints = 1 in this case.*/
+    uint32_t                        padding;                         /**< [in]: Padding.  Must be set to 0. */
+    NvOFPrivDataHandle              hPrivData;                       /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+    uint32_t                        padding2;                        /**< [in]: Padding.  Must be set to 0. */
+    uint32_t                        numRois;                         /**< [in]: Number of ROIs. */
+    NV_OF_ROI_RECT*                 roiData;                         /**< [in]: Pointer to the NV_OF_ROI_RECTs data.  Size of this buffer should be atleast numROIs * sizeof(NV_OF_ROI_RECT). */
+} NV_OF_EXECUTE_INPUT_PARAMS;
+
+/**
+* \struct NV_OF_EXECUTE_OUTPUT_PARAMS
+* Parameters which are received per frame for optical flow/stereo disparity execution.
+*/
+typedef struct _NV_OF_EXECUTE_OUTPUT_PARAMS
+{
+    NvOFGPUBufferHandle            outputBuffer;                     /**< [in]: Specifies the pointer to optical flow or stereo disparity buffer handle.
+                                                                                ::outputBuffer will be populated with optical flow in
+                                                                                ::NV_OF_FLOW_VECTOR format or stereo disparity in 
+                                                                                ::NV_OF_STEREO_DISPARITY format for each 
+                                                                                ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGridSize in a frame.*/
+    NvOFGPUBufferHandle            outputCostBuffer;                 /**< [in]: Specifies the pointer to output cost calculation buffer handle. */
+    NvOFPrivDataHandle             hPrivData;                        /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+    NvOFGPUBufferHandle            bwdOutputBuffer;                  /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH,
+                                                                                this specifies the pointer to backward optical flow buffer handle.
+                                                                                ::bwOutputBuffer will be populated with optical flow in ::NV_OF_FLOW_VECTOR format
+                                                                                for each ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGidSize in a frame. */
+    NvOFGPUBufferHandle            bwdOutputCostBuffer;              /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH and
+                                                                                ::NV_OF_INIT_PARAMS::enableOutputCost is NV_TRUE, this specifies the pointer
+                                                                                to the backward output cost calculation buffer handle. */
+    NvOFGPUBufferHandle            globalFlowBuffer;                 /**< [in]: When ::NV_OF_INIT_PARAMS::enableGlobalFlow is set to NV_true, this specifies the
+                                                                                pointer to the global flow buffer handle. ::globalFlowBuffer will be populated in
+                                                                                ::NV_OF_FLOW_VECTOR format. */
+} NV_OF_EXECUTE_OUTPUT_PARAMS;
+
+/**
+* \brief Initialize NVIDIA Video Optical Flow Interface and validates input params.
+*
+* Initializes NVIDIA Video Optical Flow Interface and validates input params.
+* It also initializes NVIDIA Video Optical Flow driver with the init value passed in ::NV_OF_INIT_PARAMS
+* structure.
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in] initParams
+*   Pointer to the ::NV_OF_INIT_PARAMS structure.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_UNSUPPORTED_DEVICE \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFINIT) (NvOFHandle hOf, const NV_OF_INIT_PARAMS *initParams);
+
+/**
+* \brief Kick off computation of optical flow between input and reference frame.
+*
+* This is asynchronous function call which kicks off computation of optical flow or stereo disparity
+* between ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame and ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame and returns
+* after submitting  execute paramaters to optical flow engine. 
+* ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer will be populated with optical flow or stereo disparity
+* based on ::NV_OF_INIT_PARAMS:mode is NV_OF_MODE_OPTICALFLOW or NV_OF_MODE_STEREODISPARITY respectively.
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in] executeInParams
+*   pointer to the ::NV_OF_EXECUTE_INPUT_PARAMS structure.
+* \param [out] executeOutParams
+*   pointer to the ::NV_OF_EXECUTE_OUTPUT_PARAMS structure.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_INVALID_DEVICE \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFEXECUTE) (NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS *executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS *executeOutParams);
+
+/**
+* \brief Release optical flow API and driver resources.
+*
+* Releases resources and waits until all resources are gracefully released.
+*
+*  \param [in] hOf
+*   Object of ::NvOFHandle type.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFDESTROY) (NvOFHandle hOf);
+
+/**
+* \brief Populate error buffer with the description of last failure.
+*
+* Populates lastError[] with the description of last failure.
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in/out] lastError
+*   lastError is a char array, minimum expected size of lastError[] is MIN_ERROR_STRING_SIZE characters.
+*   After execution of this function call, lastError[] is populated with error string.
+* \param [in/out] As an input parameter, "size" indicates the size of the array provided by the client.
+*   After execution of this function call, "size" field indicates the number of characters written into
+*   "lastError" excluding null character.
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETLASTERROR) (NvOFHandle hOf, char lastError[], uint32_t *size);
+
+/**
+* \brief Populate capability array for specified ::NV_OF_CAPS value.
+* This is to be called in two stages.
+* It returns the number of capability values for specified ::NV_OF_CAPS value when
+* queried with "capsVal" set to NULL.
+* It populates capsVal array with capability values for specified ::NV_OF_CAPS value
+* when queried with "capsVal" set to non-NULL value.
+*
+*  \param [in] hOf
+*   Object of ::NvOFHandle type.
+*  \param [in] capsParam
+*   object of ::NV_OF_CAPS type.
+*  \param [out] capsVal
+*   Pointer to uint32_t, minimum expected size of capsVal is the "size" returned by the this function call
+*   queried with "capsVal" set to NULL.
+* \param [out] size
+*   Pointer to uint32_t, which stores size of populated capsVal.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETCAPS) (NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t *capsVal, uint32_t *size);
+
+/**
+* \brief Get the largest API version supported by the driver.
+*
+* This function can be used by clients to determine if the driver supports
+* the API header the application was compiled with.
+*
+* \param [out] version
+*   Pointer to the requested value. The 4 least significant bits in the returned
+*   indicate the minor version and the rest of the bits indicate the major
+*   version of the largest supported version.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+*/
+NV_OF_STATUS NVOFAPI NvOFGetMaxSupportedApiVersion(uint32_t* version);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowCuda.h b/inc/nvofapi/nvOpticalFlowCuda.h
new file mode 100644
index 00000000..a249dd29
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowCuda.h
@@ -0,0 +1,236 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file NvOpticalFlowCuda.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowCuda.h provides cuda specific enums, structure definitions and function pointers prototypes.
+*/
+
+#ifndef _NV_OPTICALFLOW_CUDA_H_
+#define _NV_OPTICALFLOW_CUDA_H_
+#include "nvOpticalFlowCommon.h"
+#include <cuda.h>
+#define MAX_NUM_PLANES 3
+
+#if defined(__cplusplus)
+
+extern "C" 
+{
+#endif /* __cplusplus */
+
+/**
+* Supported CUDA buffer types.
+*/
+typedef enum _NV_OF_CUDA_BUFFER_TYPE
+{
+    NV_OF_CUDA_BUFFER_TYPE_UNDEFINED,
+    NV_OF_CUDA_BUFFER_TYPE_CUARRAY,           /**< Buffer type is CUarray */
+    NV_OF_CUDA_BUFFER_TYPE_CUDEVICEPTR,       /**< Buffer type is CUdeviceptr */
+    NV_OF_CUDA_BUFFER_TYPE_MAX
+} NV_OF_CUDA_BUFFER_TYPE;
+
+/**
+* \struct NV_BUFFER_STRIDE
+* Horizontal and vertical strides of a plane.
+*/
+typedef struct _NV_OF_BUFFER_STRIDE
+{
+    uint32_t strideXInBytes;               /**< Horizontal stride. */
+    uint32_t strideYInBytes;               /**< Vertical stride. */
+} NV_OF_BUFFER_STRIDE;
+
+/**
+* \struct NV_OF_CUDA_BUFFER_STRIDE_INFO
+* This structure stores buffer stride information which is populated in the ::nvOFGPUBufferGetStrideInfo() API.
+*/
+typedef struct _NV_OF_CUDA_BUFFER_STRIDE_INFO
+{
+    NV_OF_BUFFER_STRIDE strideInfo[MAX_NUM_PLANES];    /**< Stride information of each plane.*/
+    uint32_t            numPlanes;                     /**< Number of planes. */
+} NV_OF_CUDA_BUFFER_STRIDE_INFO;
+
+/**
+* \brief Create an instance of NvOFHandle object.
+*
+* This function creates an instance of NvOFHandle object and returns status.
+* Client is expected to release NvOFHandle resource using Destroy function call.
+*
+* \param [in] cuContext
+*   Should be set to cuda context created by Client.
+* \param [out] NvOFHandle*
+*   Pointer of class ::NvOFHandle object.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWCUDA) (CUcontext device, NvOFHandle *hOf);
+
+/**
+* \brief Set input and output cuda stream for specified optical flow instance.
+*
+* Optical flow algorithm may optionally involve cuda preprocessing on the input buffers and post
+* processing on the output flow vectors. This function is used to set input and output cuda stream
+* to pipeline and synchronize the cuda preprocessing and post processing tasks with OF HW engine.
+* Client should call this function before Execute function to update input and/or output streams otherwise
+* Execute function will either use preset input, output streams or default streams(If streams are never set before).
+*
+* \param [in] hOf
+*   Object of ::NvOFHandle type.
+* \param [in] inputStream
+*   CUstream type object which is used to process ::NV_OF_EXECUTE_INPUT_PARAMS::inputFrame,
+*   ::NV_OF_EXECUTE_INPUT_PARAMS::referenceFrame and optional NV_OF_EXECUTE_INPUT_PARAMS::externalHints.
+* \param [in] outputStream
+*  CUstream type object which is used to process ::NV_OF_EXECUTE_OUTPUT_PARAMS::outputBuffer and 
+*  optional ::NV_OF_EXECUTE_OUTPUT_PARAMS::costBuffer, ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputBuffer,
+*  ::NV_OF_EXECUTE_OUTPUT_PARAMS::bwdOutputCostBuffer.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_INVALID_DEVICE \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFSETIOCUDASTREAMS) (NvOFHandle hOf, CUstream inputStream, CUstream outputStream);
+
+/**
+* \brief Create ::NvOFGPUBufferHandle resource.
+*
+* This function creates ::NvOFGPUBufferHandle resource for specified cuda bufferType.
+*
+* \param [in] hOf
+*   Pointer to the NvOFHandle.
+* \param [in] createBufferParams
+*   pointer of the ::NV_OF_CREATE_BUFFER.
+* \param [out] ofGpuBuffer
+*   Output pointer of ::NvOFGPUBufferHandle type.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+* ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+* ::NV_OF_ERR_OUT_OF_MEMORY \n
+* ::NV_OF_ERR_INVALID_PARAM \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFCREATEGPUBUFFERCUDA) (NvOFHandle hOf, const NV_OF_BUFFER_DESCRIPTOR *bufferDesc,
+                                                         NV_OF_CUDA_BUFFER_TYPE bufferType, NvOFGPUBufferHandle *hOfGpuBuffer);
+
+/**
+* \brief Return CUarray object associated with ::NvOFGPUBufferHandle type resource.
+*
+* \param [in] ofGpuBuffer
+*  Object of type NvOFGPUBufferHandle, created by a call to NvOFCreateGPUBufferCuda() with bufferType set to ::NV_OF_CUDA_BUFFER_TYPE_CUARRAY.
+*
+* \return  
+* Object of CUarray type.
+* If ofGpubuffer corresponds to a GPU buffer that was not created with buffer type NV_OF_CUDA_BUFFER_TYPE_CUARRAY,
+* this function returns NULL
+*/
+typedef CUarray(NVOFAPI* PFNNVOFGPUBUFFERGETCUARRAY) (NvOFGPUBufferHandle ofGpuBuffer);
+
+/**
+* \brief Return CUdeviceptr object associated with ::NvOFGPUBufferHandle type resource.
+*
+* \param [in] ofGpuBuffer
+*  Object of type NvOFGPUBufferHandle, created by a call to NvOFCreateGPUBufferCuda() with bufferType set to ::NV_OF_CUDA_BUFFER_TYPE_CUDEVICEPTR.
+*
+* \return 
+* Object of the CUdeviceptr type.
+* If ofGpubuffer corresponds to a GPU buffer that was not created with buffer type NV_OF_CUDA_BUFFER_TYPE_CUDEVICEPTR,
+* this function returns 0
+*/
+typedef CUdeviceptr(NVOFAPI* PFNNVOFGPUBUFFERGETCUDEVICEPTR) (NvOFGPUBufferHandle ofGpuBuffer);
+
+/**
+* \brief Populates buffer information associated with ::NvOFGPUBufferHandle type resource.
+*
+* Populates structure ::NV_OF_CUDA_BUFFER_STRIDE_INFO with the horizontal and vertical stride details of all the planes.
+* \param [in] ofGpuBuffer
+*   Object of type NvOFGPUBufferHandle, created by a call to NvOFCreateGPUBufferCuda().
+* \param [out] strideInfo
+*   pointer to the ::NV_OF_CUDA_BUFFER_STRIDE_INFO.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_PTR \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNVOFGPUBUFFERGETSTRIDEINFO) (NvOFGPUBufferHandle ofGpuBuffer, NV_OF_CUDA_BUFFER_STRIDE_INFO *strideInfo);
+
+/**
+* \brief Destroy NvOFGPUBufferHandle object and associated resources.
+*
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_GENERIC \n
+*/
+typedef NV_OF_STATUS(NVOFAPI* PFNNVOFDESTROYGPUBUFFERCUDA) (NvOFGPUBufferHandle buffer);
+
+/**
+* \struct NV_OF_CUDA_API_FUNCTION_LIST
+* This is structure of function pointers  which are populated by ::NvOFAPICreateInstanceCuda() API.
+* Defination of each cuda specific function pointer is defined above.
+*/
+typedef struct _NV_OF_CUDA_API_FUNCTION_LIST
+{
+    PFNNVCREATEOPTICALFLOWCUDA                                 nvCreateOpticalFlowCuda;
+    PFNNVOFINIT                                                nvOFInit;
+    PFNNVOFCREATEGPUBUFFERCUDA                                 nvOFCreateGPUBufferCuda;
+    PFNNVOFGPUBUFFERGETCUARRAY                                 nvOFGPUBufferGetCUarray;
+    PFNNVOFGPUBUFFERGETCUDEVICEPTR                             nvOFGPUBufferGetCUdeviceptr;
+    PFNVOFGPUBUFFERGETSTRIDEINFO                               nvOFGPUBufferGetStrideInfo;
+    PFNNVOFSETIOCUDASTREAMS                                    nvOFSetIOCudaStreams;
+    PFNNVOFEXECUTE                                             nvOFExecute;
+    PFNNVOFDESTROYGPUBUFFERCUDA                                nvOFDestroyGPUBufferCuda;
+    PFNNVOFDESTROY                                             nvOFDestroy;
+    PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+    PFNNVOFGETCAPS                                             nvOFGetCaps;
+} NV_OF_CUDA_API_FUNCTION_LIST;
+
+/**
+* \brief ::NvOFAPICreateInstanceCuda() API is the entry point to the NvOFAPI interface.
+*
+* ::NvOFAPICreateInstanceCuda() API populates functionList with function pointers to the API routines implemented by the
+ * NvOFAPI interface.
+*
+* \return
+* ::NV_OF_SUCCESS \n
+* ::NV_OF_ERR_INVALID_VERSION \n
+* :: NV_OF_ERR_INVALID_PTR \n
+*/
+NV_OF_STATUS NVOFAPI NvOFAPICreateInstanceCuda(uint32_t apiVer, NV_OF_CUDA_API_FUNCTION_LIST  *functionList);
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowD3D11.h b/inc/nvofapi/nvOpticalFlowD3D11.h
new file mode 100644
index 00000000..a609e1d1
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowD3D11.h
@@ -0,0 +1,193 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowD3D11.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowD3D11.h provides D3D11 specific enums, structure definitions and function prototypes.
+*  for Direct3D11 resource.
+*/
+#ifndef _NV_OPTICALFLOW_D3D11_H_
+#define _NV_OPTICALFLOW_D3D11_H_
+#include "nvOpticalFlowCommon.h"
+#include <d3d11.h>
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+    /**
+    * \brief Create an instance of NvOFHandle object.
+    *
+    * This function creates an instance of NvOFHandle object and returns status.
+    * Client is expected to release NvOFHandle resource using Destroy function call.
+    *
+    * \param [in] pD3D11Device
+    *   Client must provide set this to the ID3D11Device created by the client.
+    * \param [in] pD3D11DeviceContext
+    *   Client must provide ID3D11DeviceContext* for the ID3D11Device created by the client.
+    * \param [out] NvOFHandle*
+    *   Pointer of class ::NvOFHandle object.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OF_NOT_AVAILABLE \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWD3D11) (ID3D11Device* const pD3D11Device, ID3D11DeviceContext* const pD3D11DeviceContext, NvOFHandle *hOFInstance);
+
+    /**
+    * \brief Populate the count of the DXGI_FORMATs supported.
+    *
+    * This function returns the count of the DXGI_FORMAT supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client can use this count to allocate a sufficiently large array for 
+    * querying the DXGI_FORMATS supported.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pCount
+    *  The count is returned by uint32_t* pCount
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATCOUNTD3D11) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, uint32_t* const pCount);
+
+    /**
+    * \brief Populate the array of the DXGI_FORMATs supported.
+    *
+    * This function returns the array of the DXGI_FORMATs supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client must populate surface format count prior to this call.
+    * Client must allocate sufficiently large array size for this function call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pFormat
+    *  The list is returned through client allocated array of DXGI_FORMAT.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATD3D11) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat);
+
+    /**
+    * \brief Register the app allocated ID3D11Resource with the NvOFAPI.
+    *
+    * This function registers the app allocated ID3D11Resource with the NvOFAPI and gets an opaque handle NvOFGPUBufferHandle
+    * in return. The client should call ::NvOFUnregisterResourceD3D11 with NvOFGPUBufferHandle to unregister the resource.
+    * Client need to register the ID3D11Resource with OFAPI to be able to use it in the ::NvOFExecute call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] pResource
+    *  ID3D11Resource* allocated by the client.
+    * \param [out] hOFGpuBuffer
+    *   Output pointer of ::NvOFGPUBufferHandle type.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFREGISTERRESOURCED3D11) (NvOFHandle hOf, ID3D11Resource* pResource, NvOFGPUBufferHandle* const hOFGpuBuffer);
+
+    /**
+    * \brief Unregister the app allocated ID3D11Resource with the NvOFAPI.
+    *
+    * This function unregisters the app allocated ID3D11Resource which is already registered with the NvOFAPI.
+    * Client needs to provied the NvOFGPUBufferHandle, which it has received in ::NvOFRegisterResourceD3D11 call.
+
+    * \param in] hOFGpuBuffer
+    *   Input pointer of ::NvOFGPUBufferHandle type.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFUNREGISTERRESOURCED3D11) (NvOFGPUBufferHandle hOFGpuBuffer);
+
+    /*
+    * Defining D3D11 specific API function pointers.
+    */
+    typedef struct _NV_OF_D3D11_API_FUNCTION_LIST
+    {
+        PFNNVCREATEOPTICALFLOWD3D11                                nvCreateOpticalFlowD3D11;
+        PFNNVOFINIT                                                nvOFInit;
+        PFNNVOFGETSURFACEFORMATCOUNTD3D11                          nvOFGetSurfaceFormatCountD3D11;
+        PFNNVOFGETSURFACEFORMATD3D11                               nvOFGetSurfaceFormatD3D11;
+        PFNNVOFREGISTERRESOURCED3D11                               nvOFRegisterResourceD3D11;
+        PFNNVOFUNREGISTERRESOURCED3D11                             nvOFUnregisterResourceD3D11;
+        PFNNVOFEXECUTE                                             nvOFExecute;
+        PFNNVOFDESTROY                                             nvOFDestroy;
+        PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+        PFNNVOFGETCAPS                                             nvOFGetCaps;
+    } NV_OF_D3D11_API_FUNCTION_LIST;
+
+
+    /**
+    * \brief ::NvOFAPICreateInstanceD3D11() API is the entry point to the NvOFAPI interface.
+    *
+    * ::NvOFAPICreateInstanceD3D11() API populates functionList with function pointers to the API routines implemented by the
+    * NvOFAPI interface.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    */
+    NV_OF_STATUS NVOFAPI NvOFAPICreateInstanceD3D11(uint32_t apiVer, NV_OF_D3D11_API_FUNCTION_LIST  *functionList);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowD3D12.h b/inc/nvofapi/nvOpticalFlowD3D12.h
new file mode 100644
index 00000000..7794304d
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowD3D12.h
@@ -0,0 +1,308 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowD3D12.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow and stereo estimation.
+*   nvOpticalFlowD3D12.h provides D3D12 specific enums, structure definitions and function prototypes.
+* */
+#ifndef _NV_OPTICALFLOW_D3D12_H_
+#define _NV_OPTICALFLOW_D3D12_H_
+#include "nvOpticalFlowCommon.h"
+#include <d3d12.h>
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+    /** \struct NV_OF_FENCE_POINT
+    * Fence and value for synchronization.
+    */
+    typedef struct _NV_OF_FENCE_POINT
+    {
+        ID3D12Fence*                    fence;                          /**< [in]: Fence object used in synchronization. */
+        uint64_t                        value;                          /**< [in]: Value the fence to reach or exceed before the GPU operation or
+                                                                                   Value to set the fence to after the GPU operation. */
+    } NV_OF_FENCE_POINT;
+
+    /**
+    * \struct NV_OF_REGISTER_RESOURCE_PARAMS_D3D12
+    * Parameters used in registering a ID3D12Resource
+    */
+    typedef struct _NV_OF_REGISTER_RESOURCE_PARAMS_D3D12
+    {
+        ID3D12Resource*                 resource;                       /**< [in]: ID3D12Resource that need to be registered. */
+        NV_OF_FENCE_POINT               inputFencePoint;                /**< [in]: GPU wait until the specified fence reaches or exceeds the specified value. */
+        NvOFGPUBufferHandle*            hOFGpuBuffer;                   /**< [in]: Pointer to the opaque handle of the registered resource. */
+        NV_OF_FENCE_POINT               outputFencePoint;               /**< [in]: Updates the specified fence to the specified value after GPU operation. */
+    } NV_OF_REGISTER_RESOURCE_PARAMS_D3D12;
+
+    /**
+    * \struct NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12
+    * Parameters used in unregistering a ID3D12Resource
+    */
+    typedef struct _NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12
+    {
+        NvOFGPUBufferHandle             hOFGpuBuffer;                   /**< [in]: Registered handle of the resource that need to be unregistered. */
+    } NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12;
+
+    /**
+    * \struct NV_OF_EXECUTE_INPUT_PARAMS_D3D12
+    * Parameters which are sent per frame for optical flow/stereo disparity execution.
+    */
+    typedef struct _NV_OF_EXECUTE_INPUT_PARAMS_D3D12
+    {
+        NvOFGPUBufferHandle             inputFrame;                      /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the input frame.
+                                                                                    If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified left view. */
+        NvOFGPUBufferHandle             referenceFrame;                  /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the reference frame.
+                                                                                    If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_STEREODISPARITY, this specifies the handle to the buffer containing the rectified right view. */
+        NvOFGPUBufferHandle             externalHints;                   /**< [in]: It is an optional input, This field will be considered if client had set ::NV_OF_INIT_PARAMS::enableExternalHint flag.
+                                                                                    Client can pass some available predictors as hints. 
+                                                                                    Optical flow driver will search around those hints to optimize flow vectors quality.
+                                                                                    Expected hint buffer format is ::NV_OF_FLOW_VECTOR, ::NV_OF_STEREO_DISPARITY 
+                                                                                    for ::NV_OF_MODE_OPTICALFLOW, ::NV_OF_MODE_STEREODISPARITY modes respectively for
+                                                                                    each ::NV_OF_INIT_PARAMS::hintGridSize in a frame. */
+        NV_OF_BOOL                      disableTemporalHints;            /**< [in]: Temporal hints yield better accuracy flow vectors when running on successive frames of a continuous video (without major scene changes).
+                                                                                    When disableTemporalHints = 0, optical flow vectors from previous NvOFExecute call are automatically used as hints for the current NvOFExecute call.
+                                                                                    However, when running optical flow on pairs of images which are completely independent of each other, temporal hints are useless
+                                                                                    and in fact, they will degrade the quality. Therefore, it is recommended to set disableTemporalHints = 1 in this case.*/
+        uint32_t                        padding;                         /**< [in]: Padding.  Must be set to 0. */
+        NvOFPrivDataHandle              hPrivData;                       /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        uint32_t                        padding2;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numRois;                         /**< [in]: Number of ROIs. */
+        NV_OF_ROI_RECT*                 roiData;                         /**< [in]: Pointer to the NV_OF_ROI_RECTs data.  Size of this buffer should be atleast numROIs * sizeof(NV_OF_ROI_RECT). */
+        uint32_t                        padding3;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numFencePoints;                  /**< [in]: Number of fence points to reach or exceed before GPU operation starts.
+                                                                                    Client can use different fence points for different buffers syncrhonization.  Client shall speicify all the fence points
+                                                                                    used for the buffers synchronization which will be used in Optical Flow estimation. */
+        NV_OF_FENCE_POINT*              fencePoint;                      /**< [in]: Pointer to an array of fence points to reach or exceed before GPU operation starts. */
+    } NV_OF_EXECUTE_INPUT_PARAMS_D3D12;
+
+    /**
+    * \struct NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12
+    * Parameters which are received per frame for optical flow/stereo disparity execution.
+    */
+    typedef struct _NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12
+    {
+        NvOFGPUBufferHandle             outputBuffer;                     /**< [in]: Specifies the pointer to optical flow or stereo disparity buffer handle.
+                                                                                    ::outputBuffer will be populated with optical flow in
+                                                                                    ::NV_OF_FLOW_VECTOR format or stereo disparity in 
+                                                                                    ::NV_OF_STEREO_DISPARITY format for each 
+                                                                                    ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGridSize in a frame.*/
+        NvOFGPUBufferHandle             outputCostBuffer;                 /**< [in]: Specifies the pointer to output cost calculation buffer handle. */
+        NvOFPrivDataHandle              hPrivData;                        /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        NvOFGPUBufferHandle             bwdOutputBuffer;                  /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH,
+                                                                                    this specifies the pointer to backward optical flow buffer handle.
+                                                                                    ::bwOutputBuffer will be populated with optical flow in ::NV_OF_FLOW_VECTOR format
+                                                                                    for each ::NV_OF_VECTOR_GRID_SIZE::outGidSize in a frame. */
+        NvOFGPUBufferHandle             bwdOutputCostBuffer;              /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH and
+                                                                                    ::NV_OF_INIT_PARAMS::enableOutputCost is NV_TRUE, this specifies the pointer
+                                                                                    to the backward output cost calculation buffer handle. */
+        NvOFGPUBufferHandle             globalFlowBuffer;                 /**< [in]: When ::NV_OF_INIT_PARAMS::enableGlobalFlow is set to NV_true, this specifies the
+                                                                                    pointer to the global flow buffer handle. ::globalFlowBuffer will be populated in
+                                                                                    ::NV_OF_FLOW_VECTOR format. */
+        uint32_t                        padding[2];                       /**< [in]: Reserved.  Must be set to 0. */
+        NV_OF_FENCE_POINT*              fencePoint;                       /**< [in]: Pointer to a single fence point to set after GPU operation. */
+    } NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12;
+
+    /**
+    * \brief Create an instance of NvOFHandle object.
+    *
+    * This function creates an instance of NvOFHandle object and returns status.
+    * Client is expected to release NvOFHandle resource using Destroy function call.
+    *
+    * \param [in] pD3D12Device
+    *   Client must provide set this to the ID3D12Device created by the client.
+    * \param [out] NvOFHandle*
+    *   Pointer of class ::NvOFHandle object.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OF_NOT_AVAILABLE \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWD3D12) (ID3D12Device* const pD3D12Device, NvOFHandle* hOFInstance);
+
+    /**
+    * \brief Populate the count of the DXGI_FORMATs supported.
+    *
+    * This function returns the count of the DXGI_FORMAT supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client can use this count to allocate a sufficiently large array for 
+    * querying the DXGI_FORMATS supported.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pCount
+    *  The count is returned by uint32_t* pCount
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATCOUNTD3D12) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, uint32_t* const pCount);
+
+    /**
+    * \brief Populate the array of the DXGI_FORMATs supported.
+    *
+    * This function returns the array of the DXGI_FORMATs supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE. Client must populate surface format count prior to this call.
+    * Client must allocate sufficiently large array size for this function call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client.
+    * \param [out] pFormat
+    *  The list is returned through client allocated array of DXGI_FORMAT.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATD3D12) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat);
+
+    /**
+    * \brief Register the app allocated ID3D12Resource with the NvOFAPI.
+    *
+    * This function registers the app allocated ID3D12Resource with the NvOFAPI and gets an opaque handle NvOFGPUBufferHandle
+    * in return. The client should call ::NvOFUnregisterResourceD3D12 with NvOFGPUBufferHandle to unregister the resource.
+    * Client need to register the ID3D12Resource with OFAPI to be able to use it in the ::NvOFExecute call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in/out] registerParams
+    *   pointer to the ::NV_OF_REGISTER_RESOURCE_PARAMS_D3D12 strcture.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFREGISTERRESOURCED3D12) (NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
+
+    /**
+    * \brief Unregister the app allocated ID3D12Resource with the NvOFAPI.
+    *
+    * This function unregisters the app allocated ID3D12Resource which is already registered with the NvOFAPI.
+    * Client needs to provied the NvOFGPUBufferHandle, which it has received in ::NvOFRegisterResourceD3D12 call.
+
+    * \param [in] unregisterParams
+    *   pointer to the ::NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12 strcture
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFUNREGISTERRESOURCED3D12) (NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* unregisterParams);
+
+    /**
+    * \brief Kick off computation of optical flow between input and reference frame.
+    *
+    * This is asynchronous function call which kicks off computation of optical flow or stereo disparity
+    * between ::NV_OF_EXECUTE_INPUT_PARAMS_D3D12::inputFrame and ::NV_OF_EXECUTE_INPUT_PARAMS_D3D12::referenceFrame and returns
+    * after submitting  execute paramaters to optical flow engine. 
+    * ::NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12::outputBuffer will be populated with optical flow or stereo disparity
+    * based on ::NV_OF_INIT_PARAMS:mode is NV_OF_MODE_OPTICALFLOW or NV_OF_MODE_STEREODISPARITY respectively.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] executeInParams
+    *   pointer to the ::NV_OF_EXECUTE_INPUT_PARAMS_D3D12 structure.
+    * \param [out] executeOutParams
+    *   pointer to the ::NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12 structure.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFEXECUTED3D12) (NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12 *executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12 *executeOutParams);
+
+    /*
+    * Defining D3D12 specific API function pointers.
+    */
+    typedef struct _NV_OF_D3D12_API_FUNCTION_LIST
+    {
+        PFNNVCREATEOPTICALFLOWD3D12                                nvCreateOpticalFlowD3D12;
+        PFNNVOFINIT                                                nvOFInit;
+        PFNNVOFGETSURFACEFORMATCOUNTD3D12                          nvOFGetSurfaceFormatCountD3D12;
+        PFNNVOFGETSURFACEFORMATD3D12                               nvOFGetSurfaceFormatD3D12;
+        PFNNVOFREGISTERRESOURCED3D12                               nvOFRegisterResourceD3D12;
+        PFNNVOFUNREGISTERRESOURCED3D12                             nvOFUnregisterResourceD3D12;
+        PFNNVOFEXECUTED3D12                                        nvOFExecuteD3D12;
+        PFNNVOFDESTROY                                             nvOFDestroy;
+        PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+        PFNNVOFGETCAPS                                             nvOFGetCaps;
+    } NV_OF_D3D12_API_FUNCTION_LIST;
+
+
+    /**
+    * \brief ::NvOFAPICreateInstanceD3D12() API is the entry point to the NvOFAPI interface.
+    *
+    * ::NvOFAPICreateInstanceD3D12() API populates functionList with function pointers to the API routines implemented by the
+    * NvOFAPI interface.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    */
+    NV_OF_STATUS NVOFAPI NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/inc/nvofapi/nvOpticalFlowVulkan.h b/inc/nvofapi/nvOpticalFlowVulkan.h
new file mode 100644
index 00000000..36455a6b
--- /dev/null
+++ b/inc/nvofapi/nvOpticalFlowVulkan.h
@@ -0,0 +1,312 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/**
+* \file nvOpticalFlowVulkan.h
+*   NVIDIA GPUs - Turing and above contains a hardware-based optical flow engine
+*   which provides fully-accelerated hardware-based optical flow.
+*   nvOpticalFlowVulkan.h provides Vulkan specific enums, structure definitions and function prototypes.
+*   Vulkan optical flow is not supported for the WSL(Window subsystem for Linux) architecture.
+*   Vulkan optical flow is not supported for the Stereo disparity mode.
+*   Vulkan optical flow is not supported on the Turing GPU.
+* */
+#ifndef _NV_OPTICALFLOW_VULKAN_H_
+#define _NV_OPTICALFLOW_VULKAN_H_
+#include "nvOpticalFlowCommon.h"
+#include <vulkan/vulkan.h>
+#ifdef _WIN32
+#include <vulkan/vulkan_win32.h>
+#endif
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif /* __cplusplus */
+    /** \struct NV_OF_SYNC_VK
+    * Semaphore and value for synchronization.
+    */
+    typedef struct _NV_OF_SYNC_VK
+    {
+        VkSemaphore                     semaphore;                      /**< [in]: Timeline semaphore object used in synchronization. */
+        uint64_t                        value;                          /**< [in]: Value the fence to reach or exceed before the GPU operation or
+                                                                                   Value to set the fence to after the GPU operation. */
+    } NV_OF_SYNC_VK;
+
+    /**
+    * \struct NV_OF_REGISTER_RESOURCE_PARAMS_VK
+    * Parameters used in registering a Vulkan resource
+    */
+    typedef struct _NV_OF_REGISTER_RESOURCE_PARAMS_VK
+    {
+		VkImage                         image;                          /**< [in]: Vulkan resource that need to be registered. */
+		VkFormat                        format;                         /**< [in]: Vulkan resource format. */
+        NvOFGPUBufferHandle*            hOFGpuBuffer;                   /**< [in]: Pointer to the opaque handle of the registered resource. */
+    } NV_OF_REGISTER_RESOURCE_PARAMS_VK;
+
+    /**
+    * \struct NV_OF_UNREGISTER_RESOURCE_PARAMS_VK
+    * Parameters used in unregistering a Vulkan resource
+    */
+    typedef struct _NV_OF_UNREGISTER_RESOURCE_PARAMS_VK
+    {
+        NvOFGPUBufferHandle             hOFGpuBuffer;                   /**< [in]: Registered handle of the resource that need to be unregistered. */
+    } NV_OF_UNREGISTER_RESOURCE_PARAMS_VK;
+
+    /**
+    * \struct NV_OF_EXECUTE_INPUT_PARAMS_VK
+    * Parameters which are sent per frame for optical flow execution.
+    */
+    typedef struct _NV_OF_EXECUTE_INPUT_PARAMS_VK
+    {
+        NvOFGPUBufferHandle             inputFrame;                      /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the input frame. */
+        NvOFGPUBufferHandle             referenceFrame;                  /**< [in]: If ::NV_OF_INIT_PARAMS::mode is ::NV_OF_MODE_OPTICALFLOW, this specifies the handle to the buffer containing the reference frame. */
+        NvOFGPUBufferHandle             externalHints;                   /**< [in]: It is an optional input, This field will be considered if client had set ::NV_OF_INIT_PARAMS::enableExternalHint flag.
+                                                                                    Client can pass some available predictors as hints. 
+                                                                                    Optical flow driver will search around those hints to optimize flow vectors quality.
+                                                                                    Expected hint buffer format is ::NV_OF_FLOW_VECTOR for ::NV_OF_MODE_OPTICALFLOW
+                                                                                    each ::NV_OF_INIT_PARAMS::hintGridSize in a frame. */
+        NV_OF_BOOL                      disableTemporalHints;            /**< [in]: Temporal hints yield better accuracy flow vectors when running on successive frames of a continuous video (without major scene changes).
+                                                                                    When disableTemporalHints = 0, optical flow vectors from previous NvOFExecute call are automatically used as hints for the current NvOFExecute call.
+                                                                                    However, when running optical flow on pairs of images which are completely independent of each other, temporal hints are useless
+                                                                                    and in fact, they will degrade the quality. Therefore, it is recommended to set disableTemporalHints = 1 in this case.*/
+        uint32_t                        padding;                         /**< [in]: Padding.  Must be set to 0. */
+        NvOFPrivDataHandle              hPrivData;                       /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        uint32_t                        padding2;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numRois;                         /**< [in]: Number of ROIs. */
+        NV_OF_ROI_RECT*                 roiData;                         /**< [in]: Pointer to the NV_OF_ROI_RECTs data.  Size of this buffer should be atleast numROIs * sizeof(NV_OF_ROI_RECT). */
+        uint32_t                        padding3;                        /**< [in]: Padding.  Must be set to 0. */
+        uint32_t                        numWaitSyncs;                    /**< [in]: Number of semaphores to reach or exceed before GPU operation starts.
+                                                                                    Client can use different fence points for different buffers syncrhonization.  Client shall speicify all the fence points
+                                                                                    used for the buffers synchronization which will be used in Optical Flow estimation. */
+        NV_OF_SYNC_VK*                  pWaitSyncs;                      /**< [in]: Pointer to an array of semaphores to reach or exceed before GPU operation starts. */
+    } NV_OF_EXECUTE_INPUT_PARAMS_VK;
+
+    /**
+    * \struct NV_OF_EXECUTE_OUTPUT_PARAMS_VK
+    * Parameters which are received per frame for optical flow/stereo disparity execution.
+    */
+    typedef struct _NV_OF_EXECUTE_OUTPUT_PARAMS_VK
+    {
+        NvOFGPUBufferHandle             outputBuffer;                     /**< [in]: Specifies the pointer to optical flow buffer handle.
+                                                                                    ::outputBuffer will be populated with optical flow in
+                                                                                    ::NV_OF_FLOW_VECTOR format for each ::NV_OF_OUTPUT_VECTOR_GRID_SIZE::outGridSize in a frame.*/
+        NvOFGPUBufferHandle             outputCostBuffer;                 /**< [in]: Specifies the pointer to output cost calculation buffer handle. */
+        NvOFPrivDataHandle              hPrivData;                        /**< [in]: Optical flow private data handle. It is reserved field and should be set to NULL. */
+        NvOFGPUBufferHandle             bwdOutputBuffer;                  /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH,
+                                                                                    this specifies the pointer to backward optical flow buffer handle.
+                                                                                    ::bwOutputBuffer will be populated with optical flow in ::NV_OF_FLOW_VECTOR format
+                                                                                    for each ::NV_OF_VECTOR_GRID_SIZE::outGidSize in a frame. */
+        NvOFGPUBufferHandle             bwdOutputCostBuffer;              /**< [in]: When ::NV_OF_INIT_PARAMS::predDirection is ::NV_OF_PRED_DIRECTION_BOTH and
+                                                                                    ::NV_OF_INIT_PARAMS::enableOutputCost is NV_TRUE, this specifies the pointer
+                                                                                    to the backward output cost calculation buffer handle. */
+        NvOFGPUBufferHandle             globalFlowBuffer;                 /**< [in]: When ::NV_OF_INIT_PARAMS::enableGlobalFlow is set to NV_true, this specifies the
+                                                                                    pointer to the global flow buffer handle. ::globalFlowBuffer will be populated in
+                                                                                    ::NV_OF_FLOW_VECTOR format. */
+        uint32_t                        padding[2];                       /**< [in]: Reserved.  Must be set to 0. */
+        NV_OF_SYNC_VK*                  pSignalSync;                      /**< [in]: Pointer to a single semaphore to signal after GPU operation. */
+    } NV_OF_EXECUTE_OUTPUT_PARAMS_VK;
+
+    /**
+    * \brief Create an instance of NvOFHandle object.
+    *
+    * This function creates an instance of NvOFHandle object and returns status.
+    * Client is expected to release NvOFHandle resource using Destroy function call.
+    *
+    * \param [in] instance
+    *   Client must set this to the vulkan instance used by the client.
+    * \param [in] physicalDevice
+    *   Client must set this to the vulkan physical device used by the client.
+    * \param [in] device
+    *   Client must set this to the vulkan device created by the client.
+    * \param [out] NvOFHandle*
+    *   Pointer of class ::NvOFHandle object.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OF_NOT_AVAILABLE \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVCREATEOPTICALFLOWVK) (VkInstance instance, VkPhysicalDevice physicalDevice, VkDevice device, NvOFHandle* hOFInstance);
+
+    /**
+    * \brief Populate the count of the VkFormat's supported.
+    *
+    * This function returns the count of the VkFormat's supported for the given NV_OF_BUFFER_USAGE
+    * and the NV_OF_MODE_OPTICALFLOW mode. Client can use this count to allocate a sufficiently large array for 
+    * querying the VkFormat's supported.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client. Note that NV_OF_MODE_STEREODISPARITY mode is not supported for the Vulkan.
+    * \param [out] pCount
+    *  The count is returned by uint32_t* pCount
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATCOUNTVK) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, uint32_t* const pCount);
+
+    /**
+    * \brief Populate the array of the VkFormat's supported.
+    *
+    * This function returns the array of the VkFormat's supported for the given NV_OF_BUFFER_USAGE and ::NV_OF_MODE_OPTICALFLOW mode.
+    * Client must populate surface format count prior to this call.
+    * Client must allocate sufficiently large array size for this function call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] bufUsage
+    *  ::NV_OF_BUFFER_USAGE needs to be provided by the client.
+    * \param [in] ofMode
+    *  ::NV_OF_MODE needs to be provided by the client. Note that NV_OF_MODE_STEREODISPARITY mode is not supported for the Vulkan.
+    * \param [out] pFormat
+    *  The list is returned through client allocated array of VkFormat's.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFGETSURFACEFORMATVK) (NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat);
+
+    /**
+    * \brief Register the app allocated vulkan resource with the NvOFAPI.
+    *
+    * This function registers the app allocated vulkan resource with the NvOFAPI and gets an opaque handle NvOFGPUBufferHandle
+    * in return. The client should call ::NvOFUnregisterResourceVk with NvOFGPUBufferHandle to unregister the resource.
+    * Client need to register the vulkan resource with OFAPI to be able to use it in the ::NvOFExecute call.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in/out] registerParams
+    *   pointer to the ::NV_OF_REGISTER_RESOURCE_PARAMS_VK structure.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFREGISTERRESOURCEVK) (NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
+
+    /**
+    * \brief Unregister the app allocated vulkan resource with the NvOFAPI.
+    *
+    * This function unregisters the app allocated vulkan resource which is already registered with the NvOFAPI.
+    * Client needs to provied the NvOFGPUBufferHandle, which it has received in ::NvOFRegisterResourceVk call.
+
+    * \param [in] unregisterParams
+    *   pointer to the ::NV_OF_UNREGISTER_RESOURCE_PARAMS_VK strcture
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFUNREGISTERRESOURCEVK) (NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* unregisterParams);
+
+    /**
+    * \brief Kick off computation of optical flow between input and reference frame.
+    *
+    * This is asynchronous function call which kicks off computation of optical flow.
+    * between ::NV_OF_EXECUTE_INPUT_PARAMS_VK::inputFrame and ::NV_OF_EXECUTE_INPUT_PARAMS_VK::referenceFrame and returns
+    * after submitting  execute paramaters to optical flow engine. 
+    * ::NV_OF_EXECUTE_OUTPUT_PARAMS_VK::outputBuffer will be populated with optical flow.
+    * based on ::NV_OF_INIT_PARAMS:mode is NV_OF_MODE_OPTICALFLOW.
+    *
+    * \param [in] hOf
+    *   Object of ::NvOFHandle type.
+    * \param [in] executeInParams
+    *   pointer to the ::NV_OF_EXECUTE_INPUT_PARAMS_VK structure.
+    * \param [out] executeOutParams
+    *   pointer to the ::NV_OF_EXECUTE_OUTPUT_PARAMS_VK structure.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    * ::NV_OF_ERR_INVALID_DEVICE \n
+    * ::NV_OF_ERR_DEVICE_DOES_NOT_EXIST \n
+    * ::NV_OF_ERR_UNSUPPORTED_PARAM \n
+    * ::NV_OF_ERR_OUT_OF_MEMORY \n
+    * ::NV_OF_ERR_INVALID_PARAM \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_OF_NOT_INITIALIZED \n
+    * ::NV_OF_ERR_GENERIC \n
+    */
+    typedef NV_OF_STATUS(NVOFAPI* PFNNVOFEXECUTEVK) (NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK *executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK *executeOutParams);
+
+    /*
+    * Defining Vulkan specific API function pointers.
+    */
+    typedef struct _NV_OF_VK_API_FUNCTION_LIST
+    {
+        PFNNVCREATEOPTICALFLOWVK                                   nvCreateOpticalFlowVk;
+        PFNNVOFINIT                                                nvOFInit;
+        PFNNVOFGETSURFACEFORMATCOUNTVK                             nvOFGetSurfaceFormatCountVk;
+        PFNNVOFGETSURFACEFORMATVK                                  nvOFGetSurfaceFormatVk;
+        PFNNVOFREGISTERRESOURCEVK                                  nvOFRegisterResourceVk;
+        PFNNVOFUNREGISTERRESOURCEVK                                nvOFUnregisterResourceVk;
+        PFNNVOFEXECUTEVK                                           nvOFExecuteVk;
+        PFNNVOFDESTROY                                             nvOFDestroy;
+        PFNNVOFGETLASTERROR                                        nvOFGetLastError;
+        PFNNVOFGETCAPS                                             nvOFGetCaps;
+    } NV_OF_VK_API_FUNCTION_LIST;
+
+    /**
+    * \brief ::NvOFAPICreateInstanceVk() API is the entry point to the NvOFAPI interface.
+    *
+    * ::NvOFAPICreateInstanceVk() API populates functionList with function pointers to the API routines implemented by the
+    * NvOFAPI interface.
+    *
+    * \return
+    * ::NV_OF_SUCCESS \n
+    * ::NV_OF_ERR_INVALID_VERSION \n
+    * ::NV_OF_ERR_INVALID_PTR \n
+    */
+
+	NV_OF_STATUS NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif

From b7fba65ebf6feb3ab765291dda6709daafe1d078 Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Sat, 12 Oct 2024 16:56:28 -0700
Subject: [PATCH] vkd3d-proton: Update interfaces from c9a3cb05

Signed-off-by: Liam Middlebrook <lmiddlebrook@nvidia.com>
---
 src/vkd3d-proton/vkd3d-proton_interfaces.h | 58 +++++++++++++++++++++-
 1 file changed, 57 insertions(+), 1 deletion(-)

diff --git a/src/vkd3d-proton/vkd3d-proton_interfaces.h b/src/vkd3d-proton/vkd3d-proton_interfaces.h
index 1ab71962..17670fcf 100644
--- a/src/vkd3d-proton/vkd3d-proton_interfaces.h
+++ b/src/vkd3d-proton/vkd3d-proton_interfaces.h
@@ -26,7 +26,8 @@
 enum D3D12_VK_EXTENSION : uint32_t {
     D3D12_VK_NVX_BINARY_IMPORT = 0x1,
     D3D12_VK_NVX_IMAGE_VIEW_HANDLE = 0x2,
-    D3D12_VK_NV_LOW_LATENCY_2 = 0x3
+    D3D12_VK_NV_LOW_LATENCY_2 = 0x3,
+    D3D12_VK_NV_OPTICAL_FLOW = 0x4
 };
 
 enum D3D12_OUT_OF_BAND_CQ_TYPE : uint32_t {
@@ -84,6 +85,59 @@ ID3D12DeviceExt : public IUnknown {
         D3D12_UAV_INFO * uav_info) = 0;
 };
 
+MIDL_INTERFACE("39da4e09-bd1c-4198-9fae-86bbe3be41fd")
+ID3D12DXVKInteropDevice : public IUnknown {
+    virtual HRESULT STDMETHODCALLTYPE GetDXGIAdapter(
+        REFIID iid,
+        void** object) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetInstanceExtensions(
+        UINT * extensionCount,
+        const char** extensions) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetDeviceExtensions(
+        UINT * extensionCount,
+        const char** extensions) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetDeviceFeatures(
+        const VkPhysicalDeviceFeatures2** features) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanHandles(
+        VkInstance * vk_instance,
+        VkPhysicalDevice * vk_physical_device,
+        VkDevice * vk_device) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanQueueInfo(
+        ID3D12CommandQueue * queue,
+        VkQueue * vkQueue,
+        UINT32 * vkFamily) = 0;
+
+    virtual void STDMETHODCALLTYPE GetVulkanImageLayout(
+        ID3D12Resource * resource,
+        D3D12_RESOURCE_STATES state,
+        VkImageLayout * layout) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanResourceInfo(
+        ID3D12Resource * resource,
+        UINT64 * handle,
+        UINT64 * offset) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE LockCommandQueue(
+        ID3D12CommandQueue * queue) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE UnlockCommandQueue(
+        ID3D12CommandQueue * queue) = 0;
+};
+MIDL_INTERFACE("902d8115-59eb-4406-9518-fe00f991ee65")
+ID3D12DXVKInteropDevice1 : public ID3D12DXVKInteropDevice {
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanResourceInfo1(ID3D12Resource * resource, UINT64 * vk_handle, UINT64 * buffer_offset, VkFormat * format);
+    virtual HRESULT STDMETHODCALLTYPE CreateInteropCommandQueue(const D3D12_COMMAND_QUEUE_DESC* pDesc, UINT32 vk_queue_family_index, ID3D12CommandQueue** ppQueue);
+    virtual HRESULT STDMETHODCALLTYPE CreateInteropCommandAllocator(D3D12_COMMAND_LIST_TYPE type, UINT32 vk_queue_family_index, ID3D12CommandAllocator * *ppAllocator);
+    virtual HRESULT STDMETHODCALLTYPE BeginVkCommandBufferInterop(ID3D12CommandList * pCmdList, VkCommandBuffer * pCommandBuffer);
+    virtual HRESULT STDMETHODCALLTYPE EndVkCommandBufferInterop(ID3D12CommandList * pCmdList);
+};
+
 MIDL_INTERFACE("77a86b09-2bea-4801-b89a-37648e104af1")
 ID3D12GraphicsCommandListExt : public IUnknown {
     virtual HRESULT STDMETHODCALLTYPE GetVulkanHandle(
@@ -120,6 +174,8 @@ ID3D12CommandQueueExt : public IUnknown {
 
 #ifndef _MSC_VER
 __CRT_UUID_DECL(ID3D12DeviceExt, 0x11ea7a1a, 0x0f6a, 0x49bf, 0xb6, 0x12, 0x3e, 0x30, 0xf8, 0xe2, 0x01, 0xdd);
+__CRT_UUID_DECL(ID3D12DXVKInteropDevice, 0x39da4e09, 0xbd1c, 0x4198, 0x9f, 0xae, 0x86, 0xbb, 0xe3, 0xbe, 0x41, 0xfd);
+__CRT_UUID_DECL(ID3D12DXVKInteropDevice1, 0x902d8115, 0x59eb, 0x4406, 0x95, 0x18, 0xfe, 0x00, 0xf9, 0x91, 0xee, 0x65);
 __CRT_UUID_DECL(ID3D12GraphicsCommandListExt, 0x77a86b09, 0x2bea, 0x4801, 0xb8, 0x9a, 0x37, 0x64, 0x8e, 0x10, 0x4a, 0xf1);
 __CRT_UUID_DECL(ID3D12GraphicsCommandListExt1, 0xd53b0028, 0xafb4, 0x4b65, 0xa4, 0xf1, 0x7b, 0x0d, 0xaa, 0xa6, 0x5b, 0x4f);
 __CRT_UUID_DECL(ID3D12CommandQueueExt, 0x40ed3f96, 0xe773, 0xe9bc, 0xfc, 0x0c, 0xe9, 0x55, 0x60, 0xc9, 0x9a, 0xd6);

From a13b0f5b88c4486110cff15b162de7d1dd12299e Mon Sep 17 00:00:00 2001
From: Liam Middlebrook <lmiddlebrook@nvidia.com>
Date: Sat, 12 Oct 2024 16:57:19 -0700
Subject: [PATCH] nvofapi: Introduce library

Introduce an implementation of the NVIDIA Optical Flow API layered on
top of VK_NV_optical_flow. This implementation covers the D3D12 and
Vulkan backends for NVOFAPI.

Signed-off-by: Liam Middlebrook <lmiddlebrook@nvidia.com>
---
 src/meson.build                     |  16 ++
 src/nvofapi/nvofapi.h               | 177 ++++++++++++++++++++++
 src/nvofapi/nvofapi_common.cpp      | 209 ++++++++++++++++++++++++++
 src/nvofapi/nvofapi_d3d12.cpp       | 181 ++++++++++++++++++++++
 src/nvofapi/nvofapi_entrypoints.cpp | 223 ++++++++++++++++++++++++++++
 src/nvofapi/nvofapi_vulkan.cpp      | 168 +++++++++++++++++++++
 6 files changed, 974 insertions(+)
 create mode 100644 src/nvofapi/nvofapi.h
 create mode 100644 src/nvofapi/nvofapi_common.cpp
 create mode 100644 src/nvofapi/nvofapi_d3d12.cpp
 create mode 100644 src/nvofapi/nvofapi_entrypoints.cpp
 create mode 100644 src/nvofapi/nvofapi_vulkan.cpp

diff --git a/src/meson.build b/src/meson.build
index 18b125bc..9d40fa1e 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -31,3 +31,19 @@ nvapi_dll = shared_library('nvapi'+target_suffix, [ nvapi_src, dxvk_nvapi_versio
   dependencies        : [ lib_dxgi, lib_d3d11, lib_version ],
   include_directories : [ nvapi_headers, vk_headers ],
   install             : true)
+
+nvofapi_src = files([
+  'util/util_string.cpp',
+  'util/util_env.cpp',
+  'util/util_log.cpp',
+  'nvofapi/nvofapi_common.cpp',
+  'nvofapi/nvofapi_d3d12.cpp',
+  'nvofapi/nvofapi_vulkan.cpp',
+  'nvofapi/nvofapi_entrypoints.cpp'
+])
+
+nvofapi_dll = shared_library('nvofapi'+target_suffix, [ nvofapi_src, dxvk_nvapi_version ],
+  name_prefix         : '',
+  dependencies        : [ lib_version ],
+  include_directories : [ nvapi_headers, vk_headers ],
+  install             : true)
diff --git a/src/nvofapi/nvofapi.h b/src/nvofapi/nvofapi.h
new file mode 100644
index 00000000..d74d028b
--- /dev/null
+++ b/src/nvofapi/nvofapi.h
@@ -0,0 +1,177 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "vkd3d-proton/vkd3d-proton_interfaces.h"
+
+#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+namespace nvofapi {
+    constexpr uint32_t CMDS_IN_FLIGHT = 1;
+    class NvOFInstance;
+    class NvOFImageVk;
+
+    class NvOFInstance {
+
+      protected:
+        VkInstance m_vkInstance;
+        VkPhysicalDevice m_vkPhysicalDevice;
+        VkDevice m_vkDevice;
+        VkOpticalFlowSessionNV m_vkOfaSession{};
+        PFN_vkGetInstanceProcAddr m_vkGetInstanceProcAddr{};
+        PFN_vkGetDeviceProcAddr m_vkGetDeviceProcAddr{};
+        PFN_vkCreateOpticalFlowSessionNV m_vkCreateOpticalFlowSessionNV{};
+        PFN_vkDestroyOpticalFlowSessionNV m_vkDestroyOpticalFlowSessionNV{};
+        PFN_vkCreateImageView m_vkCreateImageView{};
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+        PFN_vkBindOpticalFlowSessionImageNV m_vkBindOpticalFlowSessionImageNV{};
+        PFN_vkCmdOpticalFlowExecuteNV m_vkCmdOpticalFlowExecuteNV{};
+
+        PFN_vkGetPhysicalDeviceQueueFamilyProperties m_vkGetPhysicalDeviceQueueFamilyProperties;
+        HMODULE m_library;
+
+        uint32_t GetVkOFAQueue();
+
+      public:
+        VkDevice GetVkDevice() { return m_vkDevice; }
+        VkOpticalFlowSessionNV GetOfaSession() { return m_vkOfaSession; }
+
+        NvOFInstance(VkInstance vkInstance,
+            VkPhysicalDevice vkPhysicalDevice,
+            VkDevice vkDevice) : m_vkInstance(vkInstance),
+                                 m_vkPhysicalDevice(vkPhysicalDevice), m_vkDevice(vkDevice) {
+        }
+
+        NvOFInstance() {};
+        virtual ~NvOFInstance() {
+            m_vkDestroyOpticalFlowSessionNV(m_vkDevice, m_vkOfaSession, nullptr);
+            FreeLibrary(m_library);
+        }
+
+        NV_OF_STATUS getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size);
+
+        NV_OF_STATUS InitSession(const NV_OF_INIT_PARAMS* initParams);
+
+        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams);
+
+        NV_OF_STATUS BindImageToSession(NvOFImageVk* image, VkOpticalFlowSessionBindingPointNV bindingPoint);
+
+        NV_OF_STATUS RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf);
+    };
+
+    class NvOFImageVk {
+      private:
+        NvOFInstance* m_ofInstance;
+        VkImage m_image;
+        VkImageView m_imageView;
+        VkFormat m_format;
+        PFN_vkDestroyImageView m_vkDestroyImageView{};
+
+      public:
+        VkImageView ImageView() { return m_imageView; }
+        NvOFImageVk(NvOFInstance* ofInstance, VkImage image, VkFormat format) : m_ofInstance(ofInstance), m_image(image), m_format(format) {
+        }
+        ~NvOFImageVk() {
+            m_vkDestroyImageView(m_ofInstance->GetVkDevice(), m_imageView, nullptr);
+        }
+
+        bool Initialize(PFN_vkCreateImageView CreateImageView,
+            PFN_vkDestroyImageView DestroyImageView);
+    };
+
+    class NvOFInstanceVk : public NvOFInstance {
+      public:
+        NvOFInstanceVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice) : NvOFInstance(vkInstance, vkPhysicalDevice, vkDevice) {
+        }
+        virtual ~NvOFInstanceVk() {
+            // free cmdbuffers
+            m_vkFreeCommandBuffers(m_vkDevice, m_commandPool, 8, m_commandBuffers);
+            m_vkDestroyCommandPool(m_vkDevice, m_commandPool, nullptr);
+        }
+        bool Initialize();
+
+        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams);
+
+      private:
+        VkQueue m_queue;
+        VkCommandPool m_commandPool;
+        PFN_vkCreateCommandPool m_vkCreateCommandPool;
+        PFN_vkDestroyCommandPool m_vkDestroyCommandPool;
+        VkCommandBuffer m_commandBuffers[CMDS_IN_FLIGHT]; // eight ought to be more than
+                                                          // enough for anybody ;)
+
+        PFN_vkAllocateCommandBuffers m_vkAllocateCommandBuffers;
+        PFN_vkFreeCommandBuffers m_vkFreeCommandBuffers;
+
+        uint32_t m_cmdBufIndex = 0;
+        PFN_vkResetCommandBuffer m_vkResetCommandBuffer;
+        PFN_vkBeginCommandBuffer m_vkBeginCommandBuffer;
+        PFN_vkEndCommandBuffer m_vkEndCommandBuffer;
+
+        PFN_vkGetDeviceQueue m_vkGetDeviceQueue;
+        PFN_vkQueueSubmit2 m_vkQueueSubmit2{};
+    };
+
+    class NvOFInstanceD3D12 : public NvOFInstance {
+      private:
+        ID3D12DXVKInteropDevice1* m_device{};
+        ID3D12DeviceExt* m_deviceExt{};
+        ID3D12Device4* m_d3ddevice{};
+        ID3D12CommandQueue* m_commandQueue{};
+        ID3D12GraphicsCommandList* m_cmdList[CMDS_IN_FLIGHT]{};
+        uint32_t m_cmdListIndex = 0;
+        ID3D12CommandAllocator* m_cmdAllocator{};
+
+        uint32_t m_vkQueueFamilyIndex = 0;
+
+      public:
+        bool Initialize();
+        NvOFInstanceD3D12(ID3D12Device* pD3D12Device);
+        virtual ~NvOFInstanceD3D12() {
+            for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+                if (m_cmdList[i])
+                    m_cmdList[i]->Release();
+            }
+            if (m_cmdAllocator)
+                m_cmdAllocator->Release();
+
+            if (m_commandQueue)
+                m_commandQueue->Release();
+
+            if (m_deviceExt)
+                m_deviceExt->Release();
+
+            if (m_d3ddevice)
+                m_d3ddevice->Release();
+
+            if (m_device)
+                m_device->Release();
+        }
+
+        NV_OF_STATUS RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams);
+
+        NV_OF_STATUS Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams);
+    };
+}
diff --git a/src/nvofapi/nvofapi_common.cpp b/src/nvofapi/nvofapi_common.cpp
new file mode 100644
index 00000000..4a54cd41
--- /dev/null
+++ b/src/nvofapi/nvofapi_common.cpp
@@ -0,0 +1,209 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "util/util_log.h"
+#include "util/util_string.h"
+
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+#include "nvofapi.h"
+
+namespace nvofapi {
+
+    typedef struct NV_OF_PRIV_DATA {
+        uint32_t size;
+        uint32_t id;
+        void* data;
+    } NV_OF_PRIV_DATA;
+
+    typedef struct NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS {
+        NvOFGPUBufferHandle input[6];
+        NvOFGPUBufferHandle reference[6];
+        uint8_t reserved[100];
+    } NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS;
+
+    constexpr uint32_t NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS = 6;
+
+    uint32_t NvOFInstance::GetVkOFAQueue() {
+        uint32_t count = 0;
+        m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, nullptr);
+        VkQueueFamilyProperties* queueFamProps = (VkQueueFamilyProperties*)calloc(sizeof(VkQueueFamilyProperties), count);
+        m_vkGetPhysicalDeviceQueueFamilyProperties(m_vkPhysicalDevice, &count, queueFamProps);
+
+        for (int i = 0; i < count; i++) {
+            if (queueFamProps[i].queueFlags & VK_QUEUE_OPTICAL_FLOW_BIT_NV) {
+                free(queueFamProps);
+                return i;
+            }
+        }
+        free(queueFamProps);
+        return -1;
+    }
+
+    NV_OF_STATUS NvOFInstance::InitSession(const NV_OF_INIT_PARAMS* initParams) {
+        dxvk::log::info(
+            dxvk::str::format("OFSessionInit params:",
+                " width: ", initParams->width,
+                " height: ", initParams->height,
+                " outGrid: ", initParams->outGridSize,
+                " hintGrid: ", initParams->hintGridSize,
+                " mode: ", initParams->mode,
+                " perfLevel: ", initParams->perfLevel,
+                " enableExternalHints: ", initParams->enableExternalHints,
+                " enableOutputCost: ", initParams->enableOutputCost,
+                " hPrivData: ", initParams->hPrivData,
+                " enableRoi: ", initParams->enableRoi,
+                " predDirection: ", initParams->predDirection,
+                " enableGlobalFlow: ", initParams->enableGlobalFlow,
+                " inputBufferFormat: ", initParams->inputBufferFormat));
+
+        VkOpticalFlowSessionCreateInfoNV createInfo = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV};
+        createInfo.width = initParams->width;
+        createInfo.height = initParams->height;
+        createInfo.outputGridSize = VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV;
+
+        switch (initParams->perfLevel) {
+            case NV_OF_PERF_LEVEL_SLOW:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV;
+                break;
+            case NV_OF_PERF_LEVEL_MEDIUM:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV;
+                break;
+            case NV_OF_PERF_LEVEL_FAST:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV;
+                break;
+            default:
+                createInfo.performanceLevel = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV;
+                break;
+        }
+
+        switch (initParams->inputBufferFormat) {
+            case NV_OF_BUFFER_FORMAT_GRAYSCALE8:
+                createInfo.imageFormat = VK_FORMAT_R8_UNORM;
+                break;
+            case NV_OF_BUFFER_FORMAT_NV12:
+                createInfo.imageFormat = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
+                break;
+            case NV_OF_BUFFER_FORMAT_ABGR8:
+                createInfo.imageFormat = VK_FORMAT_B8G8R8A8_UNORM;
+                break;
+        }
+
+        // Need to get the size/id for the private data to pass it along to VK...
+        VkOpticalFlowSessionCreatePrivateDataInfoNV privData = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV};
+        privData.size = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->size;
+        privData.id = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->id;
+        privData.pPrivateData = ((NV_OF_PRIV_DATA*)initParams->hPrivData)->data;
+
+        createInfo.pNext = &privData;
+
+        auto ret = m_vkCreateOpticalFlowSessionNV(m_vkDevice, &createInfo, NULL, &m_vkOfaSession);
+
+        if (ret == VK_SUCCESS) {
+            return NV_OF_SUCCESS;
+        }
+
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NvOFInstance::BindImageToSession(NvOFImageVk* image, VkOpticalFlowSessionBindingPointNV bindingPoint) {
+        VkImageLayout layout = VK_IMAGE_LAYOUT_GENERAL;
+
+        if (!image)
+            return NV_OF_ERR_GENERIC;
+
+        auto ret = m_vkBindOpticalFlowSessionImageNV(m_vkDevice,
+            m_vkOfaSession,
+            bindingPoint,
+            image->ImageView(),
+            layout);
+        if (ret != VK_SUCCESS) {
+            return NV_OF_ERR_GENERIC;
+        }
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NvOFInstance::getCaps(NV_OF_CAPS param, uint32_t* capsVal, uint32_t* size) {
+        if (param == NV_OF_CAPS_SUPPORTED_OUTPUT_GRID_SIZES) {
+            *size = 1;
+            if (capsVal) {
+                *capsVal = NV_OF_OUTPUT_VECTOR_GRID_SIZE_4;
+            }
+
+            // XXX[ljm] query VkPhysicalDevice for actual support
+            return NV_OF_SUCCESS;
+        }
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NvOFInstance::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        NvOFImageVk* nvOFImage = new NvOFImageVk(this, registerParams->image, registerParams->format);
+        nvOFImage->Initialize(m_vkCreateImageView, m_vkDestroyImageView);
+        *registerParams->hOFGpuBuffer = reinterpret_cast<NvOFGPUBufferHandle>(nvOFImage);
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NvOFInstance::RecordCmdBuf(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams, VkCommandBuffer cmdBuf) {
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(inParams->inputFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(inParams->referenceFrame), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->outputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->outputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->bwdOutputBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->bwdOutputCostBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV);
+        BindImageToSession(reinterpret_cast<NvOFImageVk*>(outParams->globalFlowBuffer), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV);
+        // Support INPUT_MIPS execute priv data
+        if (((NV_OF_PRIV_DATA*)inParams->hPrivData)->id == NV_OF_EXECUTE_PRIV_DATA_ID_INPUT_MIPS) {
+            NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS* mipData = ((NV_OF_EXECUTE_PRIV_DATA_INPUT_MIPS*)((NV_OF_PRIV_DATA*)inParams->hPrivData)->data);
+            for (int i = 0; i < 6; i++) {
+                if (mipData->input[i] && mipData->reference[i]) {
+                    BindImageToSession(reinterpret_cast<NvOFImageVk*>(mipData->input[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV);
+                    BindImageToSession(reinterpret_cast<NvOFImageVk*>(mipData->reference[i]), VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV);
+                }
+            }
+        }
+        VkRect2D* regions;
+
+        if (inParams->numRois) {
+            regions = (VkRect2D*)calloc(sizeof(VkRect2D), inParams->numRois);
+            for (int i = 0; i < inParams->numRois; i++) {
+                regions[i].offset.x = inParams->roiData[i].start_x;
+                regions[i].offset.y = inParams->roiData[i].start_y;
+                regions[i].extent.width = inParams->roiData[i].width;
+                regions[i].extent.height = inParams->roiData[i].height;
+            }
+        }
+
+        VkOpticalFlowExecuteInfoNV ofaExecuteInfo = {VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV};
+        ofaExecuteInfo.regionCount = inParams->numRois;
+        ofaExecuteInfo.pRegions = regions;
+
+        if (inParams->disableTemporalHints) {
+            ofaExecuteInfo.flags |= VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV;
+        }
+
+        m_vkCmdOpticalFlowExecuteNV(cmdBuf, m_vkOfaSession, &ofaExecuteInfo);
+
+        free(regions);
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi/nvofapi_d3d12.cpp b/src/nvofapi/nvofapi_d3d12.cpp
new file mode 100644
index 00000000..f224ea05
--- /dev/null
+++ b/src/nvofapi/nvofapi_d3d12.cpp
@@ -0,0 +1,181 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <cassert>
+
+#include "util/util_log.h"
+#include "util/util_string.h"
+
+#include "vkd3d-proton/vkd3d-proton_interfaces.h"
+#include "../inc/nvofapi/nvOpticalFlowD3D12.h"
+
+#include "nvofapi.h"
+
+namespace nvofapi {
+
+    NvOFInstanceD3D12::NvOFInstanceD3D12(ID3D12Device* pD3D12Device) {
+        // Query for the extension interface
+        // Grab the vk triad
+        HRESULT status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_device));
+
+        if (S_OK != status) {
+            throw std::invalid_argument("Failed to query interface for m_device");
+        }
+
+        m_device->GetVulkanHandles(&m_vkInstance,
+            &m_vkPhysicalDevice,
+            &m_vkDevice);
+
+        status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_d3ddevice));
+
+        if (S_OK != status) {
+            throw std::invalid_argument("Failed to query interface for m_d3ddevice");
+        }
+
+        status = pD3D12Device->QueryInterface(IID_PPV_ARGS(&m_deviceExt));
+
+        if (S_OK != status) {
+            throw std::invalid_argument("Failed to query interface for m_deviceExt");
+        }
+    }
+
+    bool NvOFInstanceD3D12::Initialize() {
+        m_library = LoadLibraryA("winevulkan.dll");
+        if (!m_library) {
+            return false;
+        }
+
+        // Confirm that OPTICAL_FLOW extension is available
+        if (!m_deviceExt->GetExtensionSupport(D3D12_VK_NV_OPTICAL_FLOW)) {
+            dxvk::log::info("Missing VK_NV_optical_flow extension!");
+            return false;
+        }
+
+        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)GetProcAddress(m_library, "vkGetInstanceProcAddr");
+        m_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetDeviceProcAddr");
+        m_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
+
+        m_vkCreateImageView = (PFN_vkCreateImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateImageView");
+        m_vkDestroyImageView = (PFN_vkDestroyImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyImageView");
+
+        // Populate the optical flow related info here
+        // fail to create if optical flow extension is unsupported
+        m_vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateOpticalFlowSessionNV");
+        m_vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyOpticalFlowSessionNV");
+        m_vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkBindOpticalFlowSessionImageNV");
+        m_vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCmdOpticalFlowExecuteNV");
+
+        // Get the OFA queue
+        m_vkQueueFamilyIndex = GetVkOFAQueue();
+
+        D3D12_COMMAND_QUEUE_DESC desc{};
+        if (m_device->CreateInteropCommandQueue(&desc, m_vkQueueFamilyIndex, &m_commandQueue)
+            != S_OK) {
+            return false;
+        }
+        if (m_device->CreateInteropCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, m_vkQueueFamilyIndex, &m_cmdAllocator)
+            != S_OK) {
+            return false;
+        }
+        for (int i = 0; i < CMDS_IN_FLIGHT; i++) {
+            if (m_d3ddevice->CreateCommandList1(0, D3D12_COMMAND_LIST_TYPE_DIRECT, (D3D12_COMMAND_LIST_FLAGS)0, IID_PPV_ARGS(&m_cmdList[i]))
+                != S_OK) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    NV_OF_STATUS NvOFInstanceD3D12::RegisterBuffer(const NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        NV_OF_REGISTER_RESOURCE_PARAMS_VK vkParams{};
+        dxvk::log::info(
+            dxvk::str::format("RegisterBuffer DX: resource: ",
+                registerParams->resource, " inputFencePoint: ",
+                registerParams->inputFencePoint.fence, " ouputFencePoint: ",
+                registerParams->outputFencePoint.fence));
+        // Convert D3D12 params to VK params
+        //
+        // ID3D12Resource -> VK Image / VkFormat pair
+        vkParams.hOFGpuBuffer = registerParams->hOFGpuBuffer;
+        uint64_t offset;
+        m_device->GetVulkanResourceInfo1(registerParams->resource, (UINT64*)&vkParams.image, &offset, &vkParams.format);
+
+        // ID3D12 fence to timeline semaphore
+        // no inputFencePoint/outputFencePoint equivalents for VK, leaving as
+        // no-op :(
+        assert(registerParams->inputFencePoint.fence == nullptr);
+        assert(registerParams->inputFencePoint.value == 0);
+        assert(registerParams->outputFencePoint.fence == nullptr);
+        assert(registerParams->outputFencePoint.value == 0);
+        return ((NvOFInstance*)this)->RegisterBuffer(&vkParams);
+    }
+
+    NV_OF_STATUS NvOFInstanceD3D12::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* outParams) {
+        // Convert the D3D12 parameters to VK parameters
+        NV_OF_EXECUTE_INPUT_PARAMS_VK vkInputParams{};
+        NV_OF_EXECUTE_OUTPUT_PARAMS_VK vkOutputParams{};
+
+        vkInputParams.inputFrame = inParams->inputFrame;
+        vkInputParams.referenceFrame = inParams->referenceFrame;
+        vkInputParams.externalHints = inParams->externalHints;
+        vkInputParams.disableTemporalHints = inParams->disableTemporalHints;
+        vkInputParams.hPrivData = inParams->hPrivData;
+        vkInputParams.numRois = inParams->numRois;
+        vkInputParams.roiData = inParams->roiData;
+
+        vkOutputParams.outputBuffer = outParams->outputBuffer;
+        vkOutputParams.outputCostBuffer = outParams->outputCostBuffer;
+        vkOutputParams.hPrivData = outParams->hPrivData;
+        vkOutputParams.bwdOutputBuffer = outParams->bwdOutputBuffer;
+        vkOutputParams.bwdOutputCostBuffer = outParams->bwdOutputCostBuffer;
+        vkOutputParams.globalFlowBuffer = outParams->globalFlowBuffer;
+
+        // Use vkd3d-proton's interop functionality to grab a VkCommandBuffer
+        // that we record our commands into. Work submission and syncrhonization
+        // happens using D3D12.
+        m_cmdList[m_cmdListIndex]->Reset(m_cmdAllocator, nullptr);
+
+        for (int i = 0; i < inParams->numFencePoints; i++) {
+            m_commandQueue->Wait(inParams->fencePoint[i].fence, inParams->fencePoint[i].value);
+        }
+
+        VkCommandBuffer vkCmdBuf;
+        m_device->BeginVkCommandBufferInterop(m_cmdList[m_cmdListIndex], &vkCmdBuf);
+
+        this->RecordCmdBuf(&vkInputParams, &vkOutputParams, vkCmdBuf);
+
+        m_device->EndVkCommandBufferInterop(m_cmdList[m_cmdListIndex]);
+        m_cmdList[m_cmdListIndex]->Close();
+
+        m_commandQueue->ExecuteCommandLists(1, (ID3D12CommandList**)&m_cmdList[m_cmdListIndex]);
+
+        m_commandQueue->Signal(outParams->fencePoint->fence, outParams->fencePoint->value);
+
+        m_cmdListIndex++;
+        if (m_cmdListIndex >= CMDS_IN_FLIGHT)
+            m_cmdListIndex = 0;
+
+        return NV_OF_SUCCESS;
+    }
+
+}
diff --git a/src/nvofapi/nvofapi_entrypoints.cpp b/src/nvofapi/nvofapi_entrypoints.cpp
new file mode 100644
index 00000000..65eb9144
--- /dev/null
+++ b/src/nvofapi/nvofapi_entrypoints.cpp
@@ -0,0 +1,223 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "nvofapi.h"
+
+#include "util/util_env.h"
+#include "util/util_log.h"
+#include "util/util_string.h"
+#include "../version.h"
+
+extern "C" {
+
+    // Common entrypoints
+    NV_OF_STATUS NVOFAPI OFSessionInit(NvOFHandle hOf, const NV_OF_INIT_PARAMS* initParams) {
+        dxvk::log::info("OFSessionInit called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("OFSessionInit failed!"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        return nvOF->InitSession(initParams);
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionDestroy(NvOFHandle hOf) {
+        dxvk::log::info("OFSessionDestroy called");
+        nvofapi::NvOFInstance* nvOF = reinterpret_cast<nvofapi::NvOFInstance*>(hOf);
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("OFSessionDestroy failed!"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        delete nvOF;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionGetLastError(NvOFHandle hOf, char lastError[], uint32_t* size) {
+        dxvk::log::info("OFSessionGetLastError called");
+        dxvk::log::info(dxvk::str::format("OFSessionGetLastError failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI OFSessionGetCaps(NvOFHandle hOf, NV_OF_CAPS capsParam, uint32_t* capsVal, uint32_t* size) {
+        dxvk::log::info("OFSessionGetCaps called");
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+
+        return nvOF->getCaps(capsParam, capsVal, size);
+    }
+
+    // D3D12 entrypoints
+    NV_OF_STATUS NVOFAPI CreateOpticalFlowD3D12(ID3D12Device* pD3D12Device, NvOFHandle* hOFInstance) {
+        dxvk::log::info("CreateOpticalFlowD3D12 called");
+
+        nvofapi::NvOFInstanceD3D12* nvOF = nullptr;
+        try {
+            nvOF = new nvofapi::NvOFInstanceD3D12(pD3D12Device);
+        } catch (std::exception e) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 exception, %s", e.what()));
+        }
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed allocation"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        if (!nvOF->Initialize()) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 failed creation"));
+            delete nvOF;
+            return NV_OF_ERR_GENERIC;
+        }
+
+        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
+        dxvk::log::info(dxvk::str::format("CreateOpticalFlowD3D12 end"));
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
+        dxvk::log::info("GetSurfaceFormatCountD3D12 called");
+        *pCount = 1;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatD3D12(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, DXGI_FORMAT* const pFormat) {
+        dxvk::log::info("GetSurfaceFormatD3D12 called");
+        if (bufferUsage == NV_OF_BUFFER_USAGE_INPUT)
+            *pFormat = DXGI_FORMAT_R8_UNORM;
+        else
+            *pFormat = DXGI_FORMAT_R16G16_SINT;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI RegisterResourceD3D12(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        dxvk::log::info("RegisterResourceD3D12 called");
+        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+
+        return nvOF->RegisterBuffer(registerParams);
+    }
+
+    NV_OF_STATUS NVOFAPI UnregisterResourceD3D12(NV_OF_UNREGISTER_RESOURCE_PARAMS_D3D12* registerParams) {
+        dxvk::log::info("UnregisterResourceD3D12 called");
+        nvofapi::NvOFImageVk* nvRes = reinterpret_cast<nvofapi::NvOFImageVk*>(registerParams->hOFGpuBuffer);
+        delete nvRes;
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI ExecuteD3D12(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_D3D12* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_D3D12* executeOutParams) {
+        dxvk::log::info("ExecuteD3D12 called");
+        dxvk::log::info(dxvk::str::format("handle: %p", hOf));
+        nvofapi::NvOFInstanceD3D12* nvOF = reinterpret_cast<nvofapi::NvOFInstanceD3D12*>(hOf);
+
+        return nvOF->Execute(executeInParams, executeOutParams);
+    }
+
+    // VK entrypoints
+    NV_OF_STATUS NVOFAPI CreateOpticalFlowVk(VkInstance vkInstance, VkPhysicalDevice vkPhysicalDevice, VkDevice vkDevice, NvOFHandle* hOFInstance) {
+        dxvk::log::info("CreateOpticalFlowVk called");
+        nvofapi::NvOFInstanceVk* nvOF = new nvofapi::NvOFInstanceVk(vkInstance, vkPhysicalDevice, vkDevice);
+
+        if (!nvOF) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed allocation"));
+            return NV_OF_ERR_GENERIC;
+        }
+
+        if (!nvOF->Initialize()) {
+            dxvk::log::info(dxvk::str::format("CreateOpticalFlowVK failed creation"));
+            delete nvOF;
+            return NV_OF_ERR_GENERIC;
+        }
+
+        *hOFInstance = reinterpret_cast<NvOFHandle>(nvOF);
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatCountVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, uint32_t* const pCount) {
+        dxvk::log::info("GetSurfaceFormatCountVk called");
+        dxvk::log::info(dxvk::str::format("GetSurfaceFormatCountVk failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI GetSurfaceFormatVk(NvOFHandle hOf, const NV_OF_BUFFER_USAGE bufferUsage, const NV_OF_MODE ofMode, VkFormat* const pFormat) {
+        dxvk::log::info("GetSurfaceFormatVk called");
+        dxvk::log::info(dxvk::str::format("GetSurfaceFormatVk failed!"));
+        return NV_OF_ERR_GENERIC;
+    }
+
+    NV_OF_STATUS NVOFAPI RegisterResourceVk(NvOFHandle hOf, NV_OF_REGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        dxvk::log::info("RegisterResourceVk called");
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+        return nvOF->RegisterBuffer(registerParams);
+    }
+
+    NV_OF_STATUS NVOFAPI UnregisterResourceVk(NV_OF_UNREGISTER_RESOURCE_PARAMS_VK* registerParams) {
+        dxvk::log::info("UnregisterResourceVk called");
+        nvofapi::NvOFImageVk* nvRes = reinterpret_cast<nvofapi::NvOFImageVk*>(registerParams->hOFGpuBuffer);
+        delete nvRes;
+        return NV_OF_SUCCESS;
+    }
+    NV_OF_STATUS NVOFAPI ExecuteVk(NvOFHandle hOf, const NV_OF_EXECUTE_INPUT_PARAMS_VK* executeInParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* executeOutParams) {
+        nvofapi::NvOFInstanceVk* nvOF = reinterpret_cast<nvofapi::NvOFInstanceVk*>(hOf);
+
+        return nvOF->Execute(executeInParams, executeOutParams);
+    }
+
+    // ETBLs
+    NV_OF_STATUS __cdecl NvOFAPICreateInstanceVk(uint32_t apiVer, NV_OF_VK_API_FUNCTION_LIST* functionList) {
+        constexpr auto n = __func__;
+
+        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") VK"));
+
+        functionList->nvCreateOpticalFlowVk = CreateOpticalFlowVk;
+        functionList->nvOFInit = OFSessionInit;
+        functionList->nvOFGetSurfaceFormatCountVk = GetSurfaceFormatCountVk;
+        functionList->nvOFGetSurfaceFormatVk = GetSurfaceFormatVk;
+        functionList->nvOFRegisterResourceVk = RegisterResourceVk;
+        functionList->nvOFUnregisterResourceVk = UnregisterResourceVk;
+        functionList->nvOFExecuteVk = ExecuteVk;
+        functionList->nvOFDestroy = OFSessionDestroy;
+        functionList->nvOFGetLastError = OFSessionGetLastError;
+        functionList->nvOFGetCaps = OFSessionGetCaps;
+
+        return NV_OF_SUCCESS;
+    }
+
+    NV_OF_STATUS __stdcall NvOFAPICreateInstanceD3D12(uint32_t apiVer, NV_OF_D3D12_API_FUNCTION_LIST* functionList) {
+        constexpr auto n = __func__;
+
+        dxvk::log::info(dxvk::str::format("DXVK-NVOFAPI ", DXVK_NVAPI_VERSION, " (", dxvk::env::getExecutableName(), ") D3D12"));
+
+        functionList->nvCreateOpticalFlowD3D12 = CreateOpticalFlowD3D12;
+        functionList->nvOFInit = OFSessionInit;
+        functionList->nvOFGetSurfaceFormatCountD3D12 = GetSurfaceFormatCountD3D12;
+        functionList->nvOFGetSurfaceFormatD3D12 = GetSurfaceFormatD3D12;
+        functionList->nvOFRegisterResourceD3D12 = RegisterResourceD3D12;
+        functionList->nvOFUnregisterResourceD3D12 = UnregisterResourceD3D12;
+        functionList->nvOFExecuteD3D12 = ExecuteD3D12;
+        functionList->nvOFDestroy = OFSessionDestroy;
+        functionList->nvOFGetLastError = OFSessionGetLastError;
+        functionList->nvOFGetCaps = OFSessionGetCaps;
+
+        return NV_OF_SUCCESS;
+    }
+}
diff --git a/src/nvofapi/nvofapi_vulkan.cpp b/src/nvofapi/nvofapi_vulkan.cpp
new file mode 100644
index 00000000..308ccad4
--- /dev/null
+++ b/src/nvofapi/nvofapi_vulkan.cpp
@@ -0,0 +1,168 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+ * SPDX-License-Identifier: MIT
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "util/util_log.h"
+#include "util/util_string.h"
+
+#include "../inc/nvofapi/nvOpticalFlowVulkan.h"
+
+#include "nvofapi.h"
+
+namespace nvofapi {
+
+    bool NvOFInstanceVk::Initialize() {
+        m_library = LoadLibraryA("winevulkan.dll");
+        if (!m_library) {
+            return false;
+        }
+
+        m_vkGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)GetProcAddress(m_library, "vkGetInstanceProcAddr");
+        m_vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetDeviceProcAddr");
+        m_vkGetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)m_vkGetInstanceProcAddr(m_vkInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
+
+        m_vkCreateImageView = (PFN_vkCreateImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateImageView");
+        m_vkDestroyImageView = (PFN_vkDestroyImageView)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyImageView");
+
+        m_vkGetDeviceQueue = (PFN_vkGetDeviceQueue)m_vkGetDeviceProcAddr(m_vkDevice, "vkGetDeviceQueue");
+        m_vkCreateCommandPool = (PFN_vkCreateCommandPool)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateCommandPool");
+        m_vkDestroyCommandPool = (PFN_vkDestroyCommandPool)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyCommandPool");
+        m_vkAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)m_vkGetDeviceProcAddr(m_vkDevice, "vkAllocateCommandBuffers");
+        m_vkQueueSubmit2 = (PFN_vkQueueSubmit2)m_vkGetDeviceProcAddr(m_vkDevice, "vkQueueSubmit2");
+
+        m_vkResetCommandBuffer = (PFN_vkResetCommandBuffer)m_vkGetDeviceProcAddr(m_vkDevice, "vkResetCommandBuffer");
+        m_vkBeginCommandBuffer = (PFN_vkBeginCommandBuffer)m_vkGetDeviceProcAddr(m_vkDevice, "vkBeginCommandBuffer");
+        m_vkEndCommandBuffer = (PFN_vkEndCommandBuffer)m_vkGetDeviceProcAddr(m_vkDevice, "vkEndCommandBuffer");
+
+        // Get NvapiAdapter from the vkPhysicalDevice
+        // Populate the optical flow related info here
+        // fail to create if optical flow extension is unsupported
+        m_vkCreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCreateOpticalFlowSessionNV");
+        m_vkDestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkDestroyOpticalFlowSessionNV");
+        m_vkBindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkBindOpticalFlowSessionImageNV");
+        m_vkCmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)m_vkGetDeviceProcAddr(m_vkDevice, "vkCmdOpticalFlowExecuteNV");
+
+        // Get the OFA queue
+        VkCommandPoolCreateInfo createInfo = {VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO};
+        createInfo.queueFamilyIndex = GetVkOFAQueue();
+        m_vkGetDeviceQueue(m_vkDevice, createInfo.queueFamilyIndex, 0, &m_queue);
+
+        if (m_vkCreateCommandPool(m_vkDevice, &createInfo, NULL, &m_commandPool)
+            != VK_SUCCESS) {
+            return false;
+        }
+
+        // ALlocate command buffers
+        VkCommandBufferAllocateInfo allocInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO};
+        allocInfo.commandPool = m_commandPool;
+        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
+        allocInfo.commandBufferCount = CMDS_IN_FLIGHT; // more than enough for anybody ;)
+        if (m_vkAllocateCommandBuffers(m_vkDevice, &allocInfo, m_commandBuffers)
+            != VK_SUCCESS) {
+            return false;
+        }
+
+        return true;
+    }
+
+    bool NvOFImageVk::Initialize(PFN_vkCreateImageView fpCreateImageView,
+        PFN_vkDestroyImageView fpDestroyImageView) {
+        m_vkDestroyImageView = fpDestroyImageView;
+        VkOpticalFlowSessionBindingPointNV bindingPoint;
+        VkImageViewCreateInfo viewInfo = {VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO};
+        viewInfo.image = m_image;
+        viewInfo.format = m_format;
+
+        // XXX[ljm] remaining or 1???
+        viewInfo.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, VK_REMAINING_MIP_LEVELS, 0, VK_REMAINING_ARRAY_LAYERS};
+        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
+        viewInfo.flags = 0;
+
+        auto ret = fpCreateImageView(m_ofInstance->GetVkDevice(), &viewInfo, NULL, &m_imageView);
+        if (ret != VK_SUCCESS) {
+            return false;
+        }
+        return true;
+    }
+
+    NV_OF_STATUS NvOFInstanceVk::Execute(const NV_OF_EXECUTE_INPUT_PARAMS_VK* inParams, NV_OF_EXECUTE_OUTPUT_PARAMS_VK* outParams) {
+        dxvk::log::info(
+            dxvk::str::format("OFExecuteVK params:",
+                " inputFrame: ", inParams->inputFrame,
+                " referenceFrame: ", inParams->referenceFrame,
+                " externalHints: ", inParams->externalHints,
+                " disableTemporalHints: ", inParams->disableTemporalHints,
+                " hPrivData: ", inParams->hPrivData,
+                " numRois: ", inParams->numRois,
+                " roiData: ", inParams->roiData,
+                " numWaitSync: ", inParams->numWaitSyncs,
+                " pWaitSyncs: ", inParams->pWaitSyncs));
+
+        VkSemaphoreSubmitInfo* waitSyncs = nullptr;
+
+        if (inParams->numWaitSyncs) {
+            waitSyncs = (VkSemaphoreSubmitInfo*)calloc(sizeof(VkSemaphoreSubmitInfo), inParams->numWaitSyncs);
+            for (int i = 0; i < inParams->numWaitSyncs; i++) {
+                waitSyncs[i].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
+                waitSyncs[i].semaphore = inParams->pWaitSyncs[i].semaphore;
+                waitSyncs[i].value = inParams->pWaitSyncs[i].value;
+                waitSyncs[i].stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
+            }
+        }
+
+        VkSemaphoreSubmitInfo signalSync = {VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO};
+        if (outParams->pSignalSync) {
+            signalSync.semaphore = outParams->pSignalSync->semaphore;
+            signalSync.value = outParams->pSignalSync->value;
+            signalSync.stageMask = VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV;
+        }
+
+        VkCommandBufferSubmitInfo cmdbufInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO};
+        cmdbufInfo.commandBuffer = m_commandBuffers[m_cmdBufIndex];
+        cmdbufInfo.deviceMask = 1;
+
+        VkCommandBufferBeginInfo begInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
+        m_vkResetCommandBuffer(m_commandBuffers[m_cmdBufIndex], 0);
+        m_vkBeginCommandBuffer(m_commandBuffers[m_cmdBufIndex], &begInfo);
+
+        RecordCmdBuf(inParams, outParams, m_commandBuffers[m_cmdBufIndex]);
+
+        m_vkEndCommandBuffer(m_commandBuffers[m_cmdBufIndex]);
+
+        VkSubmitInfo2 submit = {VK_STRUCTURE_TYPE_SUBMIT_INFO_2};
+        submit.waitSemaphoreInfoCount = inParams->numWaitSyncs;
+        submit.pWaitSemaphoreInfos = waitSyncs;
+        submit.commandBufferInfoCount = 1;
+        submit.pCommandBufferInfos = &cmdbufInfo;
+        submit.signalSemaphoreInfoCount = (outParams->pSignalSync) ? 1 : 0;
+        submit.pSignalSemaphoreInfos = &signalSync;
+
+        m_vkQueueSubmit2(m_queue, 1, &submit, VK_NULL_HANDLE);
+
+        free(waitSyncs);
+
+        m_cmdBufIndex++;
+        if (m_cmdBufIndex >= CMDS_IN_FLIGHT)
+            m_cmdBufIndex = 0;
+        return NV_OF_SUCCESS;
+    }
+}
