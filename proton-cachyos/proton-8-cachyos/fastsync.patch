commit 8a6a58a3d160b32f9d83e8462413a35b559efe42
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 11:56:25 2024 +1000

    server: add an object operation to retrieve a fast synchronization object.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/async.c b/server/async.c
index 91f0d87f9df..1ccf77d396a 100644
--- a/server/async.c
+++ b/server/async.c
@@ -91,6 +91,7 @@ static const struct object_ops async_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     async_destroy              /* destroy */
 };
@@ -692,6 +693,7 @@ static const struct object_ops iosb_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     iosb_destroy              /* destroy */
 };
diff --git a/server/atom.c b/server/atom.c
index 6b95a546597..56916392752 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -93,6 +93,7 @@ static const struct object_ops atom_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     atom_table_destroy            /* destroy */
 };
diff --git a/server/change.c b/server/change.c
index 9ffa8ab694f..f0f3f27dfe5 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,6 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/clipboard.c b/server/clipboard.c
index f24924eafa5..a45a71e43bd 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -90,6 +90,7 @@ static const struct object_ops clipboard_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     clipboard_destroy             /* destroy */
 };
diff --git a/server/completion.c b/server/completion.c
index 3ed7b2ff2a3..1dbce63d045 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -104,6 +104,7 @@ static const struct object_ops completion_wait_ops =
     NULL,                           /* unlink_name */
     no_open_file,                   /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_fast_sync,               /* get_fast_sync */
     no_close_handle,                /* close_handle */
     completion_wait_destroy         /* destroy */
 };
@@ -113,6 +114,7 @@ static int completion_add_queue( struct object *obj, struct wait_queue_entry *en
 static void completion_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int completion_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int completion_get_fsync_idx( struct object *obj, enum fsync_type *type );
+static struct fast_sync *completion_get_fast_sync ( struct object *obj );
 static void completion_destroy( struct object * );
 
 static const struct object_ops completion_ops =
@@ -137,6 +139,7 @@ static const struct object_ops completion_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    completion_get_fast_sync,  /* get_fast_sync */
     no_close_handle,           /* close_handle */
     completion_destroy         /* destroy */
 };
@@ -254,6 +257,14 @@ static unsigned int completion_get_fsync_idx( struct object *obj, enum fsync_typ
     return completion->wait->obj.ops->get_fsync_idx( &completion->wait->obj, type );
 }
 
+static struct fast_sync *completion_get_fast_sync ( struct object *obj )
+{
+    struct completion *completion = (struct completion*)obj;
+
+    assert(obj->ops == &completion_ops);
+    return completion->wait->obj.ops->get_fast_sync( &completion->wait->obj );
+}
+
 static void completion_destroy( struct object *obj )
 {
     struct completion *completion = (struct completion *)obj;
diff --git a/server/console.c b/server/console.c
index 00c09d1cc01..4dc74d3cb01 100644
--- a/server/console.c
+++ b/server/console.c
@@ -97,6 +97,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -180,6 +181,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -251,6 +253,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* unlink_name */
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
@@ -302,6 +305,7 @@ static const struct object_ops console_device_ops =
     default_unlink_name,              /* unlink_name */
     console_device_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     no_destroy                        /* destroy */
 };
@@ -341,6 +345,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -400,6 +405,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -460,6 +466,7 @@ static const struct object_ops console_connection_ops =
     default_unlink_name,              /* unlink_name */
     console_connection_open_file,     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     console_connection_close_handle,  /* close_handle */
     console_connection_destroy        /* destroy */
 };
diff --git a/server/debugger.c b/server/debugger.c
index b0cd35604d2..fe123b0d60e 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -100,6 +100,7 @@ static const struct object_ops debug_event_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     debug_event_destroy            /* destroy */
 };
@@ -130,6 +131,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 7e9911efb6a..a5d30941258 100644
--- a/server/device.c
+++ b/server/device.c
@@ -82,6 +82,7 @@ static const struct object_ops irp_call_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     irp_call_destroy                  /* destroy */
 };
@@ -128,6 +129,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -187,6 +189,7 @@ static const struct object_ops device_ops =
     default_unlink_name,              /* unlink_name */
     device_open_file,                 /* open_file */
     device_get_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     device_destroy                    /* destroy */
 };
@@ -241,6 +244,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/directory.c b/server/directory.c
index 878941cddbf..cd649103db6 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -84,6 +84,7 @@ static const struct object_ops object_type_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     no_destroy                    /* destroy */
 };
@@ -136,6 +137,7 @@ static const struct object_ops directory_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     directory_destroy             /* destroy */
 };
diff --git a/server/esync.c b/server/esync.c
index a5164435ed6..66e074d86bd 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -143,6 +143,7 @@ const struct object_ops esync_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     esync_destroy              /* destroy */
 };
diff --git a/server/event.c b/server/event.c
index b93a9960ad2..5f4f2125f9c 100644
--- a/server/event.c
+++ b/server/event.c
@@ -93,6 +93,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -142,6 +143,7 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
+    no_get_fast_sync,            /* get_fast_sync */
     no_close_handle,             /* close_handle */
     no_destroy                   /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index cb7f67a4863..7d42c2b54d3 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -224,6 +224,7 @@ static const struct object_ops fd_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     fd_destroy                /* destroy */
 };
@@ -267,6 +268,7 @@ static const struct object_ops device_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     device_destroy            /* destroy */
 };
@@ -309,6 +311,7 @@ static const struct object_ops inode_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     inode_destroy             /* destroy */
 };
@@ -353,6 +356,7 @@ static const struct object_ops file_lock_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/file.c b/server/file.c
index 6da354af245..3968e6441e4 100644
--- a/server/file.c
+++ b/server/file.c
@@ -137,6 +137,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/fsync.c b/server/fsync.c
index dc50aa0a1f3..d401f9d3fda 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -164,6 +164,7 @@ const struct object_ops fsync_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     fsync_destroy              /* destroy */
 };
diff --git a/server/handle.c b/server/handle.c
index 48b5d8101bb..9c049a2119c 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -140,6 +140,7 @@ static const struct object_ops handle_table_ops =
     NULL,                            /* unlink_name */
     no_open_file,                    /* open_file */
     no_kernel_obj_list,              /* get_kernel_obj_list */
+    no_get_fast_sync,                /* get_fast_sync */
     no_close_handle,                 /* close_handle */
     handle_table_destroy             /* destroy */
 };
diff --git a/server/hook.c b/server/hook.c
index 24eb27434db..68e1301ab88 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -94,6 +94,7 @@ static const struct object_ops hook_table_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     hook_table_destroy            /* destroy */
 };
diff --git a/server/mailslot.c b/server/mailslot.c
index 41fb020aaf0..0c7be874cfb 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -88,6 +88,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -149,6 +150,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     mail_writer_destroy         /* destroy */
 };
@@ -214,6 +216,7 @@ static const struct object_ops mailslot_device_ops =
     default_unlink_name,            /* unlink_name */
     mailslot_device_open_file,      /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
+    no_get_fast_sync,               /* get_fast_sync */
     no_close_handle,                /* close_handle */
     mailslot_device_destroy         /* destroy */
 };
@@ -246,6 +249,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
+    no_get_fast_sync,                       /* get_fast_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/mapping.c b/server/mapping.c
index 67896165048..a2093a4403a 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -82,6 +82,7 @@ static const struct object_ops ranges_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     ranges_destroy             /* destroy */
 };
@@ -120,6 +121,7 @@ static const struct object_ops shared_map_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     shared_map_destroy         /* destroy */
 };
@@ -198,6 +200,7 @@ static const struct object_ops mapping_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     mapping_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,            /* get_fast_sync */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
diff --git a/server/mutex.c b/server/mutex.c
index 2503d12057f..a45d8b85c9e 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -87,6 +87,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 22eacf301fb..aa53faec6a3 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -133,6 +133,7 @@ static const struct object_ops named_pipe_ops =
     default_unlink_name,          /* unlink_name */
     named_pipe_open_file,         /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     named_pipe_destroy            /* destroy */
 };
@@ -183,6 +184,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -229,6 +231,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -278,6 +281,7 @@ static const struct object_ops named_pipe_device_ops =
     default_unlink_name,              /* unlink_name */
     named_pipe_device_open_file,      /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
+    no_get_fast_sync,                 /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     named_pipe_device_destroy         /* destroy */
 };
@@ -311,6 +315,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
+    no_get_fast_sync,                        /* get_fast_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
diff --git a/server/object.c b/server/object.c
index 29f1ea96129..1ae2a9ec514 100644
--- a/server/object.c
+++ b/server/object.c
@@ -538,6 +538,12 @@ struct fd *no_get_fd( struct object *obj )
     return NULL;
 }
 
+struct fast_sync *no_get_fast_sync ( struct object *obj )
+{
+    set_error( STATUS_OBJECT_TYPE_MISMATCH );
+    return NULL;
+}
+
 unsigned int default_map_access( struct object *obj, unsigned int access )
 {
     return map_access( access, &obj->ops->type->mapping );
diff --git a/server/object.h b/server/object.h
index 20c7ab63938..5d722f80874 100644
--- a/server/object.h
+++ b/server/object.h
@@ -42,6 +42,7 @@ struct async;
 struct async_queue;
 struct winstation;
 struct object_type;
+struct fast_sync;
 
 
 struct unicode_str
@@ -107,6 +108,8 @@ struct object_ops
                                 unsigned int options);
     /* return list of kernel objects */
     struct list *(*get_kernel_obj_list)(struct object *);
+    /* get a client-waitable fast-synchronization handle to this object */
+    struct fast_sync *(*get_fast_sync)(struct object *);
     /* close a handle to this object */
     int (*close_handle)(struct object *,struct process *,obj_handle_t);
     /* destroy on refcount == 0 */
@@ -226,6 +229,10 @@ extern void reset_event( struct event *event );
 
 extern void abandon_mutexes( struct thread *thread );
 
+/* fast synchronization functions */
+
+extern struct fast_sync *no_get_fast_sync ( struct object *obj );
+
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
diff --git a/server/process.c b/server/process.c
index fa9eab47214..9263031b3af 100644
--- a/server/process.c
+++ b/server/process.c
@@ -124,6 +124,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,            /* get_fast_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -177,6 +178,7 @@ static const struct object_ops startup_info_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     startup_info_destroy           /* destroy */
 };
@@ -240,6 +242,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
diff --git a/server/protocol.def b/server/protocol.def
index 9589aacfbbc..d02af29a4f8 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3989,3 +3989,14 @@ enum fsync_type
     unsigned int shm_idx;
 @REPLY
 @END
+
+enum fast_sync_type
+{
+    FAST_SYNC_SEMAPHORE = 1,
+    FAST_SYNC_MUTEX,
+    FAST_SYNC_AUTO_EVENT,
+    FAST_SYNC_MANUAL_EVENT,
+    FAST_SYNC_AUTO_SERVER,
+    FAST_SYNC_MANUAL_SERVER,
+    FAST_SYNC_QUEUE,
+};
diff --git a/server/queue.c b/server/queue.c
index f51263ed692..ab4ca4bc343 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -189,6 +189,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -228,6 +229,7 @@ static const struct object_ops thread_input_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     thread_input_destroy          /* destroy */
 };
diff --git a/server/registry.c b/server/registry.c
index c3cf9ba7dfa..f7dc9257bc2 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -194,6 +194,7 @@ static const struct object_ops key_ops =
     key_unlink_name,         /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_fast_sync,        /* get_fast_sync */
     key_close_handle,        /* close_handle */
     key_destroy              /* destroy */
 };
diff --git a/server/request.c b/server/request.c
index 343e1a92e0e..f5807afe07f 100644
--- a/server/request.c
+++ b/server/request.c
@@ -104,6 +104,7 @@ static const struct object_ops master_socket_ops =
     NULL,                          /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     master_socket_destroy          /* destroy */
 };
diff --git a/server/semaphore.c b/server/semaphore.c
index d354892c224..156bc1dcd55 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -84,6 +84,7 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
+    no_get_fast_sync,              /* get_fast_sync */
     no_close_handle,               /* close_handle */
     no_destroy                     /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 1915d00a977..8660a2ba90a 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -99,6 +99,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/signal.c b/server/signal.c
index 802b7f936b9..ef6e94a526c 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -76,6 +76,7 @@ static const struct object_ops handler_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     handler_destroy           /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 91acb214324..8d6f7ceae9b 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -464,6 +464,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
@@ -3511,6 +3512,7 @@ static const struct object_ops ifchange_ops =
     NULL,                    /* unlink_name */
     no_open_file,            /* open_file */
     no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_get_fast_sync,        /* get_fast_sync */
     no_close_handle,         /* close_handle */
     ifchange_destroy         /* destroy */
 };
@@ -3734,6 +3736,7 @@ static const struct object_ops socket_device_ops =
     default_unlink_name,        /* unlink_name */
     socket_device_open_file,    /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
diff --git a/server/symlink.c b/server/symlink.c
index cd954effa91..ea142a99571 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -85,6 +85,7 @@ static const struct object_ops symlink_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     no_close_handle,              /* close_handle */
     symlink_destroy               /* destroy */
 };
diff --git a/server/thread.c b/server/thread.c
index d728c1a2160..b903d632198 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -119,6 +119,7 @@ static const struct object_ops thread_apc_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     thread_apc_destroy          /* destroy */
 };
@@ -166,6 +167,7 @@ static const struct object_ops context_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     no_destroy                  /* destroy */
 };
@@ -219,6 +221,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
diff --git a/server/timer.c b/server/timer.c
index 884ace9376f..4de4787de0d 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -96,6 +96,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
diff --git a/server/token.c b/server/token.c
index 6ab8848230f..bd50992e2c0 100644
--- a/server/token.c
+++ b/server/token.c
@@ -161,6 +161,7 @@ static const struct object_ops token_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_get_fast_sync,          /* get_fast_sync */
     no_close_handle,           /* close_handle */
     token_destroy              /* destroy */
 };
diff --git a/server/window.c b/server/window.c
index 302aa2e6071..5ed140f4ac5 100644
--- a/server/window.c
+++ b/server/window.c
@@ -121,6 +121,7 @@ static const struct object_ops window_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_get_fast_sync,         /* get_fast_sync */
     no_close_handle,          /* close_handle */
     window_destroy            /* destroy */
 };
diff --git a/server/winstation.c b/server/winstation.c
index 53613592a82..0760afb6496 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -89,6 +89,7 @@ static const struct object_ops winstation_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     winstation_close_handle,      /* close_handle */
     winstation_destroy            /* destroy */
 };
@@ -131,6 +132,7 @@ static const struct object_ops desktop_ops =
     default_unlink_name,          /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_get_fast_sync,             /* get_fast_sync */
     desktop_close_handle,         /* close_handle */
     desktop_destroy               /* destroy */
 };
commit 626df99ed7551a96c3b1295461c9066d452a6082
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 11:57:43 2024 +1000

    server: Create fast synchronization objects for events.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: FuzzyQuils
    
    Unlike mainline/staging wine, I have opted to include linux/winesync.h
    into the Proton Wine tree and delete any ifdef'd code for if winesync.h
    is missing. This is so building with Steam Runtime Sniper is possible
    without the functions being erroneously stubbed, due to the Steam
    Runtime container typically lacking linux/winesync.h in the intended
    path.
    
    Additionally, linux_device_ops and fast_sync_ops have been modified to
    take NULL get_esync_fd and get_fsync_idx function pointers to match
    Proton's object_ops as Proton Wine has esync/fsync built-in. This would
    potentially apply to a staging port as well, depending on patch
    application order.

diff --git a/configure.ac b/configure.ac
index 0d37ab24923..d7b77cab896 100644
--- a/configure.ac
+++ b/configure.ac
@@ -431,6 +431,7 @@ AC_CHECK_HEADERS(\
 	linux/serial.h \
 	linux/types.h \
 	linux/ucdrom.h \
+	linux/winesync.h \
 	linux/wireless.h \
 	lwp.h \
 	mach-o/loader.h \
diff --git a/include/linux/winesync.h b/include/linux/winesync.h
new file mode 100644
index 00000000000..5b4e369f746
--- /dev/null
+++ b/include/linux/winesync.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Kernel support for Wine synchronization primitives
+ *
+ * Copyright (C) 2021 Zebediah Figura
+ */
+
+#ifndef __LINUX_WINESYNC_H
+#define __LINUX_WINESYNC_H
+
+#include <linux/types.h>
+
+struct winesync_sem_args {
+	__u32 sem;
+	__u32 count;
+	__u32 max;
+};
+
+struct winesync_mutex_args {
+	__u32 mutex;
+	__u32 owner;
+	__u32 count;
+};
+
+struct winesync_event_args {
+	__u32 event;
+	__u32 manual;
+	__u32 signaled;
+};
+
+struct winesync_wait_args {
+	__u64 timeout;
+	__u64 objs;
+	__u32 count;
+	__u32 owner;
+	__u32 index;
+	__u32 alert;
+};
+
+#define WINESYNC_IOC_BASE 0xf7
+
+#define WINESYNC_IOC_CREATE_SEM		_IOWR(WINESYNC_IOC_BASE, 0, \
+					      struct winesync_sem_args)
+#define WINESYNC_IOC_DELETE		_IOW (WINESYNC_IOC_BASE, 1, __u32)
+#define WINESYNC_IOC_PUT_SEM		_IOWR(WINESYNC_IOC_BASE, 2, \
+					      struct winesync_sem_args)
+#define WINESYNC_IOC_WAIT_ANY		_IOWR(WINESYNC_IOC_BASE, 3, \
+					      struct winesync_wait_args)
+#define WINESYNC_IOC_WAIT_ALL		_IOWR(WINESYNC_IOC_BASE, 4, \
+					      struct winesync_wait_args)
+#define WINESYNC_IOC_CREATE_MUTEX	_IOWR(WINESYNC_IOC_BASE, 5, \
+					      struct winesync_mutex_args)
+#define WINESYNC_IOC_PUT_MUTEX		_IOWR(WINESYNC_IOC_BASE, 6, \
+					      struct winesync_mutex_args)
+#define WINESYNC_IOC_KILL_OWNER		_IOW (WINESYNC_IOC_BASE, 7, __u32)
+#define WINESYNC_IOC_READ_SEM		_IOWR(WINESYNC_IOC_BASE, 8, \
+					      struct winesync_sem_args)
+#define WINESYNC_IOC_READ_MUTEX		_IOWR(WINESYNC_IOC_BASE, 9, \
+					      struct winesync_mutex_args)
+#define WINESYNC_IOC_CREATE_EVENT	_IOWR(WINESYNC_IOC_BASE, 10, \
+					      struct winesync_event_args)
+#define WINESYNC_IOC_SET_EVENT		_IOWR(WINESYNC_IOC_BASE, 11, \
+					      struct winesync_event_args)
+#define WINESYNC_IOC_RESET_EVENT	_IOWR(WINESYNC_IOC_BASE, 12, \
+					      struct winesync_event_args)
+#define WINESYNC_IOC_PULSE_EVENT	_IOWR(WINESYNC_IOC_BASE, 13, \
+					      struct winesync_event_args)
+#define WINESYNC_IOC_READ_EVENT		_IOWR(WINESYNC_IOC_BASE, 14, \
+					      struct winesync_event_args)
+
+#endif
diff --git a/server/Makefile.in b/server/Makefile.in
index c364b2b62aa..2470898276e 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -13,6 +13,7 @@ C_SRCS = \
 	directory.c \
 	esync.c \
 	event.c \
+	fast_sync.c \
 	fd.c \
 	file.c \
 	fsync.c \
diff --git a/server/event.c b/server/event.c
index 5f4f2125f9c..0625c35a470 100644
--- a/server/event.c
+++ b/server/event.c
@@ -60,6 +60,7 @@ struct event
     int            signaled;        /* event has been signaled */
     int            esync_fd;        /* esync file descriptor */
     unsigned int   fsync_idx;
+    struct fast_sync *fast_sync;    /* fast synchronization object */
 };
 
 static void event_dump( struct object *obj, int verbose );
@@ -69,6 +70,7 @@ static int event_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int event_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
+static struct fast_sync *event_get_fast_sync( struct object *obj );
 static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
@@ -93,7 +95,7 @@ static const struct object_ops event_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    event_get_fast_sync,       /* get_fast_sync */
     no_close_handle,           /* close_handle */
     event_destroy              /* destroy */
 };
@@ -164,6 +166,7 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
             event->fsync_idx = 0;
+            event->fast_sync    = NULL;
 
             if (do_fsync())
                 event->fsync_idx = fsync_alloc_shm( initial_state, 0 );
@@ -216,6 +219,7 @@ void set_event( struct event *event )
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
+    fast_set_event( event->fast_sync );
 }
 
 void reset_event( struct event *event )
@@ -238,6 +242,8 @@ void reset_event( struct event *event )
 
     if (do_esync())
         esync_clear( event->esync_fd );
+
+    fast_reset_event( event->fast_sync );
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -297,6 +303,19 @@ static struct list *event_get_kernel_obj_list( struct object *obj )
     return &event->kernel_object;
 }
 
+static struct fast_sync *event_get_fast_sync( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (!event->fast_sync)
+    {
+        enum fast_sync_type type = event->manual_reset ? FAST_SYNC_MANUAL_EVENT : FAST_SYNC_AUTO_EVENT;
+        event->fast_sync = fast_create_event( type, event->signaled );
+    }
+    if (event->fast_sync) grab_object( event->fast_sync );
+    return event->fast_sync;
+}
+
 static void event_destroy( struct object *obj )
 {
     struct event *event = (struct event *)obj;
@@ -304,6 +323,7 @@ static void event_destroy( struct object *obj )
     if (do_esync())
         close( event->esync_fd );
     if (event->fsync_idx) fsync_free_shm_idx( event->fsync_idx );
+    if (event->fast_sync) release_object( event->fast_sync );
 }
 
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
diff --git a/server/fast_sync.c b/server/fast_sync.c
new file mode 100644
index 00000000000..21fa8052d49
--- /dev/null
+++ b/server/fast_sync.c
@@ -0,0 +1,281 @@
+/*
+ * Fast synchronization primitives
+ *
+ * Copyright (C) 2021-2022 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
+
+#include "file.h"
+#include "thread.h"
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <linux/winesync.h>
+
+struct linux_device
+{
+    struct object obj;      /* object header */
+    struct fd *fd;          /* fd for unix fd */
+};
+
+static struct linux_device *linux_device_object;
+
+static void linux_device_dump( struct object *obj, int verbose );
+static struct fd *linux_device_get_fd( struct object *obj );
+static void linux_device_destroy( struct object *obj );
+static enum server_fd_type linux_device_get_fd_type( struct fd *fd );
+
+static const struct object_ops linux_device_ops =
+{
+    sizeof(struct linux_device),        /* size */
+    &no_type,                           /* type */
+    linux_device_dump,                  /* dump */
+    no_add_queue,                       /* add_queue */
+    NULL,                               /* remove_queue */
+    NULL,                               /* signaled */
+    NULL,                               /* get_esync_fd */
+    NULL,                               /* get_fsync_idx */
+    NULL,                               /* satisfied */
+    no_signal,                          /* signal */
+    linux_device_get_fd,                /* get_fd */
+    default_map_access,                 /* map_access */
+    default_get_sd,                     /* get_sd */
+    default_set_sd,                     /* set_sd */
+    no_get_full_name,                   /* get_full_name */
+    no_lookup_name,                     /* lookup_name */
+    no_link_name,                       /* link_name */
+    NULL,                               /* unlink_name */
+    no_open_file,                       /* open_file */
+    no_kernel_obj_list,                 /* get_kernel_obj_list */
+    no_get_fast_sync,                   /* get_fast_sync */
+    no_close_handle,                    /* close_handle */
+    linux_device_destroy                /* destroy */
+};
+
+static const struct fd_ops linux_device_fd_ops =
+{
+    default_fd_get_poll_events,     /* get_poll_events */
+    default_poll_event,             /* poll_event */
+    linux_device_get_fd_type,       /* get_fd_type */
+    no_fd_read,                     /* read */
+    no_fd_write,                    /* write */
+    no_fd_flush,                    /* flush */
+    no_fd_get_file_info,            /* get_file_info */
+    no_fd_get_volume_info,          /* get_volume_info */
+    no_fd_ioctl,                    /* ioctl */
+    default_fd_cancel_async,        /* cancel_async */
+    no_fd_queue_async,              /* queue_async */
+    default_fd_reselect_async       /* reselect_async */
+};
+
+static void linux_device_dump( struct object *obj, int verbose )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    assert( obj->ops == &linux_device_ops );
+    fprintf( stderr, "Fast synchronization device fd=%p\n", device->fd );
+}
+
+static struct fd *linux_device_get_fd( struct object *obj )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    return (struct fd *)grab_object( device->fd );
+}
+
+static void linux_device_destroy( struct object *obj )
+{
+    struct linux_device *device = (struct linux_device *)obj;
+    assert( obj->ops == &linux_device_ops );
+    if (device->fd) release_object( device->fd );
+    linux_device_object = NULL;
+}
+
+static enum server_fd_type linux_device_get_fd_type( struct fd *fd )
+{
+    return FD_TYPE_FILE;
+}
+
+static struct linux_device *get_linux_device(void)
+{
+    struct linux_device *device;
+    int unix_fd;
+
+    if (linux_device_object)
+        return (struct linux_device *)grab_object( linux_device_object );
+
+    unix_fd = open( "/dev/winesync", O_CLOEXEC | O_RDONLY );
+    if (unix_fd == -1)
+    {
+        file_set_error();
+        return NULL;
+    }
+
+    if (!(device = alloc_object( &linux_device_ops )))
+    {
+        close( unix_fd );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+
+    if (!(device->fd = create_anonymous_fd( &linux_device_fd_ops, unix_fd, &device->obj, 0 )))
+    {
+        release_object( device );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+
+    linux_device_object = device;
+    return device;
+}
+
+struct fast_sync
+{
+    struct object obj;
+    struct linux_device *device;
+    enum fast_sync_type type;
+    unsigned int linux_obj;
+};
+
+static void linux_obj_dump( struct object *obj, int verbose );
+static void linux_obj_destroy( struct object *obj );
+
+static const struct object_ops fast_sync_ops =
+{
+    sizeof(struct fast_sync),   /* size */
+    &no_type,                   /* type */
+    linux_obj_dump,             /* dump */
+    no_add_queue,               /* add_queue */
+    NULL,                       /* remove_queue */
+    NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
+    NULL,                       /* satisfied */
+    no_signal,                  /* signal */
+    no_get_fd,                  /* get_fd */
+    default_map_access,         /* map_access */
+    default_get_sd,             /* get_sd */
+    default_set_sd,             /* set_sd */
+    no_get_full_name,           /* get_full_name */
+    no_lookup_name,             /* lookup_name */
+    no_link_name,               /* link_name */
+    NULL,                       /* unlink_name */
+    no_open_file,               /* open_file */
+    no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_get_fast_sync,           /* get_fast_sync */
+    no_close_handle,            /* close_handle */
+    linux_obj_destroy           /* destroy */
+};
+
+static void linux_obj_dump( struct object *obj, int verbose )
+{
+    struct fast_sync *fast_sync = (struct fast_sync *)obj;
+    assert( obj->ops == &fast_sync_ops );
+    fprintf( stderr, "Fast synchronization object type=%u linux_obj=%u\n",
+             fast_sync->type, fast_sync->linux_obj );
+}
+
+static void linux_obj_destroy( struct object *obj )
+{
+    struct fast_sync *fast_sync = (struct fast_sync *)obj;
+
+    ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_DELETE, &fast_sync->linux_obj );
+    release_object( fast_sync->device );
+}
+
+struct fast_sync *fast_create_event( enum fast_sync_type type, int signaled )
+{
+    struct winesync_event_args args = {0};
+    struct linux_device *device;
+    struct fast_sync *fast_sync;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.signaled = signaled;
+    switch (type)
+    {
+        case FAST_SYNC_AUTO_EVENT:
+        case FAST_SYNC_AUTO_SERVER:
+            args.manual = 0;
+            break;
+
+        case FAST_SYNC_MANUAL_EVENT:
+        case FAST_SYNC_MANUAL_SERVER:
+        case FAST_SYNC_QUEUE:
+            args.manual = 1;
+            break;
+
+        case FAST_SYNC_MUTEX:
+        case FAST_SYNC_SEMAPHORE:
+            assert(0);
+            break;
+    }
+    if (ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_CREATE_EVENT, &args ) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    if (!(fast_sync = alloc_object( &fast_sync_ops ))) return NULL;
+
+    /* transfer our device reference to the fast sync object */
+    fast_sync->device = device;
+    fast_sync->type = type;
+    fast_sync->linux_obj = args.event;
+
+    return fast_sync;
+}
+
+void fast_set_event( struct fast_sync *fast_sync )
+{
+    struct winesync_event_args args = {0};
+
+    if (!fast_sync) return;
+
+    if (debug_level) fprintf( stderr, "fast_set_event %u\n", fast_sync->linux_obj );
+
+    args.event = fast_sync->linux_obj;
+    ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_SET_EVENT, &args );
+}
+
+struct timespec64
+{
+    long long tv_sec;
+    long long tv_nsec;
+};
+
+void fast_reset_event( struct fast_sync *fast_sync )
+{
+    struct winesync_event_args args = {0};
+
+    if (!fast_sync) return;
+
+    if (debug_level) fprintf( stderr, "fast_reset_event %u\n", fast_sync->linux_obj );
+
+    args.event = fast_sync->linux_obj;
+    ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_RESET_EVENT, &args );
+}
diff --git a/server/object.h b/server/object.h
index 5d722f80874..19b834b19c9 100644
--- a/server/object.h
+++ b/server/object.h
@@ -231,6 +231,10 @@ extern void abandon_mutexes( struct thread *thread );
 
 /* fast synchronization functions */
 
+extern struct fast_sync *fast_create_event( enum fast_sync_type type, int signaled );
+extern void fast_set_event( struct fast_sync *obj );
+extern void fast_reset_event( struct fast_sync *obj );
+
 extern struct fast_sync *no_get_fast_sync ( struct object *obj );
 
 /* serial functions */
commit a16b3415359e079a1d89baf37c367e6a5ee058e9
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 11:58:38 2024 +1000

    server: Create fast synchronization objects for semaphores.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 21fa8052d49..023496231be 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -250,6 +250,33 @@ struct fast_sync *fast_create_event( enum fast_sync_type type, int signaled )
     return fast_sync;
 }
 
+struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max )
+{
+    struct winesync_sem_args args = {0};
+    struct linux_device *device;
+    struct fast_sync *fast_sync;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.count = count;
+    args.max = max;
+    if (ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_CREATE_SEM, &args ) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    if (!(fast_sync = alloc_object( &fast_sync_ops ))) return NULL;
+
+    /* transfer our device reference to the fast sync object */
+    fast_sync->device = device;
+    fast_sync->type = FAST_SYNC_SEMAPHORE;
+    fast_sync->linux_obj = args.sem;
+
+    return fast_sync;
+}
+
 void fast_set_event( struct fast_sync *fast_sync )
 {
     struct winesync_event_args args = {0};
diff --git a/server/object.h b/server/object.h
index 19b834b19c9..077b9169586 100644
--- a/server/object.h
+++ b/server/object.h
@@ -232,6 +232,7 @@ extern void abandon_mutexes( struct thread *thread );
 /* fast synchronization functions */
 
 extern struct fast_sync *fast_create_event( enum fast_sync_type type, int signaled );
+extern struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max );
 extern void fast_set_event( struct fast_sync *obj );
 extern void fast_reset_event( struct fast_sync *obj );
 
diff --git a/server/semaphore.c b/server/semaphore.c
index 156bc1dcd55..077376e15d4 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -55,12 +55,15 @@ struct semaphore
     struct object  obj;    /* object header */
     unsigned int   count;  /* current count */
     unsigned int   max;    /* maximum possible count */
+    struct fast_sync *fast_sync; /* fast synchronization object */
 };
 
 static void semaphore_dump( struct object *obj, int verbose );
 static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int semaphore_signal( struct object *obj, unsigned int access );
+static struct fast_sync *semaphore_get_fast_sync( struct object *obj );
+static void semaphore_destroy( struct object *obj );
 
 static const struct object_ops semaphore_ops =
 {
@@ -84,9 +87,9 @@ static const struct object_ops semaphore_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_fast_sync,              /* get_fast_sync */
+    semaphore_get_fast_sync,       /* get_fast_sync */
     no_close_handle,               /* close_handle */
-    no_destroy                     /* destroy */
+    semaphore_destroy              /* destroy */
 };
 
 
@@ -108,6 +111,7 @@ static struct semaphore *create_semaphore( struct object *root, const struct uni
             /* initialize it if it didn't already exist */
             sem->count = initial;
             sem->max   = max;
+            sem->fast_sync = NULL;
         }
     }
     return sem;
@@ -170,6 +174,23 @@ static int semaphore_signal( struct object *obj, unsigned int access )
     return release_semaphore( sem, 1, NULL );
 }
 
+static struct fast_sync *semaphore_get_fast_sync( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (!semaphore->fast_sync)
+        semaphore->fast_sync = fast_create_semaphore( semaphore->count, semaphore->max );
+    if (semaphore->fast_sync) grab_object( semaphore->fast_sync );
+    return semaphore->fast_sync;
+}
+
+static void semaphore_destroy( struct object *obj )
+{
+    struct semaphore *semaphore = (struct semaphore *)obj;
+
+    if (semaphore->fast_sync) release_object( semaphore->fast_sync );
+}
+
 /* create a semaphore */
 DECL_HANDLER(create_semaphore)
 {
commit 7a3ae77c270855ae93f51ac2597669caa74329d2
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 11:59:22 2024 +1000

    server: Create fast synchronization objects for mutexes.
    
    Original Author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 023496231be..0825ba94f7e 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -277,6 +277,33 @@ struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max )
     return fast_sync;
 }
 
+struct fast_sync *fast_create_mutex( thread_id_t owner, unsigned int count )
+{
+    struct winesync_mutex_args args = {0};
+    struct linux_device *device;
+    struct fast_sync *fast_sync;
+
+    if (!(device = get_linux_device())) return NULL;
+
+    args.owner = owner;
+    args.count = count;
+    if (ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_CREATE_MUTEX, &args ) < 0)
+    {
+        file_set_error();
+        release_object( device );
+        return NULL;
+    }
+
+    if (!(fast_sync = alloc_object( &fast_sync_ops ))) return NULL;
+
+    /* transfer our device reference to the fast sync object */
+    fast_sync->device = device;
+    fast_sync->type = FAST_SYNC_MUTEX;
+    fast_sync->linux_obj = args.mutex;
+
+    return fast_sync;
+}
+
 void fast_set_event( struct fast_sync *fast_sync )
 {
     struct winesync_event_args args = {0};
@@ -306,3 +333,17 @@ void fast_reset_event( struct fast_sync *fast_sync )
     args.event = fast_sync->linux_obj;
     ioctl( get_unix_fd( fast_sync->device->fd ), WINESYNC_IOC_RESET_EVENT, &args );
 }
+
+void fast_abandon_mutexes( thread_id_t tid )
+{
+    struct linux_device *device;
+
+    if (!(device = get_linux_device()))
+    {
+        clear_error();
+        return;
+    }
+
+    ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_KILL_OWNER, &tid );
+    release_object( device );
+}
diff --git a/server/mutex.c b/server/mutex.c
index a45d8b85c9e..11cb45354c5 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -57,6 +57,7 @@ struct mutex
     unsigned int   count;           /* recursion count */
     int            abandoned;       /* has it been abandoned? */
     struct list    entry;           /* entry in owner thread mutex list */
+    struct fast_sync *fast_sync;    /* fast synchronization object */
 };
 
 static void mutex_dump( struct object *obj, int verbose );
@@ -64,6 +65,7 @@ static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void mutex_destroy( struct object *obj );
 static int mutex_signal( struct object *obj, unsigned int access );
+static struct fast_sync *mutex_get_fast_sync( struct object *obj );
 
 static const struct object_ops mutex_ops =
 {
@@ -87,7 +89,7 @@ static const struct object_ops mutex_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    mutex_get_fast_sync,       /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mutex_destroy              /* destroy */
 };
@@ -130,6 +132,7 @@ static struct mutex *create_mutex( struct object *root, const struct unicode_str
             mutex->owner = NULL;
             mutex->abandoned = 0;
             if (owned) do_grab( mutex, current );
+            mutex->fast_sync = NULL;
         }
     }
     return mutex;
@@ -192,14 +195,27 @@ static int mutex_signal( struct object *obj, unsigned int access )
     return 1;
 }
 
+static struct fast_sync *mutex_get_fast_sync( struct object *obj )
+{
+    struct mutex *mutex = (struct mutex *)obj;
+
+    if (!mutex->fast_sync)
+        mutex->fast_sync = fast_create_mutex( mutex->owner ? mutex->owner->id : 0, mutex->count );
+    if (mutex->fast_sync) grab_object( mutex->fast_sync );
+    return mutex->fast_sync;
+}
+
 static void mutex_destroy( struct object *obj )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
 
-    if (!mutex->count) return;
-    mutex->count = 0;
-    do_release( mutex );
+    if (mutex->count)
+    {
+        mutex->count = 0;
+        do_release( mutex );
+    }
+    if (mutex->fast_sync) release_object( mutex->fast_sync );
 }
 
 /* create a mutex */
diff --git a/server/object.h b/server/object.h
index 077b9169586..ca4e8510842 100644
--- a/server/object.h
+++ b/server/object.h
@@ -233,8 +233,10 @@ extern void abandon_mutexes( struct thread *thread );
 
 extern struct fast_sync *fast_create_event( enum fast_sync_type type, int signaled );
 extern struct fast_sync *fast_create_semaphore( unsigned int count, unsigned int max );
+extern struct fast_sync *fast_create_mutex( thread_id_t owner, unsigned int count );
 extern void fast_set_event( struct fast_sync *obj );
 extern void fast_reset_event( struct fast_sync *obj );
+extern void fast_abandon_mutexes( thread_id_t tid );
 
 extern struct fast_sync *no_get_fast_sync ( struct object *obj );
 
diff --git a/server/thread.c b/server/thread.c
index b903d632198..7d490b28c7a 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1564,6 +1564,7 @@ void kill_thread( struct thread *thread, int violent_death )
     }
     kill_console_processes( thread, 0 );
     abandon_mutexes( thread );
+    fast_abandon_mutexes( thread->id );
     if (do_fsync())
         fsync_abandon_mutexes( thread );
     if (do_esync())
commit 24c56ec79b26472cb8fae1ef95233fc1f7b549e8
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 11:59:57 2024 +1000

    server: Create fast synchronization objects for completion ports.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail
    
    Due to Valve's weird implementation of completion ports, several parts
    of the original commit had to be changed so completion_ops calls pass
    through to completion_wait_ops calls, which is required for fastsync
    completion ports to work properly in Proton. Esync/fsync in the
    Proton tree do the same thing FWIW.
    
    For more information, visit this gist with my thoughts on it:
    https://gist.github.com/FuzzyQuills/bcb69dac421af0a2d7e72057feba871e

diff --git a/server/completion.c b/server/completion.c
index 1dbce63d045..475e60fe55c 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -67,6 +67,7 @@ struct completion_wait
     unsigned int       depth;
     int                esync_fd;
     unsigned int       fsync_idx;
+    struct fast_sync   *fast_sync;
 };
 
 struct completion
@@ -80,6 +81,7 @@ static int completion_wait_signaled( struct object *obj, struct wait_queue_entry
 static void completion_wait_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int completion_wait_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int completion_wait_get_fsync_idx( struct object *obj, enum fsync_type *type );
+static struct fast_sync *completion_wait_get_fast_sync( struct object *obj );
 static void completion_wait_destroy( struct object * );
 
 static const struct object_ops completion_wait_ops =
@@ -104,7 +106,7 @@ static const struct object_ops completion_wait_ops =
     NULL,                           /* unlink_name */
     no_open_file,                   /* open_file */
     no_kernel_obj_list,             /* get_kernel_obj_list */
-    no_get_fast_sync,               /* get_fast_sync */
+    completion_wait_get_fast_sync,  /* get_fast_sync */
     no_close_handle,                /* close_handle */
     completion_wait_destroy         /* destroy */
 };
@@ -167,6 +169,8 @@ static void completion_wait_destroy( struct object *obj)
         close( wait->esync_fd );
 
     if (wait->fsync_idx) fsync_free_shm_idx( wait->fsync_idx );
+
+    if (wait->fast_sync) release_object( wait->fast_sync );
 }
 
 static void completion_wait_dump( struct object *obj, int verbose )
@@ -202,6 +206,16 @@ static unsigned int completion_wait_get_fsync_idx( struct object *obj, enum fsyn
     return wait->fsync_idx;
 }
 
+static struct fast_sync *completion_wait_get_fast_sync( struct object *obj )
+{
+    struct completion_wait *wait = (struct completion_wait *)obj;
+
+    if (!wait->fast_sync)
+        wait->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, !list_empty( &wait->queue ) );
+    if (wait->fast_sync) grab_object( wait->fast_sync );
+    return wait->fast_sync;
+}
+
 static void completion_wait_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct completion_wait *wait = (struct completion_wait *)obj;
@@ -294,6 +308,7 @@ static struct completion *create_completion( struct object *root, const struct u
     list_init( &completion->wait->queue );
     completion->wait->depth = 0;
     completion->wait->fsync_idx = 0;
+    completion->wait->fast_sync = NULL;
 
     if (do_fsync())
         completion->wait->fsync_idx = fsync_alloc_shm( 0, 0 );
@@ -326,6 +341,7 @@ void add_completion( struct completion *completion, apc_param_t ckey, apc_param_
     completion->wait->depth++;
 
     wake_up( &completion->wait->obj, 1 );
+    fast_set_event( completion->wait->fast_sync );
 }
 
 /* create a completion */
@@ -420,6 +436,8 @@ DECL_HANDLER(remove_completion)
         reply->status = msg->status;
         reply->information = msg->information;
         free( msg );
+        if (list_empty( &wait->queue ))
+            fast_reset_event( wait->fast_sync );
 
         if (!completion_wait_signaled( &wait->obj, NULL ))
         {
commit dfa974228148ba80d1cb7ac8a4cc2a9a513e9863
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:00:37 2024 +1000

    server: Create fast synchronization objects for consoles.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/console.c b/server/console.c
index 4dc74d3cb01..b17e78adbfe 100644
--- a/server/console.c
+++ b/server/console.c
@@ -63,6 +63,7 @@ struct console
     struct fd                   *fd;            /* for bare console, attached input fd */
     struct async_queue           ioctl_q;       /* ioctl queue */
     struct async_queue           read_q;        /* read queue */
+    struct fast_sync            *fast_sync;     /* fast synchronization object */
 };
 
 static void console_dump( struct object *obj, int verbose );
@@ -74,6 +75,7 @@ static struct object *console_lookup_name( struct object *obj, struct unicode_st
 static struct object *console_open_file( struct object *obj, unsigned int access,
                                          unsigned int sharing, unsigned int options );
 static int console_add_queue( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *console_get_fast_sync( struct object *obj );
 
 static const struct object_ops console_ops =
 {
@@ -97,7 +99,7 @@ static const struct object_ops console_ops =
     NULL,                             /* unlink_name */
     console_open_file,                /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_get_fast_sync,            /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_destroy                   /* destroy */
 };
@@ -230,6 +232,7 @@ static int screen_buffer_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *screen_buffer_get_fd( struct object *obj );
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
+static struct fast_sync *screen_buffer_get_fast_sync( struct object *obj );
 
 static const struct object_ops screen_buffer_ops =
 {
@@ -254,7 +257,7 @@ static const struct object_ops screen_buffer_ops =
     screen_buffer_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
     no_get_fast_sync,                 /* get_fast_sync */
-    no_close_handle,                  /* close_handle */
+    screen_buffer_get_fast_sync,      /* close_handle */
     screen_buffer_destroy             /* destroy */
 };
 
@@ -321,6 +324,7 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
                                                unsigned int sharing, unsigned int options );
 static int console_input_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *console_input_get_fd( struct object *obj );
+static struct fast_sync *console_input_get_fast_sync( struct object *obj );
 static void console_input_destroy( struct object *obj );
 
 static const struct object_ops console_input_ops =
@@ -345,7 +349,7 @@ static const struct object_ops console_input_ops =
     default_unlink_name,              /* unlink_name */
     console_input_open_file,          /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_input_get_fast_sync,      /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_input_destroy             /* destroy */
 };
@@ -381,6 +385,7 @@ static int console_output_add_queue( struct object *obj, struct wait_queue_entry
 static struct fd *console_output_get_fd( struct object *obj );
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct fast_sync *console_output_get_fast_sync( struct object *obj );
 static void console_output_destroy( struct object *obj );
 
 static const struct object_ops console_output_ops =
@@ -405,7 +410,7 @@ static const struct object_ops console_output_ops =
     default_unlink_name,              /* unlink_name */
     console_output_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_output_get_fast_sync,     /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_output_destroy            /* destroy */
 };
@@ -566,6 +571,7 @@ static struct object *create_console(void)
     console->server        = NULL;
     console->fd            = NULL;
     console->last_id       = 0;
+    console->fast_sync     = NULL;
     init_async_queue( &console->ioctl_q );
     init_async_queue( &console->read_q );
 
@@ -793,6 +799,8 @@ static void console_destroy( struct object *obj )
     free_async_queue( &console->read_q );
     if (console->fd)
         release_object( console->fd );
+
+    if (console->fast_sync) release_object( console->fast_sync );
 }
 
 static struct object *create_console_connection( struct console *console )
@@ -840,6 +848,16 @@ static struct object *console_open_file( struct object *obj, unsigned int access
     return grab_object( obj );
 }
 
+static struct fast_sync *console_get_fast_sync( struct object *obj )
+{
+    struct console *console = (struct console *)obj;
+
+    if (!console->fast_sync)
+        console->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, console->signaled );
+    if (console->fast_sync) grab_object( console->fast_sync );
+    return console->fast_sync;
+}
+
 static void screen_buffer_dump( struct object *obj, int verbose )
 {
     struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
@@ -889,6 +907,17 @@ static struct fd *screen_buffer_get_fd( struct object *obj )
     return NULL;
 }
 
+static struct fast_sync *screen_buffer_get_fast_sync( struct object *obj )
+{
+    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
+    if (!screen_buffer->input)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_fast_sync( &screen_buffer->input->obj );
+}
+
 static void console_server_dump( struct object *obj, int verbose )
 {
     assert( obj->ops == &console_server_ops );
@@ -1455,6 +1484,16 @@ static struct object *console_input_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct fast_sync *console_input_get_fast_sync( struct object *obj )
+{
+    if (!current->process->console)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_fast_sync( &current->process->console->obj );
+}
+
 static void console_input_destroy( struct object *obj )
 {
     struct console_input *console_input = (struct console_input *)obj;
@@ -1527,6 +1566,16 @@ static struct object *console_output_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct fast_sync *console_output_get_fast_sync( struct object *obj )
+{
+    if (!current->process->console || !current->process->console->active)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return NULL;
+    }
+    return console_get_fast_sync( &current->process->console->obj );
+}
+
 static void console_output_destroy( struct object *obj )
 {
     struct console_output *console_output = (struct console_output *)obj;
@@ -1584,11 +1633,16 @@ DECL_HANDLER(get_next_console_request)
 
     if (!server->console->renderer) server->console->renderer = current;
 
-    if (!req->signal) server->console->signaled = 0;
+    if (!req->signal)
+    {
+        server->console->signaled = 0;
+        fast_reset_event( server->console->fast_sync );
+    }
     else if (!server->console->signaled)
     {
         server->console->signaled = 1;
         wake_up( &server->console->obj, 0 );
+        fast_set_event( server->console->fast_sync );
     }
 
     if (req->read)
commit ef4412e3506440018c9698cb6433871cbf1b7025
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:01:09 2024 +1000

    server: Create fast synchronization objects for console servers.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/console.c b/server/console.c
index b17e78adbfe..d2dab94de16 100644
--- a/server/console.c
+++ b/server/console.c
@@ -148,6 +148,7 @@ struct console_server
     struct termios        termios;     /* original termios */
     int                   esync_fd;
     unsigned int          fsync_idx;
+    struct fast_sync     *fast_sync;   /* fast synchronization object */
 };
 
 static void console_server_dump( struct object *obj, int verbose );
@@ -160,6 +161,7 @@ static struct object *console_server_lookup_name( struct object *obj, struct uni
                                                 unsigned int attr, struct object *root );
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
+static struct fast_sync *console_server_get_fast_sync( struct object *obj );
 
 static const struct object_ops console_server_ops =
 {
@@ -183,7 +185,7 @@ static const struct object_ops console_server_ops =
     NULL,                             /* unlink_name */
     console_server_open_file,         /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    console_server_get_fast_sync,     /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     console_server_destroy            /* destroy */
 };
@@ -611,6 +613,7 @@ static int queue_host_ioctl( struct console_server *server, unsigned int code, u
     }
     list_add_tail( &server->queue, &ioctl->entry );
     wake_up( &server->obj, 0 );
+    fast_set_event( server->fast_sync );
     if (async) set_error( STATUS_PENDING );
     return 1;
 }
@@ -647,6 +650,7 @@ static void disconnect_console_server( struct console_server *server )
         server->console->server = NULL;
         server->console = NULL;
         wake_up( &server->obj, 0 );
+        fast_set_event( server->fast_sync );
     }
 }
 
@@ -932,6 +936,7 @@ static void console_server_destroy( struct object *obj )
     if (server->fd) release_object( server->fd );
     if (do_esync()) close( server->esync_fd );
     if (server->fsync_idx) fsync_free_shm_idx( server->fsync_idx );
+    if (server->fast_sync) release_object( server->fast_sync );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -1000,6 +1005,17 @@ static struct object *console_server_open_file( struct object *obj, unsigned int
     return grab_object( obj );
 }
 
+static struct fast_sync *console_server_get_fast_sync( struct object *obj )
+{
+    struct console_server *server = (struct console_server *)obj;
+    int signaled = !server->console || !list_empty( &server->queue );
+
+    if (!server->fast_sync)
+        server->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, signaled );
+    if (server->fast_sync) grab_object( server->fast_sync );
+    return server->fast_sync;
+}
+
 static struct object *create_console_server( void )
 {
     struct console_server *server;
@@ -1011,6 +1027,7 @@ static struct object *create_console_server( void )
     server->term_fd    = -1;
     list_init( &server->queue );
     list_init( &server->read_queue );
+    server->fast_sync = NULL;
     server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT );
     if (!server->fd)
     {
@@ -1668,6 +1685,8 @@ DECL_HANDLER(get_next_console_request)
             fsync_clear( &server->obj );
         if (do_esync() && list_empty( &server->queue ))
             esync_clear( server->esync_fd );
+        if (list_empty( &server->queue ))
+            fast_reset_event( server->fast_sync );
     }
 
     if (ioctl)
@@ -1757,6 +1776,8 @@ DECL_HANDLER(get_next_console_request)
         fsync_clear( &server->obj );
     if (do_esync() && list_empty( &server->queue ))
         esync_clear( server->esync_fd );
+    if (list_empty( &server->queue ))
+        fast_reset_event( server->fast_sync );
 
     release_object( server );
 }
commit 80d2051d71c5c95c3ce180f11db43af83bc93faa
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:01:50 2024 +1000

    server: Create fast synchronization objects for debug objects.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/debugger.c b/server/debugger.c
index fe123b0d60e..1abd7db57a6 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -71,6 +71,7 @@ struct debug_obj
     struct object        obj;         /* object header */
     struct list          event_queue; /* pending events queue */
     unsigned int         flags;       /* debug flags */
+    struct fast_sync    *fast_sync;   /* fast synchronization object */
 };
 
 
@@ -107,6 +108,7 @@ static const struct object_ops debug_event_ops =
 
 static void debug_obj_dump( struct object *obj, int verbose );
 static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *debug_obj_get_fast_sync( struct object *obj );
 static void debug_obj_destroy( struct object *obj );
 
 static const struct object_ops debug_obj_ops =
@@ -131,7 +133,7 @@ static const struct object_ops debug_obj_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_fast_sync,              /* get_fast_sync */
+    debug_obj_get_fast_sync,       /* get_fast_sync */
     no_close_handle,               /* close_handle */
     debug_obj_destroy              /* destroy */
 };
@@ -259,6 +261,7 @@ static void link_event( struct debug_obj *debug_obj, struct debug_event *event )
         /* grab reference since debugger could be killed while trying to wake up */
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        fast_set_event( debug_obj->fast_sync );
         release_object( debug_obj );
     }
 }
@@ -271,6 +274,7 @@ static void resume_event( struct debug_obj *debug_obj, struct debug_event *event
     {
         grab_object( debug_obj );
         wake_up( &debug_obj->obj, 0 );
+        fast_set_event( debug_obj->fast_sync );
         release_object( debug_obj );
     }
 }
@@ -336,6 +340,17 @@ static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entr
     return find_event_to_send( debug_obj ) != NULL;
 }
 
+static struct fast_sync *debug_obj_get_fast_sync( struct object *obj )
+{
+    struct debug_obj *debug_obj = (struct debug_obj *)obj;
+    int signaled = find_event_to_send( debug_obj ) != NULL;
+
+    if (!debug_obj->fast_sync)
+        debug_obj->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, signaled );
+    if (debug_obj->fast_sync) grab_object( debug_obj->fast_sync );
+    return debug_obj->fast_sync;
+}
+
 static void debug_obj_destroy( struct object *obj )
 {
     struct list *ptr;
@@ -348,6 +363,8 @@ static void debug_obj_destroy( struct object *obj )
     /* free all pending events */
     while ((ptr = list_head( &debug_obj->event_queue )))
         unlink_event( debug_obj, LIST_ENTRY( ptr, struct debug_event, entry ));
+
+    if (debug_obj->fast_sync) release_object( debug_obj->fast_sync );
 }
 
 struct debug_obj *get_debug_obj( struct process *process, obj_handle_t handle, unsigned int access )
@@ -367,6 +384,7 @@ static struct debug_obj *create_debug_obj( struct object *root, const struct uni
         {
             debug_obj->flags = flags;
             list_init( &debug_obj->event_queue );
+            debug_obj->fast_sync = NULL;
         }
     }
     return debug_obj;
@@ -575,6 +593,9 @@ DECL_HANDLER(wait_debug_event)
         reply->tid = get_thread_id( event->sender );
         alloc_event_handles( event, current->process );
         set_reply_data( &event->data, min( get_reply_max_size(), sizeof(event->data) ));
+
+        if (!find_event_to_send( debug_obj ))
+            fast_reset_event( debug_obj->fast_sync );
     }
     else
     {
commit 3c882bd880ee9024154d31ff1c459196760576ed
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:02:47 2024 +1000

    server: Create fast synchronization objects for device managers.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/device.c b/server/device.c
index a5d30941258..8d281e57b16 100644
--- a/server/device.c
+++ b/server/device.c
@@ -99,12 +99,14 @@ struct device_manager
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
     int                    esync_fd;       /* esync file descriptor */
     unsigned int           fsync_idx;
+    struct fast_sync      *fast_sync;      /* fast synchronization object */
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int device_manager_get_fsync_idx( struct object *obj, enum fsync_type *type );
+static struct fast_sync *device_manager_get_fast_sync( struct object *obj );
 static void device_manager_destroy( struct object *obj );
 
 static const struct object_ops device_manager_ops =
@@ -129,7 +131,7 @@ static const struct object_ops device_manager_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     no_kernel_obj_list,               /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    device_manager_get_fast_sync,     /* get_fast_sync */
     no_close_handle,                  /* close_handle */
     device_manager_destroy            /* destroy */
 };
@@ -435,7 +437,12 @@ static void add_irp_to_queue( struct device_manager *manager, struct irp_call *i
     irp->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     if (irp->file) list_add_tail( &irp->file->requests, &irp->dev_entry );
     list_add_tail( &manager->requests, &irp->mgr_entry );
-    if (list_head( &manager->requests ) == &irp->mgr_entry) wake_up( &manager->obj, 0 );  /* first one */
+    if (list_head( &manager->requests ) == &irp->mgr_entry)
+    {
+        /* first one */
+        wake_up( &manager->obj, 0 );
+        fast_set_event( manager->fast_sync );
+    }
 }
 
 static struct object *device_open_file( struct object *obj, unsigned int access,
@@ -775,6 +782,13 @@ static void delete_file( struct device_file *file )
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
 
+    /*
+     * TODO: esync/fsync code is doing this for every list item it seems.
+     *       I wonder why?
+     */
+    if (list_empty( &file->device->manager->requests ))
+        fast_reset_event( file->device->manager->fast_sync );
+
     release_object( file );
 }
 
@@ -820,6 +834,16 @@ static unsigned int device_manager_get_fsync_idx( struct object *obj, enum fsync
     return manager->fsync_idx;
 }
 
+static struct fast_sync *device_manager_get_fast_sync( struct object *obj )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+
+    if (!manager->fast_sync)
+        manager->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, !list_empty( &manager->requests ) );
+    if (manager->fast_sync) grab_object( manager->fast_sync );
+    return manager->fast_sync;
+}
+
 static void device_manager_destroy( struct object *obj )
 {
     struct device_manager *manager = (struct device_manager *)obj;
@@ -858,6 +882,7 @@ static void device_manager_destroy( struct object *obj )
     if (do_esync())
         close( manager->esync_fd );
     if (manager->fsync_idx) fsync_free_shm_idx( manager->fsync_idx );
+    if (manager->fast_sync) release_object( manager->fast_sync );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -867,6 +892,7 @@ static struct device_manager *create_device_manager(void)
     if ((manager = alloc_object( &device_manager_ops )))
     {
         manager->current_call = NULL;
+        manager->fast_sync = NULL;
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
@@ -1063,6 +1089,10 @@ DECL_HANDLER(get_next_device_request)
                 }
                 list_remove( &irp->mgr_entry );
                 list_init( &irp->mgr_entry );
+
+                if (list_empty( &manager->requests ))
+                    fast_reset_event( manager->fast_sync );
+
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;
commit b4838d0d6e50a9f4c4ec582c91641bbb05f86193
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:03:45 2024 +1000

    server: Create fast synchronization objects for keyed events.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/event.c b/server/event.c
index 0625c35a470..00dab332403 100644
--- a/server/event.c
+++ b/server/event.c
@@ -118,10 +118,13 @@ struct type_descr keyed_event_type =
 struct keyed_event
 {
     struct object  obj;             /* object header */
+    struct fast_sync *fast_sync;    /* fast synchronization object */
 };
 
 static void keyed_event_dump( struct object *obj, int verbose );
 static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *keyed_event_get_fast_sync( struct object *obj );
+static void keyed_event_destroy( struct object *obj );
 
 static const struct object_ops keyed_event_ops =
 {
@@ -145,9 +148,9 @@ static const struct object_ops keyed_event_ops =
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
     no_kernel_obj_list,          /* get_kernel_obj_list */
-    no_get_fast_sync,            /* get_fast_sync */
+    keyed_event_get_fast_sync,   /* get_fast_sync */
     no_close_handle,             /* close_handle */
-    no_destroy                   /* destroy */
+    keyed_event_destroy          /* destroy */
 };
 
 
@@ -336,6 +339,7 @@ struct keyed_event *create_keyed_event( struct object *root, const struct unicod
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
+            event->fast_sync = NULL;
         }
     }
     return event;
@@ -379,6 +383,23 @@ static int keyed_event_signaled( struct object *obj, struct wait_queue_entry *en
     return 0;
 }
 
+static struct fast_sync *keyed_event_get_fast_sync( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (!event->fast_sync)
+        event->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, 1 );
+    if (event->fast_sync) grab_object( event->fast_sync );
+    return event->fast_sync;
+}
+
+static void keyed_event_destroy( struct object *obj )
+{
+    struct keyed_event *event = (struct keyed_event *)obj;
+
+    if (event->fast_sync) release_object( event->fast_sync );
+}
+
 /* create an event */
 DECL_HANDLER(create_event)
 {
commit 4bad6dc45f224e86f0a6dd77e98f22a6ce2a07dc
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:04:23 2024 +1000

    server: Create fast synchronization objects for processes.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/process.c b/server/process.c
index 9263031b3af..8c086297f59 100644
--- a/server/process.c
+++ b/server/process.c
@@ -96,6 +96,7 @@ static unsigned int process_map_access( struct object *obj, unsigned int access
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
+static struct fast_sync *process_get_fast_sync( struct object *obj );
 static void process_destroy( struct object *obj );
 static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int process_get_fsync_idx( struct object *obj, enum fsync_type *type );
@@ -124,7 +125,7 @@ static const struct object_ops process_ops =
     NULL,                        /* unlink_name */
     no_open_file,                /* open_file */
     process_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_fast_sync,            /* get_fast_sync */
+    process_get_fast_sync,       /* get_fast_sync */
     no_close_handle,             /* close_handle */
     process_destroy              /* destroy */
 };
@@ -696,6 +697,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     process->rawinput_device_count = 0;
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
+    process->fast_sync       = NULL;
     memset( &process->image_info, 0, sizeof(process->image_info) );
     process->esync_fd        = -1;
     process->fsync_idx       = 0;
@@ -809,6 +811,7 @@ static void process_destroy( struct object *obj )
     free( process->rawinput_devices );
     free( process->dir_cache );
     free( process->image );
+    if (process->fast_sync) release_object( process->fast_sync );
     if (do_esync()) close( process->esync_fd );
     if (process->fsync_idx)
     {
@@ -860,6 +863,16 @@ static struct list *process_get_kernel_obj_list( struct object *obj )
     return &process->kernel_object;
 }
 
+static struct fast_sync *process_get_fast_sync( struct object *obj )
+{
+    struct process *process = (struct process *)obj;
+
+    if (!process->fast_sync)
+        process->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, !process->running_threads );
+    if (process->fast_sync) grab_object( process->fast_sync );
+    return process->fast_sync;
+}
+
 static struct security_descriptor *process_get_sd( struct object *obj )
 {
     static struct security_descriptor *process_default_sd;
@@ -1024,6 +1037,7 @@ static void process_killed( struct process *process )
     release_job_process( process );
     start_sigkill_timer( process );
     wake_up( &process->obj, 0 );
+    fast_set_event( process->fast_sync );
 }
 
 /* add a thread to a process running threads list */
diff --git a/server/process.h b/server/process.h
index 7d7a1f3bfcf..4dc216e9498 100644
--- a/server/process.h
+++ b/server/process.h
@@ -88,6 +88,7 @@ struct process
     pe_image_info_t      image_info;      /* main exe image info */
     int                  esync_fd;        /* esync file descriptor (signaled on exit) */
     unsigned int         fsync_idx;
+    struct fast_sync    *fast_sync;       /* fast synchronization object */
     struct cpu_topology_override cpu_override; /* Overridden CPUs to host CPUs mapping. */
     unsigned char   wine_cpu_id_from_host[64]; /* Host to overridden CPU mapping. */
 };
commit 28b16b0a08cbf23101134b9838647d03ac7620a7
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:04:52 2024 +1000

    server: Create fast synchronization objects for jobs.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/process.c b/server/process.c
index 8c086297f59..8dab996d382 100644
--- a/server/process.c
+++ b/server/process.c
@@ -202,6 +202,7 @@ struct type_descr job_type =
 
 static void job_dump( struct object *obj, int verbose );
 static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *job_get_fast_sync( struct object *obj );
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
@@ -219,6 +220,7 @@ struct job
     struct job *parent;
     struct list parent_job_entry;  /* list entry for parent job */
     struct list child_job_list;    /* list of child jobs */
+    struct fast_sync *fast_sync;   /* fast synchronization object */
 };
 
 static const struct object_ops job_ops =
@@ -243,7 +245,7 @@ static const struct object_ops job_ops =
     default_unlink_name,           /* unlink_name */
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_get_fast_sync,              /* get_fast_sync */
+    job_get_fast_sync,             /* get_fast_sync */
     job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
@@ -268,6 +270,7 @@ static struct job *create_job_object( struct object *root, const struct unicode_
             job->completion_port = NULL;
             job->completion_key = 0;
             job->parent = NULL;
+            job->fast_sync = NULL;
         }
     }
     return job;
@@ -424,6 +427,17 @@ static void terminate_job( struct job *job, int exit_code )
     job->terminating = 0;
     job->signaled = 1;
     wake_up( &job->obj, 0 );
+    fast_set_event( job->fast_sync );
+}
+
+static struct fast_sync *job_get_fast_sync( struct object *obj )
+{
+    struct job *job = (struct job *)obj;
+
+    if (!job->fast_sync)
+        job->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, job->signaled );
+    if (job->fast_sync) grab_object( job->fast_sync );
+    return job->fast_sync;
 }
 
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -454,6 +468,8 @@ static void job_destroy( struct object *obj )
         list_remove( &job->parent_job_entry );
         release_object( job->parent );
     }
+
+    if (job->fast_sync) release_object( job->fast_sync );
 }
 
 static void job_dump( struct object *obj, int verbose )
commit 0fe9eca3a1e59d8809367bc149fbd04448527368
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:05:52 2024 +1000

    server: Create fast synchronization objects for message queues.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/queue.c b/server/queue.c
index ab4ca4bc343..989afffbb0b 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -136,6 +136,7 @@ struct msg_queue
     struct thread_input   *input;           /* thread input descriptor */
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
+    struct fast_sync      *fast_sync;       /* fast synchronization object */
     int                    keystate_lock;   /* owns an input keystate lock */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
@@ -161,6 +162,7 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
 static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int msg_queue_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *msg_queue_get_fast_sync( struct object *obj );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
 static void thread_input_dump( struct object *obj, int verbose );
@@ -189,7 +191,7 @@ static const struct object_ops msg_queue_ops =
     NULL,                      /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    msg_queue_get_fast_sync,   /* get_fast_sync */
     no_close_handle,           /* close_handle */
     msg_queue_destroy          /* destroy */
 };
@@ -369,6 +371,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->input           = (struct thread_input *)grab_object( input );
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
+        queue->fast_sync       = NULL;
         queue->keystate_lock   = 0;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
@@ -619,7 +622,11 @@ static inline void set_queue_bits( struct msg_queue *queue, unsigned int bits )
     queue->shared->changed_bits = queue->changed_bits;
     SHARED_WRITE_END( &queue->shared->seq );
 
-    if (is_signaled( queue )) wake_up( &queue->obj, 0 );
+    if (is_signaled( queue ))
+    {
+        wake_up( &queue->obj, 0 );
+        fast_set_event( queue->fast_sync );
+    }
 }
 
 /* clear some queue bits */
@@ -633,6 +640,9 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
         queue->keystate_lock = 0;
     }
 
+    if (!is_signaled( queue ))
+        fast_reset_event( queue->fast_sync );
+
     if (do_fsync() && !is_signaled( queue ))
         fsync_clear( &queue->obj );
 
@@ -1216,6 +1226,7 @@ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *en
     struct msg_queue *queue = (struct msg_queue *)obj;
     queue->wake_mask = 0;
     queue->changed_mask = 0;
+    fast_reset_event( queue->fast_sync );
 
     SHARED_WRITE_BEGIN( &queue->shared->seq );
     queue->shared->wake_mask = queue->wake_mask;
@@ -1223,6 +1234,16 @@ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *en
     SHARED_WRITE_END( &queue->shared->seq );
 }
 
+static struct fast_sync *msg_queue_get_fast_sync( struct object *obj )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+
+    if (!queue->fast_sync)
+        queue->fast_sync = fast_create_event( FAST_SYNC_QUEUE, is_signaled( queue ) );
+    if (queue->fast_sync) grab_object( queue->fast_sync );
+    return queue->fast_sync;
+}
+
 static void cleanup_msg_queue( struct msg_queue *queue )
 {
     struct list *ptr;
@@ -1261,6 +1282,7 @@ static void cleanup_msg_queue( struct msg_queue *queue )
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
+    if (queue->fast_sync) release_object( queue->fast_sync );
     if (do_esync()) close( queue->esync_fd );
     queue->destroyed = 1;
 }
@@ -1290,6 +1312,7 @@ static void msg_queue_poll_event( struct fd *fd, int event )
     if (event & (POLLERR | POLLHUP)) set_fd_events( fd, -1 );
     else set_fd_events( queue->fd, 0 );
     wake_up( &queue->obj, 0 );
+    fast_set_event( queue->fast_sync );
 }
 
 static void thread_input_dump( struct object *obj, int verbose )
@@ -2803,14 +2826,21 @@ DECL_HANDLER(set_queue_mask)
             if (req->skip_wait)
             {
                 queue->wake_mask = queue->changed_mask = 0;
+                fast_reset_event( queue->fast_sync );
                 SHARED_WRITE_BEGIN( &queue->shared->seq );
                 queue->shared->wake_mask = queue->wake_mask;
                 queue->shared->changed_mask = queue->changed_mask;
                 SHARED_WRITE_END( &queue->shared->seq );
             }
-            else wake_up( &queue->obj, 0 );
+            else {
+                wake_up( &queue->obj, 0 );
+                fast_set_event( queue->fast_sync );
+            }
         }
 
+        if (!is_signaled( queue ))
+            fast_reset_event( queue->fast_sync );
+
         if (do_fsync() && !is_signaled( queue ))
             fsync_clear( &queue->obj );
 
@@ -2830,6 +2860,9 @@ DECL_HANDLER(get_queue_status)
         reply->changed_bits = queue->changed_bits;
         queue->changed_bits &= ~req->clear_bits;
 
+        if (!is_signaled( queue ))
+            fast_reset_event( queue->fast_sync );
+
         if (do_fsync() && !is_signaled( queue ))
             fsync_clear( &queue->obj );
 
@@ -3018,6 +3051,9 @@ DECL_HANDLER(get_message)
     if (filter & QS_INPUT) queue->changed_bits &= ~QS_INPUT;
     if (filter & QS_PAINT) queue->changed_bits &= ~QS_PAINT;
 
+    if (!is_signaled( queue ))
+        fast_reset_event( queue->fast_sync );
+
     SHARED_WRITE_BEGIN( &queue->shared->seq );
     queue->shared->changed_bits = queue->changed_bits;
     SHARED_WRITE_END( &queue->shared->seq );
@@ -3076,6 +3112,8 @@ DECL_HANDLER(get_message)
     queue->wake_mask = req->wake_mask;
     queue->changed_mask = req->changed_mask;
 
+    fast_reset_event( queue->fast_sync );
+
     SHARED_WRITE_BEGIN( &queue->shared->seq );
     queue->shared->wake_mask = queue->wake_mask;
     queue->shared->changed_mask = queue->changed_mask;
commit 275df87f57ae2a15bf6b3255a17a5a1d35172b64
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:06:34 2024 +1000

    server: Create fast synchronization objects for threads.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/thread.c b/server/thread.c
index 7d490b28c7a..7494a485adb 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -197,6 +197,7 @@ static unsigned int thread_get_fsync_idx( struct object *obj, enum fsync_type *t
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
+static struct fast_sync *thread_get_fast_sync( struct object *obj );
 static void destroy_thread( struct object *obj );
 
 static const struct object_ops thread_ops =
@@ -221,7 +222,7 @@ static const struct object_ops thread_ops =
     NULL,                       /* unlink_name */
     no_open_file,               /* open_file */
     thread_get_kernel_obj_list, /* get_kernel_obj_list */
-    no_get_fast_sync,           /* get_fast_sync */
+    thread_get_fast_sync,       /* get_fast_sync */
     no_close_handle,            /* close_handle */
     destroy_thread              /* destroy */
 };
@@ -296,6 +297,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->token           = NULL;
     thread->desc            = NULL;
     thread->desc_len        = 0;
+    thread->fast_sync       = NULL;
     thread->queue_shared_mapping = NULL;
     thread->queue_shared         = NULL;
     thread->input_shared_mapping = NULL;
@@ -528,6 +530,16 @@ static struct list *thread_get_kernel_obj_list( struct object *obj )
     return &thread->kernel_object;
 }
 
+static struct fast_sync *thread_get_fast_sync( struct object *obj )
+{
+    struct thread *thread = (struct thread *)obj;
+
+    if (!thread->fast_sync)
+        thread->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, thread->state == TERMINATED );
+    if (thread->fast_sync) grab_object( thread->fast_sync );
+    return thread->fast_sync;
+}
+
 /* cleanup everything that is no longer needed by a dead thread */
 /* used by destroy_thread and kill_thread */
 static void cleanup_thread( struct thread *thread )
@@ -598,6 +610,7 @@ static void destroy_thread( struct object *obj )
         fsync_free_shm_idx( thread->fsync_idx );
         fsync_free_shm_idx( thread->fsync_apc_idx );
     }
+    if (thread->fast_sync) release_object( thread->fast_sync );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1570,6 +1583,7 @@ void kill_thread( struct thread *thread, int violent_death )
     if (do_esync())
         esync_abandon_mutexes( thread );
     wake_up( &thread->obj, 0 );
+    fast_set_event( thread->fast_sync );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
diff --git a/server/thread.h b/server/thread.h
index 067fea940cf..2f89edd122f 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -95,6 +95,7 @@ struct thread
     struct list            kernel_object; /* list of kernel object pointers */
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
+    struct fast_sync      *fast_sync;     /* fast synchronization object */
     struct object         *locked_completion; /* completion port wait object successfully waited by the thread */
     struct object         *queue_shared_mapping; /* thread queue shared memory mapping */
     volatile struct queue_shared_memory *queue_shared;  /* thread queue shared memory ptr */
commit b8e2f5573e0038df00e2db12fcb528a35f98d219
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:07:01 2024 +1000

    server: Create fast synchronization objects for timers.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/timer.c b/server/timer.c
index 4de4787de0d..94720dd8a8c 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -65,6 +65,7 @@ struct timer
     client_ptr_t         arg;       /* callback argument */
     int                  esync_fd;  /* esync file descriptor */
     unsigned int         fsync_idx; /* fsync shm index */
+    struct fast_sync    *fast_sync; /* fast synchronization object */
 };
 
 static void timer_dump( struct object *obj, int verbose );
@@ -72,6 +73,7 @@ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int timer_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static struct fast_sync *timer_get_fast_sync( struct object *obj );
 static void timer_destroy( struct object *obj );
 
 static const struct object_ops timer_ops =
@@ -96,7 +98,7 @@ static const struct object_ops timer_ops =
     default_unlink_name,       /* unlink_name */
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    timer_get_fast_sync,       /* get_fast_sync */
     no_close_handle,           /* close_handle */
     timer_destroy              /* destroy */
 };
@@ -121,6 +123,7 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->thread   = NULL;
             timer->esync_fd = -1;
             timer->fsync_idx = 0;
+            timer->fast_sync = NULL;
 
             if (do_fsync())
                 timer->fsync_idx = fsync_alloc_shm( 0, 0 );
@@ -168,6 +171,7 @@ static void timer_callback( void *private )
     /* wake up waiters */
     timer->signaled = 1;
     wake_up( &timer->obj, 0 );
+    fast_set_event( timer->fast_sync );
 }
 
 /* cancel a running timer */
@@ -199,6 +203,8 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
 
+        fast_reset_event( timer->fast_sync );
+
         if (do_fsync())
             fsync_clear( &timer->obj );
 
@@ -252,6 +258,19 @@ static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry
     if (!timer->manual) timer->signaled = 0;
 }
 
+static struct fast_sync *timer_get_fast_sync( struct object *obj )
+{
+    struct timer *timer = (struct timer *)obj;
+
+    if (!timer->fast_sync)
+    {
+        enum fast_sync_type type = timer->manual ? FAST_SYNC_MANUAL_SERVER : FAST_SYNC_AUTO_SERVER;
+        timer->fast_sync = fast_create_event( type, timer->signaled );
+    }
+    if (timer->fast_sync) grab_object( timer->fast_sync );
+    return timer->fast_sync;
+}
+
 static void timer_destroy( struct object *obj )
 {
     struct timer *timer = (struct timer *)obj;
@@ -261,6 +280,7 @@ static void timer_destroy( struct object *obj )
     if (timer->thread) release_object( timer->thread );
     if (do_esync()) close( timer->esync_fd );
     if (timer->fsync_idx) fsync_free_shm_idx( timer->fsync_idx );
+    if (timer->fast_sync) release_object( timer->fast_sync );
 }
 
 /* create a timer */
commit d64fbfede6b0b8e3e8bcb138b94c0cd91c059054
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:08:44 2024 +1000

    server: Create fast synchronization objects for fd-based objects.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/change.c b/server/change.c
index f0f3f27dfe5..c658b7181ab 100644
--- a/server/change.c
+++ b/server/change.c
@@ -126,7 +126,7 @@ static const struct object_ops dir_ops =
     NULL,                     /* unlink_name */
     no_open_file,             /* open_file */
     no_kernel_obj_list,       /* get_kernel_obj_list */
-    no_get_fast_sync,         /* get_fast_sync */
+    default_fd_get_fast_sync, /* get_fast_sync */
     dir_close_handle,         /* close_handle */
     dir_destroy               /* destroy */
 };
diff --git a/server/device.c b/server/device.c
index 8d281e57b16..2d69e3297ef 100644
--- a/server/device.c
+++ b/server/device.c
@@ -246,7 +246,7 @@ static const struct object_ops device_file_ops =
     NULL,                             /* unlink_name */
     no_open_file,                     /* open_file */
     device_file_get_kernel_obj_list,  /* get_kernel_obj_list */
-    no_get_fast_sync,                 /* get_fast_sync */
+    default_fd_get_fast_sync,         /* get_fast_sync */
     device_file_close_handle,         /* close_handle */
     device_file_destroy               /* destroy */
 };
diff --git a/server/fd.c b/server/fd.c
index 7d42c2b54d3..b8c3229b8e5 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -197,6 +197,7 @@ struct fd
     unsigned int         comp_flags;  /* completion flags */
     int                  esync_fd;    /* esync file descriptor */
     unsigned int         fsync_idx;   /* fsync shm index */
+    struct fast_sync    *fast_sync;   /* fast synchronization object */
 };
 
 static void fd_dump( struct object *obj, int verbose );
@@ -1607,6 +1608,7 @@ static void fd_destroy( struct object *obj )
     if (do_esync())
         close( fd->esync_fd );
     if (fd->fsync_idx) fsync_free_shm_idx( fd->fsync_idx );
+    if (fd->fast_sync) release_object( fd->fast_sync );
 }
 
 /* check if the desired access is possible without violating */
@@ -1725,6 +1727,7 @@ static struct fd *alloc_fd_object(void)
     fd->comp_flags = 0;
     fd->esync_fd   = -1;
     fd->fsync_idx  = 0;
+    fd->fast_sync  = NULL;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
@@ -1772,6 +1775,7 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
     fd->esync_fd   = -1;
     fd->fsync_idx  = 0;
+    fd->fast_sync  = NULL;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
@@ -2246,13 +2250,21 @@ void set_fd_signaled( struct fd *fd, int signaled )
 {
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
-    if (signaled) wake_up( fd->user, 0 );
+    if (signaled)
+    {
+        wake_up( fd->user, 0 );
+        fast_set_event( fd->fast_sync );
+    }
+    else
+    {
+        if (do_fsync())
+            fsync_clear( fd->user );
 
-    if (do_fsync() && !signaled)
-        fsync_clear( fd->user );
+        if (do_esync())
+            esync_clear( fd->esync_fd );
 
-    if (do_esync() && !signaled)
-        esync_clear( fd->esync_fd );
+        fast_reset_event( fd->fast_sync );
+    }
 }
 
 /* check if events are pending and if yes return which one(s) */
@@ -2269,6 +2281,19 @@ int check_fd_events( struct fd *fd, int events )
     return pfd.revents;
 }
 
+struct fast_sync *default_fd_get_fast_sync( struct object *obj )
+{
+    struct fd *fd = get_obj_fd( obj );
+    struct fast_sync *ret;
+
+    if (!fd->fast_sync)
+        fd->fast_sync = fast_create_event( FAST_SYNC_MANUAL_SERVER, fd->signaled );
+    ret = fd->fast_sync;
+    release_object( fd );
+    if (ret) grab_object( ret );
+    return ret;
+}
+
 /* default signaled() routine for objects that poll() on an fd */
 int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
diff --git a/server/file.c b/server/file.c
index 3968e6441e4..23ac327a775 100644
--- a/server/file.c
+++ b/server/file.c
@@ -137,7 +137,7 @@ static const struct object_ops file_ops =
     NULL,                         /* unlink_name */
     file_open_file,               /* open_file */
     file_get_kernel_obj_list,     /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     no_close_handle,              /* close_handle */
     file_destroy                  /* destroy */
 };
diff --git a/server/file.h b/server/file.h
index 4f835ab1e99..e3eb1c25a7b 100644
--- a/server/file.h
+++ b/server/file.h
@@ -110,6 +110,7 @@ extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
 extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
 extern unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type );
+extern struct fast_sync *default_fd_get_fast_sync( struct object *obj );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
 extern void fd_cancel_async( struct fd *fd, struct async *async );
diff --git a/server/mailslot.c b/server/mailslot.c
index 0c7be874cfb..8e1b39e2476 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -88,7 +88,7 @@ static const struct object_ops mailslot_ops =
     default_unlink_name,       /* unlink_name */
     mailslot_open_file,        /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_get_fast_sync,          /* get_fast_sync */
+    default_fd_get_fast_sync,  /* get_fast_sync */
     no_close_handle,           /* close_handle */
     mailslot_destroy           /* destroy */
 };
@@ -249,7 +249,7 @@ static const struct object_ops mailslot_device_file_ops =
     NULL,                                   /* unlink_name */
     no_open_file,                           /* open_file */
     no_kernel_obj_list,                     /* get_kernel_obj_list */
-    no_get_fast_sync,                       /* get_fast_sync */
+    default_fd_get_fast_sync,               /* get_fast_sync */
     no_close_handle,                        /* close_handle */
     mailslot_device_file_destroy            /* destroy */
 };
diff --git a/server/named_pipe.c b/server/named_pipe.c
index aa53faec6a3..f0725943a14 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -184,7 +184,7 @@ static const struct object_ops pipe_server_ops =
     NULL,                         /* unlink_name */
     pipe_server_open_file,        /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_server_destroy           /* destroy */
 };
@@ -231,7 +231,7 @@ static const struct object_ops pipe_client_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     async_close_obj_handle,       /* close_handle */
     pipe_end_destroy              /* destroy */
 };
@@ -315,7 +315,7 @@ static const struct object_ops named_pipe_device_file_ops =
     NULL,                                    /* unlink_name */
     no_open_file,                            /* open_file */
     no_kernel_obj_list,                      /* get_kernel_obj_list */
-    no_get_fast_sync,                        /* get_fast_sync */
+    default_fd_get_fast_sync,                /* get_fast_sync */
     no_close_handle,                         /* close_handle */
     named_pipe_device_file_destroy           /* destroy */
 };
diff --git a/server/serial.c b/server/serial.c
index 8660a2ba90a..d3d70b7d379 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -99,7 +99,7 @@ static const struct object_ops serial_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     no_close_handle,              /* close_handle */
     serial_destroy                /* destroy */
 };
diff --git a/server/sock.c b/server/sock.c
index 8d6f7ceae9b..39ba452000e 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -464,7 +464,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    no_get_fast_sync,             /* get_fast_sync */
+    default_fd_get_fast_sync,     /* get_fast_sync */
     sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
commit 8da3d3d88ea14de4efb1a323bbb701b66f71f358
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:09:28 2024 +1000

    server: Add a request to retrieve the fast synchronization device.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail
    
    As noted in an earlier commit, the parts that are wrapped with
    HAVE_LINUX_WINESYNC_H have the ifdefs and stubs removed for
    Proton usage.

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 0825ba94f7e..6d2c3b13054 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -29,6 +29,8 @@
 #include "winternl.h"
 
 #include "file.h"
+#include "handle.h"
+#include "request.h"
 #include "thread.h"
 
 #include <fcntl.h>
@@ -347,3 +349,14 @@ void fast_abandon_mutexes( thread_id_t tid )
     ioctl( get_unix_fd( device->fd ), WINESYNC_IOC_KILL_OWNER, &tid );
     release_object( device );
 }
+
+DECL_HANDLER(get_linux_sync_device)
+{
+    struct linux_device *device;
+
+    if ((device = get_linux_device()))
+    {
+        reply->handle = alloc_handle( current->process, device, 0, 0 );
+        release_object( device );
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index d02af29a4f8..edcb49f2e6a 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4000,3 +4000,9 @@ enum fast_sync_type
     FAST_SYNC_MANUAL_SERVER,
     FAST_SYNC_QUEUE,
 };
+
+/* Obtain a handle to the fast synchronization device object */
+@REQ(get_linux_sync_device)
+@REPLY
+    obj_handle_t handle;          /* handle to the device */
+@END
commit cad4da08ee45b9304db63672b1a4885dca84e9a5
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:10:03 2024 +1000

    server: Add a request to retrieve the fast synchronization object from a handle.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail
    
    As noted in an earlier commit, the parts that are wrapped with
    HAVE_LINUX_WINESYNC_H have the ifdefs and stubs removed for
    Proton usage.

diff --git a/server/fast_sync.c b/server/fast_sync.c
index 6d2c3b13054..1d7d5ddff52 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -360,3 +360,23 @@ DECL_HANDLER(get_linux_sync_device)
         release_object( device );
     }
 }
+
+DECL_HANDLER(get_linux_sync_obj)
+{
+    struct object *obj;
+
+    if ((obj = get_handle_obj( current->process, req->handle, 0, NULL )))
+    {
+        struct fast_sync *fast_sync;
+
+        if ((fast_sync = obj->ops->get_fast_sync( obj )))
+        {
+            reply->handle = alloc_handle( current->process, fast_sync, 0, 0 );
+            reply->obj = fast_sync->linux_obj;
+            reply->type = fast_sync->type;
+            reply->access = get_handle_access( current->process, req->handle );
+            release_object( fast_sync );
+        }
+        release_object( obj );
+    }
+}
diff --git a/server/protocol.def b/server/protocol.def
index edcb49f2e6a..594836c45b4 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4006,3 +4006,13 @@ enum fast_sync_type
 @REPLY
     obj_handle_t handle;          /* handle to the device */
 @END
+
+/* Get the fast synchronization object associated with the given handle */
+@REQ(get_linux_sync_obj)
+    obj_handle_t handle;          /* handle to the object */
+@REPLY
+    obj_handle_t handle;          /* handle to the fast synchronization object */
+    int          obj;             /* linux object */
+    int          type;            /* object type */
+    unsigned int access;          /* handle access rights */
+@END
commit 9656959305005f9c6468d4f07ae7e36975e38a93
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:10:41 2024 +1000

    server: Introduce fast_select_queue and fast_unselect_queue requests.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/protocol.def b/server/protocol.def
index 594836c45b4..2b7c1eb343a 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4016,3 +4016,15 @@ enum fast_sync_type
     int          type;            /* object type */
     unsigned int access;          /* handle access rights */
 @END
+
+/* Begin a client-side wait on a message queue */
+@REQ(fast_select_queue)
+    obj_handle_t handle;          /* handle to the queue */
+@END
+
+
+/* End a client-side wait on a message queue */
+@REQ(fast_unselect_queue)
+    obj_handle_t handle;          /* handle to the queue */
+    int          signaled;        /* was the queue signaled? */
+@END
diff --git a/server/queue.c b/server/queue.c
index 989afffbb0b..d764db0503a 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -137,6 +137,7 @@ struct msg_queue
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
     struct fast_sync      *fast_sync;       /* fast synchronization object */
+    int                    in_fast_wait;    /* are we in a client-side wait? */
     int                    keystate_lock;   /* owns an input keystate lock */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
@@ -372,6 +373,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->fast_sync       = NULL;
+        queue->in_fast_wait    = 0;
         queue->keystate_lock   = 0;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
@@ -1146,6 +1148,9 @@ static int is_queue_hung( struct msg_queue *queue )
             return 0;  /* thread is waiting on queue -> not hung */
     }
 
+    if (queue->in_fast_wait)
+        return 0;  /* thread is waiting on queue in absentia -> not hung */
+
     if (do_fsync() && queue->fsync_in_msgwait)
         return 0;   /* thread is waiting on queue in absentia -> not hung */
 
@@ -3890,3 +3895,56 @@ DECL_HANDLER(fsync_msgwait)
     if (queue->fd)
         set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
 }
+
+DECL_HANDLER(fast_select_queue)
+{
+    struct msg_queue *queue;
+
+    if (!(queue = (struct msg_queue *)get_handle_obj( current->process, req->handle,
+                                                      SYNCHRONIZE, &msg_queue_ops )))
+        return;
+
+    /* a thread can only wait on its own queue */
+    if (current->queue != queue || queue->in_fast_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (current->process->idle_event && !(queue->wake_mask & QS_SMRESULT))
+            set_event( current->process->idle_event );
+
+        if (queue->fd)
+            set_fd_events( queue->fd, POLLIN );
+
+        queue->in_fast_wait = 1;
+    }
+
+    release_object( queue );
+}
+
+DECL_HANDLER(fast_unselect_queue)
+{
+    struct msg_queue *queue;
+
+    if (!(queue = (struct msg_queue *)get_handle_obj( current->process, req->handle,
+                                                      SYNCHRONIZE, &msg_queue_ops )))
+        return;
+
+    if (current->queue != queue || !queue->in_fast_wait)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+    }
+    else
+    {
+        if (queue->fd)
+            set_fd_events( queue->fd, 0 );
+
+        if (req->signaled)
+            msg_queue_satisfied( &queue->obj, NULL );
+
+        queue->in_fast_wait = 0;
+    }
+
+    release_object( queue );
+}
commit 2efb475d6b1d0e0e7cbf1f01e854135989d87bf7
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:14:33 2024 +1000

    server: Allow creating an event object for client-side user APC signaling.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/server/protocol.def b/server/protocol.def
index 2b7c1eb343a..66050f68b86 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4028,3 +4028,9 @@ enum fast_sync_type
     obj_handle_t handle;          /* handle to the queue */
     int          signaled;        /* was the queue signaled? */
 @END
+
+/* Get an event handle to be used for thread alerts with fast synchronization */
+@REQ(get_fast_alert_event)
+@REPLY
+    obj_handle_t handle;          /* handle to the event */
+@END
diff --git a/server/thread.c b/server/thread.c
index 7494a485adb..1cacbd0ea25 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -298,6 +298,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->desc            = NULL;
     thread->desc_len        = 0;
     thread->fast_sync       = NULL;
+    thread->fast_alert_event = NULL;
     thread->queue_shared_mapping = NULL;
     thread->queue_shared         = NULL;
     thread->input_shared_mapping = NULL;
@@ -611,6 +612,7 @@ static void destroy_thread( struct object *obj )
         fsync_free_shm_idx( thread->fsync_apc_idx );
     }
     if (thread->fast_sync) release_object( thread->fast_sync );
+    if (thread->fast_alert_event) release_object( thread->fast_alert_event );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -1423,6 +1425,9 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
     {
         wake_thread( thread );
 
+        if (apc->call.type == APC_USER && thread->fast_alert_event)
+            set_event( thread->fast_alert_event );
+
         if (do_fsync() && queue == &thread->user_apc)
             fsync_wake_futex( thread->fsync_apc_idx );
 
@@ -1460,6 +1465,8 @@ void thread_cancel_apc( struct thread *thread, struct object *owner, enum apc_ty
         apc->executed = 1;
         wake_up( &apc->obj, 0 );
         release_object( apc );
+        if (list_empty( &thread->user_apc ) && thread->fast_alert_event)
+            reset_event( thread->fast_alert_event );
         return;
     }
 }
@@ -1474,6 +1481,9 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system
     {
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
+
+        if (list_empty( &thread->user_apc ) && thread->fast_alert_event)
+            reset_event( thread->fast_alert_event );
     }
 
     if (do_fsync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
@@ -2313,3 +2323,12 @@ DECL_HANDLER(get_next_thread)
     set_error( STATUS_NO_MORE_ENTRIES );
     release_object( process );
 }
+
+DECL_HANDLER(get_fast_alert_event)
+{
+    if (!current->fast_alert_event)
+        current->fast_alert_event = create_event( NULL, NULL, 0, 1, !list_empty( &current->user_apc ), NULL );
+
+    if (current->fast_alert_event)
+        reply->handle = alloc_handle( current->process, current->fast_alert_event, SYNCHRONIZE, 0 );
+}
diff --git a/server/thread.h b/server/thread.h
index 2f89edd122f..a4242c2fb3a 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -96,6 +96,7 @@ struct thread
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
     struct fast_sync      *fast_sync;     /* fast synchronization object */
+    struct event          *fast_alert_event; /* fast synchronization alert event */
     struct object         *locked_completion; /* completion port wait object successfully waited by the thread */
     struct object         *queue_shared_mapping; /* thread queue shared memory mapping */
     volatile struct queue_shared_memory *queue_shared;  /* thread queue shared memory ptr */
commit 94827120daec579b7f9ccf651b865ad1efb95adc
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:15:53 2024 +1000

    ntdll: Introduce a helper to wait on an internal server handle.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 7955a88b622..4c430ab28e3 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6722,7 +6722,7 @@ NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void
         }
         if (handle)
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
             NtClose( handle );
         }
         else  /* Unix lock conflict, sleep a bit and retry */
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 3e3c24c702c..4163e626c7c 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -871,7 +871,7 @@ NTSTATUS WINAPI NtCreateUserProcess( HANDLE *process_handle_ptr, HANDLE *thread_
 
     /* wait for the new process info to be ready */
 
-    NtWaitForSingleObject( process_info, FALSE, NULL );
+    server_wait_for_object( process_info, FALSE, NULL );
     SERVER_START_REQ( get_new_process_info )
     {
         req->info = wine_server_obj_handle( process_info );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 0658185c2e1..61408e09857 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -709,6 +709,20 @@ unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT f
     return ret;
 }
 
+/* helper function to perform a server-side wait on an internal handle without
+ * using the fast synchronization path */
+unsigned int server_wait_for_object( HANDLE handle, BOOL alertable, const LARGE_INTEGER *timeout )
+{
+    select_op_t select_op;
+    UINT flags = SELECT_INTERRUPTIBLE;
+
+    if (alertable) flags |= SELECT_ALERTABLE;
+
+    select_op.wait.op = SELECT_WAIT;
+    select_op.wait.handles[0] = wine_server_obj_handle( handle );
+    return server_wait( &select_op, offsetof( select_op_t, wait.handles[1] ), flags, timeout );
+}
+
 
 /***********************************************************************
  *              NtContinue  (NTDLL.@)
@@ -771,7 +785,7 @@ unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call, a
         }
         else
         {
-            NtWaitForSingleObject( handle, FALSE, NULL );
+            server_wait_for_object( handle, FALSE, NULL );
 
             SERVER_START_REQ( get_apc_result )
             {
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 4c9101d9faa..e8bdaea4291 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1753,7 +1753,7 @@ NTSTATUS get_thread_context( HANDLE handle, void *context, BOOL *self, USHORT ma
 
     if (ret == STATUS_PENDING)
     {
-        NtWaitForSingleObject( context_handle, FALSE, NULL );
+        server_wait_for_object( context_handle, FALSE, NULL );
 
         SERVER_START_REQ( get_thread_context )
         {
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 47a21bd93bd..46cc5f1391a 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -182,6 +182,8 @@ extern unsigned int server_select( const select_op_t *select_op, data_size_t siz
                                    timeout_t abs_timeout, context_t *context, user_apc_t *user_apc ) DECLSPEC_HIDDEN;
 extern unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
                                  const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
+extern unsigned int server_wait_for_object( HANDLE handle, BOOL alertable,
+                                            const LARGE_INTEGER *timeout ) DECLSPEC_HIDDEN;
 extern unsigned int server_queue_process_apc( HANDLE process, const apc_call_t *call,
                                               apc_result_t *result ) DECLSPEC_HIDDEN;
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
@@ -384,7 +386,7 @@ static inline async_data_t server_async( HANDLE handle, struct async_fileio *use
 
 static inline NTSTATUS wait_async( HANDLE handle, BOOL alertable )
 {
-    return NtWaitForSingleObject( handle, alertable, NULL );
+    return server_wait_for_object( handle, alertable, NULL );
 }
 
 static inline BOOL in_wow64_call(void)
commit 51959d24780c29f83af2b397673f1bb658e20f08
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:16:30 2024 +1000

    ntdll: Add some traces to synchronization methods.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 62a8d9d3171..d6703289f08 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -74,7 +74,8 @@ HANDLE keyed_event = 0;
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
 {
     if (!timeout) return "(infinite)";
-    return wine_dbgstr_longlong( timeout->QuadPart );
+    return wine_dbg_sprintf( "%lld.%07ld", (long long)(timeout->QuadPart / TICKSPERSEC),
+                             (long)(timeout->QuadPart % TICKSPERSEC) );
 }
 
 /* return a monotonic time counter, in Win32 ticks */
@@ -271,6 +272,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, initial %d, max %d\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", initial, max );
+
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -304,6 +308,8 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
 
     if (do_fsync())
@@ -376,6 +382,8 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 {
     unsigned int ret;
 
+    TRACE( "handle %p, count %u, prev_count %p\n", handle, count, previous );
+
     if (do_fsync())
         return fsync_release_semaphore( handle, count, previous );
 
@@ -406,6 +414,9 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u, state %u\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type, state );
+
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
 
@@ -440,6 +451,8 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -472,6 +485,8 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
     /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     if (do_fsync())
         return fsync_set_event( handle, prev_state );
 
@@ -498,6 +513,8 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
     /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     if (do_fsync())
         return fsync_reset_event( handle, prev_state );
 
@@ -534,6 +551,8 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 {
     unsigned int ret;
 
+    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+
     if (do_fsync())
         return fsync_pulse_event( handle, prev_state );
 
@@ -602,6 +621,9 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, owned %u\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", owned );
+
     *handle = 0;
 
     if (do_fsync())
@@ -634,6 +656,8 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -665,6 +689,8 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 {
     unsigned int ret;
 
+    TRACE( "handle %p, prev_count %p\n", handle, prev_count );
+
     if (do_fsync())
         return fsync_release_mutex( handle, prev_count );
 
@@ -1362,6 +1388,9 @@ NTSTATUS WINAPI NtCreateTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, type %u\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", type );
+
     *handle = 0;
     if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -1389,6 +1418,8 @@ NTSTATUS WINAPI NtOpenTimer( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -1442,6 +1473,8 @@ NTSTATUS WINAPI NtCancelTimer( HANDLE handle, BOOLEAN *state )
 {
     unsigned int ret;
 
+    TRACE( "handle %p, state %p\n", handle, state );
+
     SERVER_START_REQ( cancel_timer )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1510,9 +1543,17 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
 {
     select_op_t select_op;
     UINT i, flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
+    if (TRACE_ON(sync))
+    {
+        TRACE( "wait_any %u, alertable %u, handles {%p", wait_any, alertable, handles[0] );
+        for (i = 1; i < count; i++) TRACE( ", %p", handles[i] );
+        TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
+    }
+
     if (do_fsync())
     {
         NTSTATUS ret = fsync_wait_objects( count, handles, wait_any, alertable, timeout );
@@ -1530,7 +1571,9 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    return server_wait( &select_op, offsetof( select_op_t, wait.handles[count] ), flags, timeout );
+    ret = server_wait( &select_op, offsetof( select_op_t, wait.handles[count] ), flags, timeout );
+    TRACE( "-> %#x\n", ret );
+    return ret;
 }
 
 
@@ -1552,6 +1595,8 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
+
     if (do_fsync())
         return fsync_signal_and_wait( signal, wait, alertable, timeout );
 
@@ -1799,6 +1844,9 @@ NTSTATUS WINAPI NtCreateKeyedEvent( HANDLE *handle, ACCESS_MASK access,
     data_size_t len;
     struct object_attributes *objattr;
 
+    TRACE( "access %#x, name %s, flags %#x\n", access,
+           attr ? debugstr_us(attr->ObjectName) : "(null)", flags );
+
     *handle = 0;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -1823,6 +1871,8 @@ NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE *handle, ACCESS_MASK access, const OBJE
 {
     unsigned int ret;
 
+    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
+
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -1849,6 +1899,8 @@ NTSTATUS WINAPI NtWaitForKeyedEvent( HANDLE handle, const void *key,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -1868,6 +1920,8 @@ NTSTATUS WINAPI NtReleaseKeyedEvent( HANDLE handle, const void *key,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
+
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
commit a2a6cfe5a144cbcd8866594f0722900e2e22c351
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:17:08 2024 +1000

    ntdll: Use fast synchronization objects.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index d6703289f08..b008f21896d 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -30,9 +30,11 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
 #include <limits.h>
 #include <signal.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
 #include <sys/mman.h>
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
@@ -45,6 +47,7 @@
 #endif
 #include <string.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -55,6 +58,8 @@
 # include <mach/mach_time.h>
 #endif
 
+#include <linux/winesync.h>
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #define NONAMELESSUNION
@@ -261,6 +266,723 @@ static unsigned int validate_open_object_attributes( const OBJECT_ATTRIBUTES *at
     return STATUS_SUCCESS;
 }
 
+/* glibc passes the sigset pointer directly to the linux kernel, but defines
+ * sigset_t to be larger. Manually define the kernel sigset size here. */
+#define KERNEL_SIGSET_SIZE (64 / 8) /* 64 signals / 8 bits per byte */
+
+struct timespec64
+{
+    long long tv_sec;
+    long long tv_nsec;
+};
+
+static int get_linux_sync_device(void)
+{
+    static int fast_sync_fd = -2;
+
+    if (fast_sync_fd == -2)
+    {
+        HANDLE device;
+        int fd, needs_close;
+        NTSTATUS ret;
+
+        SERVER_START_REQ( get_linux_sync_device )
+        {
+            if (!(ret = wine_server_call( req ))) device = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if (!ret)
+        {
+            if (!server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL ))
+            {
+                if (InterlockedCompareExchange( &fast_sync_fd, fd, -2 ) != -2)
+                {
+                    /* someone beat us to it */
+                    if (needs_close) close( fd );
+                    NtClose( device );
+                }
+                /* otherwise don't close the device */
+            }
+            else
+            {
+                InterlockedCompareExchange( &fast_sync_fd, -1, -2 );
+                NtClose( device );
+            }
+        }
+        else
+        {
+            InterlockedCompareExchange( &fast_sync_fd, -1, -2 );
+        }
+    }
+    return fast_sync_fd;
+}
+
+/* It's possible for synchronization primitives to remain alive even after being
+ * closed, because a thread is still waiting on them. It's rare in practice, and
+ * documented as being undefined behaviour by Microsoft, but it works, and some
+ * applications rely on it. This means we need to refcount handles, and defer
+ * deleting them on the server side until the refcount reaches zero. We do this
+ * by having each client process hold a handle to the fast synchronization
+ * object, as well as a private refcount. When the client refcount reaches zero,
+ * it closes the handle; when all handles are closed, the server deletes the
+ * fast synchronization object.
+ *
+ * We want lookup of objects from the cache to be very fast; ideally, it should
+ * be lock-free. We achieve this by using atomic modifications to "refcount",
+ * and guaranteeing that all other fields are valid and correct *as long as*
+ * refcount is nonzero, and we store the entire structure in memory which will
+ * never be freed.
+ *
+ * This means that acquiring the object can't use a simple atomic increment; it
+ * has to use a compare-and-swap loop to ensure that it doesn't try to increment
+ * an object with a zero refcount. That's still leagues better than a real lock,
+ * though, and release can be a single atomic decrement.
+ *
+ * It also means that threads modifying the cache need to take a lock, to
+ * prevent other threads from writing to it concurrently.
+ *
+ * It's possible for an object currently in use (by a waiter) to be closed and
+ * the same handle immediately reallocated to a different object. This should be
+ * a very rare situation, and in that case we simply don't cache the handle.
+ */
+struct fast_sync_cache_entry
+{
+    LONG refcount;
+    unsigned int obj;
+    enum fast_sync_type type;
+    unsigned int access;
+    BOOL closed;
+    /* handle to the underlying fast sync object, stored as obj_handle_t to save
+     * space */
+    obj_handle_t handle;
+};
+
+
+static void release_fast_sync_obj( struct fast_sync_cache_entry *cache )
+{
+    /* save the handle now; as soon as the refcount hits 0 we cannot access the
+     * cache anymore */
+    HANDLE handle = wine_server_ptr_handle( cache->handle );
+    LONG refcount = InterlockedDecrement( &cache->refcount );
+
+    assert( refcount >= 0 );
+
+    if (!refcount)
+    {
+        NTSTATUS ret = NtClose( handle );
+        assert( !ret );
+    }
+}
+
+
+static BOOL fast_sync_types_match( enum fast_sync_type a, enum fast_sync_type b )
+{
+    if (a == b) return TRUE;
+    if (a == FAST_SYNC_AUTO_EVENT && b == FAST_SYNC_MANUAL_EVENT) return TRUE;
+    if (b == FAST_SYNC_AUTO_EVENT && a == FAST_SYNC_MANUAL_EVENT) return TRUE;
+    return FALSE;
+}
+
+
+/* returns a pointer to a cache entry; if the object could not be cached,
+ * returns "stack_cache" instead, which should be allocated on stack */
+static NTSTATUS get_fast_sync_obj( HANDLE handle, enum fast_sync_type desired_type, ACCESS_MASK desired_access,
+                                   struct fast_sync_cache_entry *stack_cache,
+                                   struct fast_sync_cache_entry **ret_cache )
+{
+    struct fast_sync_cache_entry *cache = stack_cache;
+    NTSTATUS ret;
+
+    *ret_cache = stack_cache;
+
+    SERVER_START_REQ( get_linux_sync_obj )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            cache->handle = reply->handle;
+            cache->access = reply->access;
+            cache->type = reply->type;
+            cache->obj = reply->obj;
+            cache->refcount = 1;
+            cache->closed = FALSE;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (!ret && desired_type && !fast_sync_types_match( cache->type, desired_type ))
+    {
+        release_fast_sync_obj( cache );
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if (!ret && (cache->access & desired_access) != desired_access)
+    {
+        release_fast_sync_obj( cache );
+        return STATUS_ACCESS_DENIED;
+    }
+
+    return ret;
+}
+
+
+static NTSTATUS linux_release_semaphore_obj( int device, unsigned int obj, ULONG count, ULONG *prev_count )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    args.count = count;
+    ret = ioctl( device, WINESYNC_IOC_PUT_SEM, &args );
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_SEMAPHORE,
+                                  SEMAPHORE_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_semaphore_obj( device, cache->obj, count, prev_count );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_semaphore_obj( int device, unsigned int obj, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct winesync_sem_args args = {0};
+    NTSTATUS ret;
+
+    args.sem = obj;
+    ret = ioctl( device, WINESYNC_IOC_READ_SEM, &args );
+
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->CurrentCount = args.count;
+    info->MaximumCount = args.max;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_SEMAPHORE,
+                                  SEMAPHORE_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_semaphore_obj( device, cache->obj, info );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_set_event_obj( int device, unsigned int obj, LONG *prev_state )
+{
+    struct winesync_event_args args = {0};
+    NTSTATUS ret;
+
+    args.event = obj;
+    ret = ioctl( device, WINESYNC_IOC_SET_EVENT, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_set_event( HANDLE handle, LONG *prev_state )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_AUTO_EVENT,
+                                  EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_set_event_obj( device, cache->obj, prev_state );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_reset_event_obj( int device, unsigned int obj, LONG *prev_state )
+{
+    struct winesync_event_args args = {0};
+    NTSTATUS ret;
+
+    args.event = obj;
+    ret = ioctl( device, WINESYNC_IOC_RESET_EVENT, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_reset_event( HANDLE handle, LONG *prev_state )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_AUTO_EVENT,
+                                  EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_reset_event_obj( device, cache->obj, prev_state );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_pulse_event_obj( int device, unsigned int obj, LONG *prev_state )
+{
+    struct winesync_event_args args = {0};
+    NTSTATUS ret;
+
+    args.event = obj;
+    ret = ioctl( device, WINESYNC_IOC_PULSE_EVENT, &args );
+    if (ret < 0)
+        return errno_to_status( errno );
+    if (prev_state) *prev_state = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_pulse_event( HANDLE handle, LONG *prev_state )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_AUTO_EVENT,
+                                  EVENT_MODIFY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_pulse_event_obj( device, cache->obj, prev_state );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_event_obj( int device, unsigned int obj, enum fast_sync_type type, EVENT_BASIC_INFORMATION *info )
+{
+    struct winesync_event_args args = {0};
+    NTSTATUS ret;
+
+    args.event = obj;
+    ret = ioctl( device, WINESYNC_IOC_READ_EVENT, &args );
+
+    if (ret < 0)
+        return errno_to_status( errno );
+    info->EventType = (type == FAST_SYNC_AUTO_EVENT) ? SynchronizationEvent : NotificationEvent;
+    info->EventState = args.signaled;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_AUTO_EVENT,
+                                  EVENT_QUERY_STATE, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_event_obj( device, cache->obj, cache->type, info );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_release_mutex_obj( int device, unsigned int obj, LONG *prev_count )
+{
+    struct winesync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.mutex = obj;
+    args.owner = GetCurrentThreadId();
+    ret = ioctl( device, WINESYNC_IOC_PUT_MUTEX, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOVERFLOW)
+            return STATUS_MUTANT_LIMIT_EXCEEDED;
+        else if (errno == EPERM)
+            return STATUS_MUTANT_NOT_OWNED;
+        else
+            return errno_to_status( errno );
+    }
+    if (prev_count) *prev_count = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_release_mutex( HANDLE handle, LONG *prev_count )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_MUTEX, 0, &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_release_mutex_obj( device, cache->obj, prev_count );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+
+static NTSTATUS linux_query_mutex_obj( int device, unsigned int obj, MUTANT_BASIC_INFORMATION *info )
+{
+    struct winesync_mutex_args args = {0};
+    NTSTATUS ret;
+
+    args.mutex = obj;
+    ret = ioctl( device, WINESYNC_IOC_READ_MUTEX, &args );
+
+    if (ret < 0)
+    {
+        if (errno == EOWNERDEAD)
+        {
+            info->AbandonedState = TRUE;
+            info->OwnedByCaller = FALSE;
+            info->CurrentCount = 1;
+            return STATUS_SUCCESS;
+        }
+        else
+            return errno_to_status( errno );
+    }
+    info->AbandonedState = FALSE;
+    info->OwnedByCaller = (args.owner == GetCurrentThreadId());
+    info->CurrentCount = 1 - args.count;
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS fast_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
+{
+    struct fast_sync_cache_entry stack_cache, *cache;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( handle, FAST_SYNC_MUTEX, MUTANT_QUERY_STATE,
+                                  &stack_cache, &cache )))
+        return ret;
+
+    ret = linux_query_mutex_obj( device, cache->obj, info );
+
+    release_fast_sync_obj( cache );
+    return ret;
+}
+
+static void timespec64_from_timeout( struct timespec64 *timespec, const LARGE_INTEGER *timeout )
+{
+    struct timespec now;
+    timeout_t relative;
+
+    clock_gettime( CLOCK_MONOTONIC, &now );
+
+    if (timeout->QuadPart <= 0)
+    {
+        relative = -timeout->QuadPart;
+    }
+    else
+    {
+        LARGE_INTEGER system_now;
+
+        /* the system clock is REALTIME, so we need to convert to
+         * relative time first */
+        NtQuerySystemTime( &system_now );
+        relative = timeout->QuadPart - system_now.QuadPart;
+    }
+
+    timespec->tv_sec = now.tv_sec + (relative / TICKSPERSEC);
+    timespec->tv_nsec = now.tv_nsec + ((relative % TICKSPERSEC) * 100);
+    if (timespec->tv_nsec >= 1000000000)
+    {
+        timespec->tv_nsec -= 1000000000;
+        ++timespec->tv_sec;
+    }
+}
+
+static void select_queue( HANDLE queue )
+{
+    SERVER_START_REQ( fast_select_queue )
+    {
+        req->handle = wine_server_obj_handle( queue );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static void unselect_queue( HANDLE queue, BOOL signaled )
+{
+    SERVER_START_REQ( fast_unselect_queue )
+    {
+        req->handle = wine_server_obj_handle( queue );
+        req->signaled = signaled;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+static unsigned int get_fast_alert_obj(void)
+{
+    struct ntdll_thread_data *data = ntdll_get_thread_data();
+    struct fast_sync_cache_entry stack_cache, *cache;
+    HANDLE alert_handle;
+    NTSTATUS ret;
+
+    if (!data->fast_alert_obj)
+    {
+        SERVER_START_REQ( get_fast_alert_event )
+        {
+            if ((ret = wine_server_call( req )))
+                ERR( "failed to get fast alert event, status %#x\n", ret );
+            alert_handle = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+
+        if ((ret = get_fast_sync_obj( alert_handle, 0, SYNCHRONIZE, &stack_cache, &cache )))
+            ERR( "failed to get fast alert obj, status %#x\n", ret );
+        data->fast_alert_obj = cache->obj;
+        release_fast_sync_obj( cache );
+        NtClose( alert_handle );
+    }
+
+    return data->fast_alert_obj;
+}
+
+static NTSTATUS linux_wait_objs( int device, const DWORD count, const unsigned int *objs,
+                                BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct winesync_wait_args args = {0};
+    struct timespec64 timespec;
+    uintptr_t timeout_ptr = 0;
+    unsigned long request;
+    int ret;
+
+    if (timeout && timeout->QuadPart != TIMEOUT_INFINITE)
+    {
+        timeout_ptr = (uintptr_t)&timespec;
+        timespec64_from_timeout( &timespec, timeout );
+    }
+    args.objs = (uintptr_t)objs;
+    args.count = count;
+    args.owner = GetCurrentThreadId();
+    args.index = ~0u;
+
+    if (alertable)
+        args.alert = get_fast_alert_obj();
+
+    if (wait_any || count == 1)
+        request = WINESYNC_IOC_WAIT_ANY;
+    else
+        request = WINESYNC_IOC_WAIT_ALL;
+
+    args.timeout = timeout_ptr;
+    do
+    {
+        ret = ioctl( device, request, &args );
+    } while (ret < 0 && errno == EINTR);
+
+    if (!ret)
+    {
+        if (args.index == count)
+        {
+            static const LARGE_INTEGER timeout;
+
+            ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &timeout );
+            assert( ret == STATUS_USER_APC );
+            return ret;
+        }
+
+        return wait_any ? args.index : 0;
+    }
+    else if (errno == EOWNERDEAD)
+        return STATUS_ABANDONED + (wait_any ? args.index : 0);
+    else if (errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    else
+        return errno_to_status( errno );
+}
+
+static NTSTATUS fast_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                           BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct fast_sync_cache_entry stack_cache[64], *cache[64];
+    unsigned int objs[64];
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    DWORD i, j;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    for (i = 0; i < count; ++i)
+    {
+        if ((ret = get_fast_sync_obj( handles[i], 0, SYNCHRONIZE, &stack_cache[i], &cache[i] )))
+        {
+            for (j = 0; j < i; ++j)
+                release_fast_sync_obj( cache[j] );
+            return ret;
+        }
+        if (cache[i]->type == FAST_SYNC_QUEUE)
+            queue = handles[i];
+
+        objs[i] = cache[i]->obj;
+    }
+
+    if (queue) select_queue( queue );
+
+    ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );
+
+    if (queue) unselect_queue( queue, handles[ret] == queue );
+
+    for (i = 0; i < count; ++i)
+        release_fast_sync_obj( cache[i] );
+
+    return ret;
+}
+
+static NTSTATUS fast_signal_and_wait( HANDLE signal, HANDLE wait,
+                                      BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct fast_sync_cache_entry signal_stack_cache, *signal_cache;
+    struct fast_sync_cache_entry wait_stack_cache, *wait_cache;
+    HANDLE queue = NULL;
+    NTSTATUS ret;
+    int device;
+
+    if ((device = get_linux_sync_device()) < 0)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if ((ret = get_fast_sync_obj( signal, 0, 0, &signal_stack_cache, &signal_cache )))
+        return ret;
+
+    switch (signal_cache->type)
+    {
+        case FAST_SYNC_SEMAPHORE:
+            if (!(signal_cache->access & SEMAPHORE_MODIFY_STATE))
+            {
+                release_fast_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case FAST_SYNC_AUTO_EVENT:
+        case FAST_SYNC_MANUAL_EVENT:
+            if (!(signal_cache->access & EVENT_MODIFY_STATE))
+            {
+                release_fast_sync_obj( signal_cache );
+                return STATUS_ACCESS_DENIED;
+            }
+            break;
+
+        case FAST_SYNC_MUTEX:
+            break;
+
+        default:
+            /* can't be signaled */
+            release_fast_sync_obj( signal_cache );
+            return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+
+    if ((ret = get_fast_sync_obj( wait, 0, SYNCHRONIZE, &wait_stack_cache, &wait_cache )))
+    {
+        release_fast_sync_obj( signal_cache );
+        return ret;
+    }
+
+    if (wait_cache->type == FAST_SYNC_QUEUE)
+        queue = wait;
+
+    switch (signal_cache->type)
+    {
+        case FAST_SYNC_SEMAPHORE:
+            ret = linux_release_semaphore_obj( device, signal_cache->obj, 1, NULL );
+            break;
+
+        case FAST_SYNC_AUTO_EVENT:
+        case FAST_SYNC_MANUAL_EVENT:
+            ret = linux_set_event_obj( device, signal_cache->obj, NULL );
+            break;
+
+        case FAST_SYNC_MUTEX:
+            ret = linux_release_mutex_obj( device, signal_cache->obj, NULL );
+            break;
+
+        default:
+            assert( 0 );
+            break;
+    }
+
+    if (!ret)
+    {
+        if (queue) select_queue( queue );
+        ret = linux_wait_objs( device, 1, &wait_cache->obj, TRUE, alertable, timeout );
+        if (queue) unselect_queue( queue, !ret );
+    }
+
+    release_fast_sync_obj( signal_cache );
+    release_fast_sync_obj( wait_cache );
+    return ret;
+}
 
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
@@ -354,6 +1076,12 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
 
     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if ((ret = fast_query_semaphore( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
+        return ret;
+    }
+
     if (do_fsync())
         return fsync_query_semaphore( handle, info, ret_len );
 
@@ -384,6 +1112,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 
     TRACE( "handle %p, count %u, prev_count %p\n", handle, count, previous );
 
+    if ((ret = fast_release_semaphore( handle, count, previous )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (do_fsync())
         return fsync_release_semaphore( handle, count, previous );
 
@@ -487,6 +1218,9 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = fast_set_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (do_fsync())
         return fsync_set_event( handle, prev_state );
 
@@ -515,6 +1249,9 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = fast_reset_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (do_fsync())
         return fsync_reset_event( handle, prev_state );
 
@@ -553,6 +1290,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 
     TRACE( "handle %p, prev_state %p\n", handle, prev_state );
 
+    if ((ret = fast_pulse_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (do_fsync())
         return fsync_pulse_event( handle, prev_state );
 
@@ -590,6 +1330,12 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
 
     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if ((ret = fast_query_event( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
+        return ret;
+    }
+
     if (do_fsync())
         return fsync_query_event( handle, info, ret_len );
 
@@ -691,6 +1437,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 
     TRACE( "handle %p, prev_count %p\n", handle, prev_count );
 
+    if ((ret = fast_release_mutex( handle, prev_count )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (do_fsync())
         return fsync_release_mutex( handle, prev_count );
 
@@ -727,6 +1476,12 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
 
     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if ((ret = fast_query_mutex( handle, out )) != STATUS_NOT_IMPLEMENTED)
+    {
+        if (!ret && ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
+        return ret;
+    }
+
     if (do_fsync())
         return fsync_query_mutex( handle, info, ret_len );
 
@@ -1554,6 +2309,12 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
         TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
     }
 
+    if ((ret = fast_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+    {
+        TRACE( "-> %#x\n", ret );
+        return ret;
+    }
+
     if (do_fsync())
     {
         NTSTATUS ret = fsync_wait_objects( count, handles, wait_any, alertable, timeout );
@@ -1594,6 +2355,7 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 {
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
+    NTSTATUS ret;
 
     TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
 
@@ -1605,6 +2367,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 
     if (!signal) return STATUS_INVALID_HANDLE;
 
+    if ((ret = fast_signal_and_wait( signal, wait, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+        return ret;
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
     select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 46cc5f1391a..036f335a000 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -68,6 +68,7 @@ struct ntdll_thread_data
     PRTL_THREAD_START_ROUTINE start;  /* thread entry point */
     void              *param;         /* thread entry point parameter */
     void              *jmp_buf;       /* setjmp buffer for exception handling */
+    unsigned int       fast_alert_obj; /* linux object for the fast alert event */
 };
 
 C_ASSERT( sizeof(struct ntdll_thread_data) <= sizeof(((TEB *)0)->GdiTebBatch) );
commit a1fb8ee031eeb1089e37d1c7c1be0d304f8cc933
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:17:49 2024 +1000

    ntdll: Use server_wait_for_object() when waiting on only the queue object.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index b008f21896d..8b19ec3ce53 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -888,6 +888,17 @@ static NTSTATUS fast_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
         objs[i] = cache[i]->obj;
     }
 
+    /* It's common to wait on the message queue alone. Some applications wait
+     * on it in fast paths, with a zero timeout. Since we take two server calls
+     * instead of one when going through fast_wait_objs(), and since we only
+     * need to go through that path if we're waiting on other objects, just
+     * delegate to the server if we're only waiting on the message queue. */
+    if (count == 1 && queue)
+    {
+        release_fast_sync_obj( cache[0] );
+        return server_wait_for_object( handles[0], alertable, timeout );
+    }
+
     if (queue) select_queue( queue );
 
     ret = linux_wait_objs( device, count, objs, wait_any, alertable, timeout );
commit 5399a4b6019b0f9e2a37568046d2cc0391a284d8
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:18:37 2024 +1000

    ntdll: Cache fast synchronization objects.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 61408e09857..d961660b89a 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1710,12 +1710,17 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source, HANDLE
         return result.dup_handle.status;
     }
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     if (options & DUPLICATE_CLOSE_SOURCE)
+    {
         fd = remove_fd_from_cache( source );
+        close_fast_sync_obj( source );
+    }
 
     SERVER_START_REQ( dup_handle )
     {
@@ -1771,12 +1776,16 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     if (HandleToLong( handle ) >= ~5 && HandleToLong( handle ) <= ~0)
         return STATUS_SUCCESS;
 
+    /* hold fd_cache_mutex to prevent the fd from being added again between the
+     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     fd = remove_fd_from_cache( handle );
 
+    close_fast_sync_obj( handle );
+
     if (do_fsync())
         fsync_close( handle );
 
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 8b19ec3ce53..51b399f09be 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -328,6 +328,12 @@ static int get_linux_sync_device(void)
  * it closes the handle; when all handles are closed, the server deletes the
  * fast synchronization object.
  *
+ * We also need this for signal-and-wait. The signal and wait operations aren't
+ * atomic, but we can't perform the signal and then return STATUS_INVALID_HANDLE
+ * for the waitwe need to either do both operations or neither. That means we
+ * need to grab references to both objects, and prevent them from being
+ * destroyed before we're done with them.
+ *
  * We want lookup of objects from the cache to be very fast; ideally, it should
  * be lock-free. We achieve this by using atomic modifications to "refcount",
  * and guaranteeing that all other fields are valid and correct *as long as*
@@ -370,12 +376,138 @@ static void release_fast_sync_obj( struct fast_sync_cache_entry *cache )
 
     if (!refcount)
     {
-        NTSTATUS ret = NtClose( handle );
+        NTSTATUS ret;
+
+        /* we can't call NtClose here as we may be inside fd_cache_mutex */
+        SERVER_START_REQ( close_handle )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
         assert( !ret );
     }
 }
 
 
+#define FAST_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct fast_sync_cache_entry))
+#define FAST_SYNC_CACHE_ENTRIES     128
+
+static struct fast_sync_cache_entry *fast_sync_cache[FAST_SYNC_CACHE_ENTRIES];
+static struct fast_sync_cache_entry fast_sync_cache_initial_block[FAST_SYNC_CACHE_BLOCK_SIZE];
+
+static inline unsigned int fast_sync_handle_to_index( HANDLE handle, unsigned int *entry )
+{
+    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
+    *entry = idx / FAST_SYNC_CACHE_BLOCK_SIZE;
+    return idx % FAST_SYNC_CACHE_BLOCK_SIZE;
+}
+
+
+static struct fast_sync_cache_entry *cache_fast_sync_obj( HANDLE handle, obj_handle_t fast_sync, int obj,
+                                                          enum fast_sync_type type, unsigned int access )
+{
+    unsigned int entry, idx = fast_sync_handle_to_index( handle, &entry );
+    struct fast_sync_cache_entry *cache;
+    sigset_t sigset;
+    int refcount;
+
+    if (entry >= FAST_SYNC_CACHE_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return NULL;
+    }
+
+    if (!fast_sync_cache[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) fast_sync_cache[0] = fast_sync_cache_initial_block;
+        else
+        {
+            static const size_t size = FAST_SYNC_CACHE_BLOCK_SIZE * sizeof(struct fast_sync_cache_entry);
+            void *ptr = anon_mmap_alloc( size, PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return NULL;
+            if (InterlockedCompareExchangePointer( (void **)&fast_sync_cache[entry], ptr, NULL ))
+                munmap( ptr, size ); /* someone beat us to it */
+        }
+    }
+
+    cache = &fast_sync_cache[entry][idx];
+
+    /* Hold fd_cache_mutex instead of a separate mutex, to prevent the same
+     * race between this function and NtClose. That is, prevent the object from
+     * being cached again between close_fast_sync_obj() and close_handle. */
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (InterlockedCompareExchange( &cache->refcount, 0, 0 ))
+    {
+        /* We lost the race with another thread trying to cache this object, or
+         * the handle is currently being used for another object (i.e. it was
+         * closed and then reused). We have no way of knowing which, and in the
+         * latter case we can't cache this object until the old one is
+         * completely destroyed, so always return failure. */
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+        return NULL;
+    }
+
+    cache->handle = fast_sync;
+    cache->obj = obj;
+    cache->type = type;
+    cache->access = access;
+    cache->closed = FALSE;
+    /* Make sure we set the other members before the refcount; this store needs
+     * release semantics [paired with the load in get_cached_fast_sync_obj()].
+     * Set the refcount to 2 (one for the handle, one for the caller). */
+    refcount = InterlockedExchange( &cache->refcount, 2 );
+    assert( !refcount );
+
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    return cache;
+}
+
+
+/* returns the previous value */
+static inline LONG interlocked_inc_if_nonzero( LONG *dest )
+{
+    LONG val, tmp;
+    for (val = *dest;; val = tmp)
+    {
+        if (!val || (tmp = InterlockedCompareExchange( dest, val + 1, val )) == val)
+            break;
+    }
+    return val;
+}
+
+
+static struct fast_sync_cache_entry *get_cached_fast_sync_obj( HANDLE handle )
+{
+    unsigned int entry, idx = fast_sync_handle_to_index( handle, &entry );
+    struct fast_sync_cache_entry *cache;
+
+    if (entry >= FAST_SYNC_CACHE_ENTRIES || !fast_sync_cache[entry])
+        return NULL;
+
+    cache = &fast_sync_cache[entry][idx];
+
+    /* this load needs acquire semantics [paired with the store in
+     * cache_fast_sync_obj()] */
+    if (!interlocked_inc_if_nonzero( &cache->refcount ))
+        return NULL;
+
+    if (cache->closed)
+    {
+        /* The object is still being used, but "handle" has been closed. The
+         * handle value might have been reused for another object in the
+         * meantime, in which case we have to report that valid object, so
+         * force the caller to check the server. */
+        release_fast_sync_obj( cache );
+        return NULL;
+    }
+
+    return cache;
+}
+
+
 static BOOL fast_sync_types_match( enum fast_sync_type a, enum fast_sync_type b )
 {
     if (a == b) return TRUE;
@@ -391,42 +523,80 @@ static NTSTATUS get_fast_sync_obj( HANDLE handle, enum fast_sync_type desired_ty
                                    struct fast_sync_cache_entry *stack_cache,
                                    struct fast_sync_cache_entry **ret_cache )
 {
-    struct fast_sync_cache_entry *cache = stack_cache;
+    struct fast_sync_cache_entry *cache;
+    obj_handle_t fast_sync_handle;
+    enum fast_sync_type type;
+    unsigned int access;
     NTSTATUS ret;
+    int obj;
 
-    *ret_cache = stack_cache;
+    /* try to find it in the cache already */
+    if ((cache = get_cached_fast_sync_obj( handle )))
+    {
+        *ret_cache = cache;
+        return STATUS_SUCCESS;
+    }
 
+    /* try to retrieve it from the server */
     SERVER_START_REQ( get_linux_sync_obj )
     {
         req->handle = wine_server_obj_handle( handle );
         if (!(ret = wine_server_call( req )))
         {
-            cache->handle = reply->handle;
-            cache->access = reply->access;
-            cache->type = reply->type;
-            cache->obj = reply->obj;
-            cache->refcount = 1;
-            cache->closed = FALSE;
+            fast_sync_handle = reply->handle;
+            access = reply->access;
+            type = reply->type;
+            obj = reply->obj;
         }
     }
     SERVER_END_REQ;
 
-    if (!ret && desired_type && !fast_sync_types_match( cache->type, desired_type ))
+    if (ret) return ret;
+
+    cache = cache_fast_sync_obj( handle, fast_sync_handle, obj, type, access );
+    if (!cache)
+    {
+        cache = stack_cache;
+        cache->handle = fast_sync_handle;
+        cache->obj = obj;
+        cache->type = type;
+        cache->access = access;
+        cache->closed = FALSE;
+        cache->refcount = 1;
+    }
+
+    *ret_cache = cache;
+
+    if (desired_type && !fast_sync_types_match( cache->type, desired_type ))
     {
         release_fast_sync_obj( cache );
         return STATUS_OBJECT_TYPE_MISMATCH;
     }
 
-    if (!ret && (cache->access & desired_access) != desired_access)
+    if ((cache->access & desired_access) != desired_access)
     {
         release_fast_sync_obj( cache );
         return STATUS_ACCESS_DENIED;
     }
 
-    return ret;
+    return STATUS_SUCCESS;
 }
 
 
+/* caller must hold fd_cache_mutex */
+void close_fast_sync_obj( HANDLE handle )
+{
+    struct fast_sync_cache_entry *cache = get_cached_fast_sync_obj( handle );
+
+    if (cache)
+    {
+        cache->closed = TRUE;
+        /* once for the reference we just grabbed, and once for the handle */
+        release_fast_sync_obj( cache );
+        release_fast_sync_obj( cache );
+    }
+}
+
 static NTSTATUS linux_release_semaphore_obj( int device, unsigned int obj, ULONG count, ULONG *prev_count )
 {
     struct winesync_sem_args args = {0};
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 036f335a000..b002693b788 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -176,6 +176,8 @@ extern NTSTATUS load_main_exe( const WCHAR *name, const char *unix_name, const W
 extern NTSTATUS load_start_exe( WCHAR **image, void **module ) DECLSPEC_HIDDEN;
 extern void start_server( BOOL debug ) DECLSPEC_HIDDEN;
 
+extern pthread_mutex_t fd_cache_mutex DECLSPEC_HIDDEN;
+
 extern unsigned int server_call_unlocked( void *req_ptr ) DECLSPEC_HIDDEN;
 extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
 extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
@@ -310,6 +312,8 @@ extern struct cpu_topology_override *get_cpu_topology_override(void) DECLSPEC_HI
 
 extern void dbg_init(void) DECLSPEC_HIDDEN;
 
+extern void close_fast_sync_obj( HANDLE handle ) DECLSPEC_HIDDEN;
+
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3,
                                           PNTAPCFUNC func, NTSTATUS status ) DECLSPEC_HIDDEN;
 extern NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context ) DECLSPEC_HIDDEN;
commit 05fdb2d7736f52e7b9efa02d62bd73dbfcd3862a
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:19:24 2024 +1000

    server: Allow disabling fast synchronization support.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail
    
    I've added extra checks inside all implementations of do_esync and
    do_fsync to avoid either esync or fsync accidentally starting when
    fastsync is active.
    
    This means that unless the Proton environment sets
    WINE_DISABLE_FAST_SYNC to 1 by default, fastsync *is* the default
    instead of esync/fsync.

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 56fdd150175..41c68c78d30 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -58,7 +58,8 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync() &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
 
     return do_esync_cached;
 #else
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index c265d6c02e0..f189a1f08f4 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -172,7 +172,8 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, NULL, 0, 0, NULL, 0 );
-        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
     }
 
     return do_fsync_cached;
diff --git a/server/esync.c b/server/esync.c
index 66e074d86bd..1803c1a4d91 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -51,7 +51,8 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync() &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
 
     return do_esync_cached;
 #else
diff --git a/server/fast_sync.c b/server/fast_sync.c
index 1d7d5ddff52..fbe312e74f1 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -126,6 +126,12 @@ static struct linux_device *get_linux_device(void)
     struct linux_device *device;
     int unix_fd;
 
+    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return NULL;
+    }
+
     if (linux_device_object)
         return (struct linux_device *)grab_object( linux_device_object );
 
diff --git a/server/fsync.c b/server/fsync.c
index d401f9d3fda..44b6a69ec60 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -59,7 +59,8 @@ int do_fsync(void)
     if (do_fsync_cached == -1)
     {
         syscall( __NR_futex_waitv, 0, 0, 0, 0, 0);
-        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS &&
+                          getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) );
     }
 
     return do_fsync_cached;
diff --git a/server/main.c b/server/main.c
index 898e9af202d..67313ea315f 100644
--- a/server/main.c
+++ b/server/main.c
@@ -231,15 +231,17 @@ int main( int argc, char *argv[] )
 
     sock_init();
     open_master_socket();
+    if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
+    {
+        if (do_fsync())
+            fsync_init();
 
-    if (do_fsync())
-        fsync_init();
-
-    if (do_esync())
-        esync_init();
+        if (do_esync())
+            esync_init();
 
-    if (!do_fsync() && !do_esync())
-        fprintf( stderr, "wineserver: using server-side synchronization.\n" );
+        if (!do_fsync() && !do_esync())
+            fprintf( stderr, "wineserver: using server-side synchronization.\n" );
+    }
 
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
commit 551f7c19bab9a08e74a4709f58be6e4d8fdbc7da
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:20:13 2024 +1000

    server: Add a message to signal that fast synchronization is indeed active.
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail
    
    I've also added what could be a fix for fastsync not reporting
    that wineserver sync is active if fastsync fails for whatever reason,
    with additional reporting similar to the staging version for why it
    fails.

diff --git a/server/fast_sync.c b/server/fast_sync.c
index fbe312e74f1..2fbc99d45aa 100644
--- a/server/fast_sync.c
+++ b/server/fast_sync.c
@@ -125,6 +125,7 @@ static struct linux_device *get_linux_device(void)
 {
     struct linux_device *device;
     int unix_fd;
+    static int wineserver_once;
 
     if (getenv( "WINE_DISABLE_FAST_SYNC" ) && atoi( getenv( "WINE_DISABLE_FAST_SYNC" ) ))
     {
@@ -139,6 +140,10 @@ static struct linux_device *get_linux_device(void)
     if (unix_fd == -1)
     {
         file_set_error();
+        if (!wineserver_once++) {
+            fprintf( stderr, "fastsync: /dev/winesync not available. (Please check winesync module)\n" );
+            fprintf( stderr, "wineserver: using server-side synchronization.\n" );
+        }
         return NULL;
     }
 
@@ -146,6 +151,10 @@ static struct linux_device *get_linux_device(void)
     {
         close( unix_fd );
         set_error( STATUS_NO_MEMORY );
+        if (!wineserver_once++) {
+            fprintf( stderr, "fastsync: failed to allocate object.\n" );
+            fprintf( stderr, "wineserver: using server-side synchronization.\n" );
+        }
         return NULL;
     }
 
@@ -153,6 +162,10 @@ static struct linux_device *get_linux_device(void)
     {
         release_object( device );
         set_error( STATUS_NO_MEMORY );
+        if (!wineserver_once++) {
+            fprintf( stderr, "fastsync: failed to allocate anonymous fd.\n" );
+            fprintf( stderr, "wineserver: using server-side synchronization.\n" );
+        }
         return NULL;
     }
 
@@ -370,6 +383,10 @@ DECL_HANDLER(get_linux_sync_device)
 DECL_HANDLER(get_linux_sync_obj)
 {
     struct object *obj;
+    static int once;
+
+    if (!once++)
+        fprintf( stderr, "wine: using fast synchronization.\n" );
 
     if ((obj = get_handle_obj( current->process, req->handle, 0, NULL )))
     {
commit cff36a55eadcdfab46eb896dbaa6a67afa4a9f48
Author: Jean-Luc Mackail <fuzzyquils@scrapyard.link>
Date:   Thu Jan 4 12:20:54 2024 +1000

    make_req
    
    Original author: Zebediah Figura
    
    Proton Experimental 8.0 port: Jean-Luc Mackail

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 472c0ea709d..0fe498203b5 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5503,6 +5503,87 @@ struct get_next_thread_reply
     char __pad_12[4];
 };
 
+enum fast_sync_type
+{
+    FAST_SYNC_SEMAPHORE = 1,
+    FAST_SYNC_MUTEX,
+    FAST_SYNC_AUTO_EVENT,
+    FAST_SYNC_MANUAL_EVENT,
+    FAST_SYNC_AUTO_SERVER,
+    FAST_SYNC_MANUAL_SERVER,
+    FAST_SYNC_QUEUE,
+};
+
+
+
+struct get_linux_sync_device_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_linux_sync_device_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
+
+
+
+struct get_linux_sync_obj_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_linux_sync_obj_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          obj;
+    int          type;
+    unsigned int access;
+};
+
+
+
+struct fast_select_queue_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct fast_select_queue_reply
+{
+    struct reply_header __header;
+};
+
+
+
+struct fast_unselect_queue_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          signaled;
+    char __pad_20[4];
+};
+struct fast_unselect_queue_reply
+{
+    struct reply_header __header;
+};
+
+
+
+struct get_fast_alert_event_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_fast_alert_event_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
+
 
 enum request
 {
@@ -5784,6 +5865,11 @@ enum request
     REQ_suspend_process,
     REQ_resume_process,
     REQ_get_next_thread,
+    REQ_get_linux_sync_device,
+    REQ_get_linux_sync_obj,
+    REQ_fast_select_queue,
+    REQ_fast_unselect_queue,
+    REQ_get_fast_alert_event,
     REQ_NB_REQUESTS
 };
 
@@ -6069,6 +6155,11 @@ union generic_request
     struct suspend_process_request suspend_process_request;
     struct resume_process_request resume_process_request;
     struct get_next_thread_request get_next_thread_request;
+    struct get_linux_sync_device_request get_linux_sync_device_request;
+    struct get_linux_sync_obj_request get_linux_sync_obj_request;
+    struct fast_select_queue_request fast_select_queue_request;
+    struct fast_unselect_queue_request fast_unselect_queue_request;
+    struct get_fast_alert_event_request get_fast_alert_event_request;
 };
 union generic_reply
 {
@@ -6352,11 +6443,16 @@ union generic_reply
     struct suspend_process_reply suspend_process_reply;
     struct resume_process_reply resume_process_reply;
     struct get_next_thread_reply get_next_thread_reply;
+    struct get_linux_sync_device_reply get_linux_sync_device_reply;
+    struct get_linux_sync_obj_reply get_linux_sync_obj_reply;
+    struct fast_select_queue_reply fast_select_queue_reply;
+    struct fast_unselect_queue_reply fast_unselect_queue_reply;
+    struct get_fast_alert_event_reply get_fast_alert_event_reply;
 };
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 758
+#define SERVER_PROTOCOL_VERSION 759
 
 /* ### protocol_version end ### */
 
diff --git a/server/request.h b/server/request.h
index 089af79e199..78888391201 100644
--- a/server/request.h
+++ b/server/request.h
@@ -397,6 +397,11 @@ DECL_HANDLER(terminate_job);
 DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
 DECL_HANDLER(get_next_thread);
+DECL_HANDLER(get_linux_sync_device);
+DECL_HANDLER(get_linux_sync_obj);
+DECL_HANDLER(fast_select_queue);
+DECL_HANDLER(fast_unselect_queue);
+DECL_HANDLER(get_fast_alert_event);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -681,6 +686,11 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_suspend_process,
     (req_handler)req_resume_process,
     (req_handler)req_get_next_thread,
+    (req_handler)req_get_linux_sync_device,
+    (req_handler)req_get_linux_sync_obj,
+    (req_handler)req_fast_select_queue,
+    (req_handler)req_fast_unselect_queue,
+    (req_handler)req_get_fast_alert_event,
 };
 
 C_ASSERT( sizeof(abstime_t) == 8 );
@@ -2272,6 +2282,24 @@ C_ASSERT( FIELD_OFFSET(struct get_next_thread_request, flags) == 28 );
 C_ASSERT( sizeof(struct get_next_thread_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct get_next_thread_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_next_thread_reply) == 16 );
+C_ASSERT( sizeof(struct get_linux_sync_device_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_linux_sync_device_reply, handle) == 8 );
+C_ASSERT( sizeof(struct get_linux_sync_device_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_linux_sync_obj_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_linux_sync_obj_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_linux_sync_obj_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_linux_sync_obj_reply, obj) == 12 );
+C_ASSERT( FIELD_OFFSET(struct get_linux_sync_obj_reply, type) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_linux_sync_obj_reply, access) == 20 );
+C_ASSERT( sizeof(struct get_linux_sync_obj_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct fast_select_queue_request, handle) == 12 );
+C_ASSERT( sizeof(struct fast_select_queue_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct fast_unselect_queue_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct fast_unselect_queue_request, signaled) == 16 );
+C_ASSERT( sizeof(struct fast_unselect_queue_request) == 24 );
+C_ASSERT( sizeof(struct get_fast_alert_event_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fast_alert_event_reply, handle) == 8 );
+C_ASSERT( sizeof(struct get_fast_alert_event_reply) == 16 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/trace.c b/server/trace.c
index b749c54a900..7aef9b10d92 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -4531,6 +4531,49 @@ static void dump_get_next_thread_reply( const struct get_next_thread_reply *req
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+
+static void dump_get_linux_sync_device_request( const struct get_linux_sync_device_request *req )
+{
+}
+
+static void dump_get_linux_sync_device_reply( const struct get_linux_sync_device_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_linux_sync_obj_request( const struct get_linux_sync_obj_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_linux_sync_obj_reply( const struct get_linux_sync_obj_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", obj=%d", req->obj );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", access=%08x", req->access );
+}
+
+static void dump_fast_select_queue_request( const struct fast_select_queue_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_fast_unselect_queue_request( const struct fast_unselect_queue_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", signaled=%d", req->signaled );
+}
+
+static void dump_get_fast_alert_event_request( const struct get_fast_alert_event_request *req )
+{
+}
+
+static void dump_get_fast_alert_event_reply( const struct get_fast_alert_event_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_get_new_process_info_request,
@@ -4810,6 +4853,11 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_suspend_process_request,
     (dump_func)dump_resume_process_request,
     (dump_func)dump_get_next_thread_request,
+    (dump_func)dump_get_linux_sync_device_request,
+    (dump_func)dump_get_linux_sync_obj_request,
+    (dump_func)dump_fast_select_queue_request,
+    (dump_func)dump_fast_unselect_queue_request,
+    (dump_func)dump_get_fast_alert_event_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5091,6 +5139,11 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     (dump_func)dump_get_next_thread_reply,
+    (dump_func)dump_get_linux_sync_device_reply,
+    (dump_func)dump_get_linux_sync_obj_reply,
+    NULL,
+    NULL,
+    (dump_func)dump_get_fast_alert_event_reply,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5372,6 +5425,11 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "suspend_process",
     "resume_process",
     "get_next_thread",
+    "get_linux_sync_device",
+    "get_linux_sync_obj",
+    "fast_select_queue",
+    "fast_unselect_queue",
+    "get_fast_alert_event",
 };
 
 static const struct
